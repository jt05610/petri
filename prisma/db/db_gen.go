// Code generated by Prisma Client Go. DO NOT EDIT.
//nolint
//go:build !codeanalysis
// +build !codeanalysis

package db

import (
	"context"
	"os"
	"testing"

	"github.com/steebchen/prisma-client-go/engine"
	"github.com/steebchen/prisma-client-go/engine/mock"
	"github.com/steebchen/prisma-client-go/runtime/builder"
	"github.com/steebchen/prisma-client-go/runtime/lifecycle"
	"github.com/steebchen/prisma-client-go/runtime/raw"
	"github.com/steebchen/prisma-client-go/runtime/transaction"
	"github.com/steebchen/prisma-client-go/runtime/types"
	rawmodels "github.com/steebchen/prisma-client-go/runtime/types/raw"

	// no-op import for go modules
	_ "github.com/iancoleman/strcase"
	_ "github.com/joho/godotenv"
	_ "github.com/shopspring/decimal"
	_ "github.com/takuoki/gocase"
	_ "golang.org/x/text/cases"
)

// ignore unused os import as it may not be needed depending on engine type
var _ = os.DevNull

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

const RFC3339Milli = types.RFC3339Milli

type BatchResult = types.BatchResult

type DateTime = types.DateTime
type JSON = types.JSON
type Bytes = types.Bytes
type BigInt = types.BigInt
type Decimal = types.Decimal

type RawString = rawmodels.String
type RawInt = rawmodels.Int
type RawFloat = rawmodels.Float
type RawBoolean = rawmodels.Boolean
type RawDateTime = rawmodels.DateTime
type RawJSON = rawmodels.JSON
type RawBytes = rawmodels.Bytes
type RawBigInt = rawmodels.BigInt
type RawDecimal = rawmodels.Decimal

// deprecated: use SortOrder
type Direction = SortOrder

const (
	// deprecated: use SortOrderAsc
	ASC Direction = "asc"
	// deprecated: use SortOrderDesc
	DESC Direction = "desc"
)

// --- template create.gotpl ---

// Creates a single user.
func (r userActions) CreateOne(
	_email UserWithPrismaEmailSetParam,
	_role UserWithPrismaRoleSetParam,

	optional ...UserSetParam,
) userCreateOne {
	var v userCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	var fields []builder.Field

	fields = append(fields, _email.field())
	fields = append(fields, _role.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r userCreateOne) With(params ...UserRelationWith) userCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type userCreateOne struct {
	query builder.Query
}

func (p userCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p userCreateOne) userModel() {}

func (r userCreateOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userCreateOne) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single password.
func (r passwordActions) CreateOne(
	_hash PasswordWithPrismaHashSetParam,
	_user PasswordWithPrismaUserSetParam,

	optional ...PasswordSetParam,
) passwordCreateOne {
	var v passwordCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Password"
	v.query.Outputs = passwordOutput

	var fields []builder.Field

	fields = append(fields, _hash.field())
	fields = append(fields, _user.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r passwordCreateOne) With(params ...PasswordRelationWith) passwordCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type passwordCreateOne struct {
	query builder.Query
}

func (p passwordCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p passwordCreateOne) passwordModel() {}

func (r passwordCreateOne) Exec(ctx context.Context) (*PasswordModel, error) {
	var v PasswordModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r passwordCreateOne) Tx() passwordUniqueTxResult {
	v := NewpasswordUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single net.
func (r netActions) CreateOne(
	_name NetWithPrismaNameSetParam,
	_description NetWithPrismaDescriptionSetParam,
	_author NetWithPrismaAuthorSetParam,

	optional ...NetSetParam,
) netCreateOne {
	var v netCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Net"
	v.query.Outputs = netOutput

	var fields []builder.Field

	fields = append(fields, _name.field())
	fields = append(fields, _description.field())
	fields = append(fields, _author.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r netCreateOne) With(params ...NetRelationWith) netCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type netCreateOne struct {
	query builder.Query
}

func (p netCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p netCreateOne) netModel() {}

func (r netCreateOne) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netCreateOne) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single placeInterface.
func (r placeInterfaceActions) CreateOne(
	_name PlaceInterfaceWithPrismaNameSetParam,
	_net PlaceInterfaceWithPrismaNetSetParam,
	_bound PlaceInterfaceWithPrismaBoundSetParam,

	optional ...PlaceInterfaceSetParam,
) placeInterfaceCreateOne {
	var v placeInterfaceCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "PlaceInterface"
	v.query.Outputs = placeInterfaceOutput

	var fields []builder.Field

	fields = append(fields, _name.field())
	fields = append(fields, _net.field())
	fields = append(fields, _bound.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r placeInterfaceCreateOne) With(params ...PlaceInterfaceRelationWith) placeInterfaceCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type placeInterfaceCreateOne struct {
	query builder.Query
}

func (p placeInterfaceCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p placeInterfaceCreateOne) placeInterfaceModel() {}

func (r placeInterfaceCreateOne) Exec(ctx context.Context) (*PlaceInterfaceModel, error) {
	var v PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeInterfaceCreateOne) Tx() placeInterfaceUniqueTxResult {
	v := NewplaceInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single transitionInterface.
func (r transitionInterfaceActions) CreateOne(
	_name TransitionInterfaceWithPrismaNameSetParam,
	_net TransitionInterfaceWithPrismaNetSetParam,

	optional ...TransitionInterfaceSetParam,
) transitionInterfaceCreateOne {
	var v transitionInterfaceCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "TransitionInterface"
	v.query.Outputs = transitionInterfaceOutput

	var fields []builder.Field

	fields = append(fields, _name.field())
	fields = append(fields, _net.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r transitionInterfaceCreateOne) With(params ...TransitionInterfaceRelationWith) transitionInterfaceCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type transitionInterfaceCreateOne struct {
	query builder.Query
}

func (p transitionInterfaceCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceCreateOne) transitionInterfaceModel() {}

func (r transitionInterfaceCreateOne) Exec(ctx context.Context) (*TransitionInterfaceModel, error) {
	var v TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceCreateOne) Tx() transitionInterfaceUniqueTxResult {
	v := NewtransitionInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single place.
func (r placeActions) CreateOne(
	_name PlaceWithPrismaNameSetParam,
	_bound PlaceWithPrismaBoundSetParam,

	optional ...PlaceSetParam,
) placeCreateOne {
	var v placeCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Place"
	v.query.Outputs = placeOutput

	var fields []builder.Field

	fields = append(fields, _name.field())
	fields = append(fields, _bound.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r placeCreateOne) With(params ...PlaceRelationWith) placeCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type placeCreateOne struct {
	query builder.Query
}

func (p placeCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p placeCreateOne) placeModel() {}

func (r placeCreateOne) Exec(ctx context.Context) (*PlaceModel, error) {
	var v PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeCreateOne) Tx() placeUniqueTxResult {
	v := NewplaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single transition.
func (r transitionActions) CreateOne(
	_name TransitionWithPrismaNameSetParam,

	optional ...TransitionSetParam,
) transitionCreateOne {
	var v transitionCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Transition"
	v.query.Outputs = transitionOutput

	var fields []builder.Field

	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r transitionCreateOne) With(params ...TransitionRelationWith) transitionCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type transitionCreateOne struct {
	query builder.Query
}

func (p transitionCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p transitionCreateOne) transitionModel() {}

func (r transitionCreateOne) Exec(ctx context.Context) (*TransitionModel, error) {
	var v TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionCreateOne) Tx() transitionUniqueTxResult {
	v := NewtransitionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single arc.
func (r arcActions) CreateOne(
	_net ArcWithPrismaNetSetParam,
	_fromPlace ArcWithPrismaFromPlaceSetParam,
	_place ArcWithPrismaPlaceSetParam,
	_transition ArcWithPrismaTransitionSetParam,

	optional ...ArcSetParam,
) arcCreateOne {
	var v arcCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Arc"
	v.query.Outputs = arcOutput

	var fields []builder.Field

	fields = append(fields, _net.field())
	fields = append(fields, _fromPlace.field())
	fields = append(fields, _place.field())
	fields = append(fields, _transition.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r arcCreateOne) With(params ...ArcRelationWith) arcCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type arcCreateOne struct {
	query builder.Query
}

func (p arcCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p arcCreateOne) arcModel() {}

func (r arcCreateOne) Exec(ctx context.Context) (*ArcModel, error) {
	var v ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcCreateOne) Tx() arcUniqueTxResult {
	v := NewarcUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single devicesOnNets.
func (r devicesOnNetsActions) CreateOne(
	_device DevicesOnNetsWithPrismaDeviceSetParam,
	_net DevicesOnNetsWithPrismaNetSetParam,

	optional ...DevicesOnNetsSetParam,
) devicesOnNetsCreateOne {
	var v devicesOnNetsCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "DevicesOnNets"
	v.query.Outputs = devicesOnNetsOutput

	var fields []builder.Field

	fields = append(fields, _device.field())
	fields = append(fields, _net.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r devicesOnNetsCreateOne) With(params ...DevicesOnNetsRelationWith) devicesOnNetsCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type devicesOnNetsCreateOne struct {
	query builder.Query
}

func (p devicesOnNetsCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsCreateOne) devicesOnNetsModel() {}

func (r devicesOnNetsCreateOne) Exec(ctx context.Context) (*DevicesOnNetsModel, error) {
	var v DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesOnNetsCreateOne) Tx() devicesOnNetsUniqueTxResult {
	v := NewdevicesOnNetsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single field.
func (r fieldActions) CreateOne(
	_name FieldWithPrismaNameSetParam,
	_type FieldWithPrismaTypeSetParam,
	_event FieldWithPrismaEventSetParam,

	optional ...FieldSetParam,
) fieldCreateOne {
	var v fieldCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Field"
	v.query.Outputs = fieldOutput

	var fields []builder.Field

	fields = append(fields, _name.field())
	fields = append(fields, _type.field())
	fields = append(fields, _event.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r fieldCreateOne) With(params ...FieldRelationWith) fieldCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type fieldCreateOne struct {
	query builder.Query
}

func (p fieldCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p fieldCreateOne) fieldModel() {}

func (r fieldCreateOne) Exec(ctx context.Context) (*FieldModel, error) {
	var v FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fieldCreateOne) Tx() fieldUniqueTxResult {
	v := NewfieldUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single event.
func (r eventActions) CreateOne(
	_name EventWithPrismaNameSetParam,

	optional ...EventSetParam,
) eventCreateOne {
	var v eventCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Event"
	v.query.Outputs = eventOutput

	var fields []builder.Field

	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r eventCreateOne) With(params ...EventRelationWith) eventCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type eventCreateOne struct {
	query builder.Query
}

func (p eventCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p eventCreateOne) eventModel() {}

func (r eventCreateOne) Exec(ctx context.Context) (*EventModel, error) {
	var v EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventCreateOne) Tx() eventUniqueTxResult {
	v := NeweventUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single instance.
func (r instanceActions) CreateOne(
	_author InstanceWithPrismaAuthorSetParam,
	_language InstanceWithPrismaLanguageSetParam,
	_name InstanceWithPrismaNameSetParam,
	_device InstanceWithPrismaDeviceSetParam,
	_addr InstanceWithPrismaAddrSetParam,

	optional ...InstanceSetParam,
) instanceCreateOne {
	var v instanceCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Instance"
	v.query.Outputs = instanceOutput

	var fields []builder.Field

	fields = append(fields, _author.field())
	fields = append(fields, _language.field())
	fields = append(fields, _name.field())
	fields = append(fields, _device.field())
	fields = append(fields, _addr.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r instanceCreateOne) With(params ...InstanceRelationWith) instanceCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type instanceCreateOne struct {
	query builder.Query
}

func (p instanceCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p instanceCreateOne) instanceModel() {}

func (r instanceCreateOne) Exec(ctx context.Context) (*InstanceModel, error) {
	var v InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceCreateOne) Tx() instanceUniqueTxResult {
	v := NewinstanceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single device.
func (r deviceActions) CreateOne(
	_author DeviceWithPrismaAuthorSetParam,
	_name DeviceWithPrismaNameSetParam,
	_description DeviceWithPrismaDescriptionSetParam,

	optional ...DeviceSetParam,
) deviceCreateOne {
	var v deviceCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Device"
	v.query.Outputs = deviceOutput

	var fields []builder.Field

	fields = append(fields, _author.field())
	fields = append(fields, _name.field())
	fields = append(fields, _description.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r deviceCreateOne) With(params ...DeviceRelationWith) deviceCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type deviceCreateOne struct {
	query builder.Query
}

func (p deviceCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p deviceCreateOne) deviceModel() {}

func (r deviceCreateOne) Exec(ctx context.Context) (*DeviceModel, error) {
	var v DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceCreateOne) Tx() deviceUniqueTxResult {
	v := NewdeviceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single constant.
func (r constantActions) CreateOne(
	_action ConstantWithPrismaActionSetParam,
	_field ConstantWithPrismaFieldSetParam,
	_value ConstantWithPrismaValueSetParam,

	optional ...ConstantSetParam,
) constantCreateOne {
	var v constantCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Constant"
	v.query.Outputs = constantOutput

	var fields []builder.Field

	fields = append(fields, _action.field())
	fields = append(fields, _field.field())
	fields = append(fields, _value.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r constantCreateOne) With(params ...ConstantRelationWith) constantCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type constantCreateOne struct {
	query builder.Query
}

func (p constantCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p constantCreateOne) constantModel() {}

func (r constantCreateOne) Exec(ctx context.Context) (*ConstantModel, error) {
	var v ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r constantCreateOne) Tx() constantUniqueTxResult {
	v := NewconstantUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single action.
func (r actionActions) CreateOne(
	_input ActionWithPrismaInputSetParam,
	_output ActionWithPrismaOutputSetParam,
	_device ActionWithPrismaDeviceSetParam,
	_event ActionWithPrismaEventSetParam,

	optional ...ActionSetParam,
) actionCreateOne {
	var v actionCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Action"
	v.query.Outputs = actionOutput

	var fields []builder.Field

	fields = append(fields, _input.field())
	fields = append(fields, _output.field())
	fields = append(fields, _device.field())
	fields = append(fields, _event.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r actionCreateOne) With(params ...ActionRelationWith) actionCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type actionCreateOne struct {
	query builder.Query
}

func (p actionCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p actionCreateOne) actionModel() {}

func (r actionCreateOne) Exec(ctx context.Context) (*ActionModel, error) {
	var v ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionCreateOne) Tx() actionUniqueTxResult {
	v := NewactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single step.
func (r stepActions) CreateOne(
	_order StepWithPrismaOrderSetParam,
	_run StepWithPrismaRunSetParam,
	_action StepWithPrismaActionSetParam,

	optional ...StepSetParam,
) stepCreateOne {
	var v stepCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Step"
	v.query.Outputs = stepOutput

	var fields []builder.Field

	fields = append(fields, _order.field())
	fields = append(fields, _run.field())
	fields = append(fields, _action.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r stepCreateOne) With(params ...StepRelationWith) stepCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type stepCreateOne struct {
	query builder.Query
}

func (p stepCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p stepCreateOne) stepModel() {}

func (r stepCreateOne) Exec(ctx context.Context) (*StepModel, error) {
	var v StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r stepCreateOne) Tx() stepUniqueTxResult {
	v := NewstepUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single run.
func (r runActions) CreateOne(
	_name RunWithPrismaNameSetParam,
	_description RunWithPrismaDescriptionSetParam,
	_net RunWithPrismaNetSetParam,

	optional ...RunSetParam,
) runCreateOne {
	var v runCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Run"
	v.query.Outputs = runOutput

	var fields []builder.Field

	fields = append(fields, _name.field())
	fields = append(fields, _description.field())
	fields = append(fields, _net.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r runCreateOne) With(params ...RunRelationWith) runCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type runCreateOne struct {
	query builder.Query
}

func (p runCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p runCreateOne) runModel() {}

func (r runCreateOne) Exec(ctx context.Context) (*RunModel, error) {
	var v RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runCreateOne) Tx() runUniqueTxResult {
	v := NewrunUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single datum.
func (r datumActions) CreateOne(
	_instance DatumWithPrismaInstanceSetParam,
	_session DatumWithPrismaSessionSetParam,
	_event DatumWithPrismaEventSetParam,

	optional ...DatumSetParam,
) datumCreateOne {
	var v datumCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Datum"
	v.query.Outputs = datumOutput

	var fields []builder.Field

	fields = append(fields, _instance.field())
	fields = append(fields, _session.field())
	fields = append(fields, _event.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r datumCreateOne) With(params ...DatumRelationWith) datumCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type datumCreateOne struct {
	query builder.Query
}

func (p datumCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p datumCreateOne) datumModel() {}

func (r datumCreateOne) Exec(ctx context.Context) (*DatumModel, error) {
	var v DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumCreateOne) Tx() datumUniqueTxResult {
	v := NewdatumUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single session.
func (r sessionActions) CreateOne(
	_user SessionWithPrismaUserSetParam,
	_run SessionWithPrismaRunSetParam,

	optional ...SessionSetParam,
) sessionCreateOne {
	var v sessionCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Session"
	v.query.Outputs = sessionOutput

	var fields []builder.Field

	fields = append(fields, _user.field())
	fields = append(fields, _run.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r sessionCreateOne) With(params ...SessionRelationWith) sessionCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type sessionCreateOne struct {
	query builder.Query
}

func (p sessionCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p sessionCreateOne) sessionModel() {}

func (r sessionCreateOne) Exec(ctx context.Context) (*SessionModel, error) {
	var v SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionCreateOne) Tx() sessionUniqueTxResult {
	v := NewsessionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template find.gotpl ---

type userToPasswordFindUnique struct {
	query builder.Query
}

func (r userToPasswordFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToPasswordFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToPasswordFindUnique) with()         {}
func (r userToPasswordFindUnique) userModel()    {}
func (r userToPasswordFindUnique) userRelation() {}

func (r userToPasswordFindUnique) With(params ...PasswordRelationWith) userToPasswordFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToPasswordFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToPasswordFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToPasswordFindUnique) Update(params ...UserSetParam) userToPasswordUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToPasswordUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToPasswordUpdateUnique struct {
	query builder.Query
}

func (r userToPasswordUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToPasswordUpdateUnique) userModel() {}

func (r userToPasswordUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToPasswordUpdateUnique) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToPasswordFindUnique) Delete() userToPasswordDeleteUnique {
	var v userToPasswordDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToPasswordDeleteUnique struct {
	query builder.Query
}

func (r userToPasswordDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToPasswordDeleteUnique) userModel() {}

func (r userToPasswordDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToPasswordDeleteUnique) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToPasswordFindFirst struct {
	query builder.Query
}

func (r userToPasswordFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToPasswordFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToPasswordFindFirst) with()         {}
func (r userToPasswordFindFirst) userModel()    {}
func (r userToPasswordFindFirst) userRelation() {}

func (r userToPasswordFindFirst) With(params ...PasswordRelationWith) userToPasswordFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToPasswordFindFirst) OrderBy(params ...PasswordOrderByParam) userToPasswordFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToPasswordFindFirst) Skip(count int) userToPasswordFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToPasswordFindFirst) Take(count int) userToPasswordFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToPasswordFindFirst) Cursor(cursor UserCursorParam) userToPasswordFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToPasswordFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToPasswordFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToPasswordFindMany struct {
	query builder.Query
}

func (r userToPasswordFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToPasswordFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToPasswordFindMany) with()         {}
func (r userToPasswordFindMany) userModel()    {}
func (r userToPasswordFindMany) userRelation() {}

func (r userToPasswordFindMany) With(params ...PasswordRelationWith) userToPasswordFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToPasswordFindMany) OrderBy(params ...PasswordOrderByParam) userToPasswordFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToPasswordFindMany) Skip(count int) userToPasswordFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToPasswordFindMany) Take(count int) userToPasswordFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToPasswordFindMany) Cursor(cursor UserCursorParam) userToPasswordFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToPasswordFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToPasswordFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToPasswordFindMany) Update(params ...UserSetParam) userToPasswordUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToPasswordUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToPasswordUpdateMany struct {
	query builder.Query
}

func (r userToPasswordUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToPasswordUpdateMany) userModel() {}

func (r userToPasswordUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToPasswordUpdateMany) Tx() userManyTxResult {
	v := NewuserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToPasswordFindMany) Delete() userToPasswordDeleteMany {
	var v userToPasswordDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToPasswordDeleteMany struct {
	query builder.Query
}

func (r userToPasswordDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToPasswordDeleteMany) userModel() {}

func (r userToPasswordDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToPasswordDeleteMany) Tx() userManyTxResult {
	v := NewuserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToNetsFindUnique struct {
	query builder.Query
}

func (r userToNetsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToNetsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToNetsFindUnique) with()         {}
func (r userToNetsFindUnique) userModel()    {}
func (r userToNetsFindUnique) userRelation() {}

func (r userToNetsFindUnique) With(params ...NetRelationWith) userToNetsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToNetsFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToNetsFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToNetsFindUnique) Update(params ...UserSetParam) userToNetsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToNetsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToNetsUpdateUnique struct {
	query builder.Query
}

func (r userToNetsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToNetsUpdateUnique) userModel() {}

func (r userToNetsUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToNetsUpdateUnique) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToNetsFindUnique) Delete() userToNetsDeleteUnique {
	var v userToNetsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToNetsDeleteUnique struct {
	query builder.Query
}

func (r userToNetsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToNetsDeleteUnique) userModel() {}

func (r userToNetsDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToNetsDeleteUnique) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToNetsFindFirst struct {
	query builder.Query
}

func (r userToNetsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToNetsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToNetsFindFirst) with()         {}
func (r userToNetsFindFirst) userModel()    {}
func (r userToNetsFindFirst) userRelation() {}

func (r userToNetsFindFirst) With(params ...NetRelationWith) userToNetsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToNetsFindFirst) OrderBy(params ...NetOrderByParam) userToNetsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToNetsFindFirst) Skip(count int) userToNetsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToNetsFindFirst) Take(count int) userToNetsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToNetsFindFirst) Cursor(cursor UserCursorParam) userToNetsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToNetsFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToNetsFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToNetsFindMany struct {
	query builder.Query
}

func (r userToNetsFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToNetsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToNetsFindMany) with()         {}
func (r userToNetsFindMany) userModel()    {}
func (r userToNetsFindMany) userRelation() {}

func (r userToNetsFindMany) With(params ...NetRelationWith) userToNetsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToNetsFindMany) OrderBy(params ...NetOrderByParam) userToNetsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToNetsFindMany) Skip(count int) userToNetsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToNetsFindMany) Take(count int) userToNetsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToNetsFindMany) Cursor(cursor UserCursorParam) userToNetsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToNetsFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToNetsFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToNetsFindMany) Update(params ...UserSetParam) userToNetsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToNetsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToNetsUpdateMany struct {
	query builder.Query
}

func (r userToNetsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToNetsUpdateMany) userModel() {}

func (r userToNetsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToNetsUpdateMany) Tx() userManyTxResult {
	v := NewuserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToNetsFindMany) Delete() userToNetsDeleteMany {
	var v userToNetsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToNetsDeleteMany struct {
	query builder.Query
}

func (r userToNetsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToNetsDeleteMany) userModel() {}

func (r userToNetsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToNetsDeleteMany) Tx() userManyTxResult {
	v := NewuserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToDevicesFindUnique struct {
	query builder.Query
}

func (r userToDevicesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToDevicesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToDevicesFindUnique) with()         {}
func (r userToDevicesFindUnique) userModel()    {}
func (r userToDevicesFindUnique) userRelation() {}

func (r userToDevicesFindUnique) With(params ...DeviceRelationWith) userToDevicesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToDevicesFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToDevicesFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToDevicesFindUnique) Update(params ...UserSetParam) userToDevicesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToDevicesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToDevicesUpdateUnique struct {
	query builder.Query
}

func (r userToDevicesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToDevicesUpdateUnique) userModel() {}

func (r userToDevicesUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToDevicesUpdateUnique) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToDevicesFindUnique) Delete() userToDevicesDeleteUnique {
	var v userToDevicesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToDevicesDeleteUnique struct {
	query builder.Query
}

func (r userToDevicesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToDevicesDeleteUnique) userModel() {}

func (r userToDevicesDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToDevicesDeleteUnique) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToDevicesFindFirst struct {
	query builder.Query
}

func (r userToDevicesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToDevicesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToDevicesFindFirst) with()         {}
func (r userToDevicesFindFirst) userModel()    {}
func (r userToDevicesFindFirst) userRelation() {}

func (r userToDevicesFindFirst) With(params ...DeviceRelationWith) userToDevicesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToDevicesFindFirst) OrderBy(params ...DeviceOrderByParam) userToDevicesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToDevicesFindFirst) Skip(count int) userToDevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToDevicesFindFirst) Take(count int) userToDevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToDevicesFindFirst) Cursor(cursor UserCursorParam) userToDevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToDevicesFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToDevicesFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToDevicesFindMany struct {
	query builder.Query
}

func (r userToDevicesFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToDevicesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToDevicesFindMany) with()         {}
func (r userToDevicesFindMany) userModel()    {}
func (r userToDevicesFindMany) userRelation() {}

func (r userToDevicesFindMany) With(params ...DeviceRelationWith) userToDevicesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToDevicesFindMany) OrderBy(params ...DeviceOrderByParam) userToDevicesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToDevicesFindMany) Skip(count int) userToDevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToDevicesFindMany) Take(count int) userToDevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToDevicesFindMany) Cursor(cursor UserCursorParam) userToDevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToDevicesFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToDevicesFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToDevicesFindMany) Update(params ...UserSetParam) userToDevicesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToDevicesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToDevicesUpdateMany struct {
	query builder.Query
}

func (r userToDevicesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToDevicesUpdateMany) userModel() {}

func (r userToDevicesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToDevicesUpdateMany) Tx() userManyTxResult {
	v := NewuserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToDevicesFindMany) Delete() userToDevicesDeleteMany {
	var v userToDevicesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToDevicesDeleteMany struct {
	query builder.Query
}

func (r userToDevicesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToDevicesDeleteMany) userModel() {}

func (r userToDevicesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToDevicesDeleteMany) Tx() userManyTxResult {
	v := NewuserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToInstancesFindUnique struct {
	query builder.Query
}

func (r userToInstancesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToInstancesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToInstancesFindUnique) with()         {}
func (r userToInstancesFindUnique) userModel()    {}
func (r userToInstancesFindUnique) userRelation() {}

func (r userToInstancesFindUnique) With(params ...InstanceRelationWith) userToInstancesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToInstancesFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToInstancesFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToInstancesFindUnique) Update(params ...UserSetParam) userToInstancesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToInstancesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToInstancesUpdateUnique struct {
	query builder.Query
}

func (r userToInstancesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToInstancesUpdateUnique) userModel() {}

func (r userToInstancesUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToInstancesUpdateUnique) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToInstancesFindUnique) Delete() userToInstancesDeleteUnique {
	var v userToInstancesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToInstancesDeleteUnique struct {
	query builder.Query
}

func (r userToInstancesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToInstancesDeleteUnique) userModel() {}

func (r userToInstancesDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToInstancesDeleteUnique) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToInstancesFindFirst struct {
	query builder.Query
}

func (r userToInstancesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToInstancesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToInstancesFindFirst) with()         {}
func (r userToInstancesFindFirst) userModel()    {}
func (r userToInstancesFindFirst) userRelation() {}

func (r userToInstancesFindFirst) With(params ...InstanceRelationWith) userToInstancesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToInstancesFindFirst) OrderBy(params ...InstanceOrderByParam) userToInstancesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToInstancesFindFirst) Skip(count int) userToInstancesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToInstancesFindFirst) Take(count int) userToInstancesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToInstancesFindFirst) Cursor(cursor UserCursorParam) userToInstancesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToInstancesFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToInstancesFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToInstancesFindMany struct {
	query builder.Query
}

func (r userToInstancesFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToInstancesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToInstancesFindMany) with()         {}
func (r userToInstancesFindMany) userModel()    {}
func (r userToInstancesFindMany) userRelation() {}

func (r userToInstancesFindMany) With(params ...InstanceRelationWith) userToInstancesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToInstancesFindMany) OrderBy(params ...InstanceOrderByParam) userToInstancesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToInstancesFindMany) Skip(count int) userToInstancesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToInstancesFindMany) Take(count int) userToInstancesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToInstancesFindMany) Cursor(cursor UserCursorParam) userToInstancesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToInstancesFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToInstancesFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToInstancesFindMany) Update(params ...UserSetParam) userToInstancesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToInstancesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToInstancesUpdateMany struct {
	query builder.Query
}

func (r userToInstancesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToInstancesUpdateMany) userModel() {}

func (r userToInstancesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToInstancesUpdateMany) Tx() userManyTxResult {
	v := NewuserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToInstancesFindMany) Delete() userToInstancesDeleteMany {
	var v userToInstancesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToInstancesDeleteMany struct {
	query builder.Query
}

func (r userToInstancesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToInstancesDeleteMany) userModel() {}

func (r userToInstancesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToInstancesDeleteMany) Tx() userManyTxResult {
	v := NewuserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToSessionsFindUnique struct {
	query builder.Query
}

func (r userToSessionsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToSessionsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToSessionsFindUnique) with()         {}
func (r userToSessionsFindUnique) userModel()    {}
func (r userToSessionsFindUnique) userRelation() {}

func (r userToSessionsFindUnique) With(params ...SessionRelationWith) userToSessionsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToSessionsFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToSessionsFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToSessionsFindUnique) Update(params ...UserSetParam) userToSessionsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToSessionsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToSessionsUpdateUnique struct {
	query builder.Query
}

func (r userToSessionsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToSessionsUpdateUnique) userModel() {}

func (r userToSessionsUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToSessionsUpdateUnique) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToSessionsFindUnique) Delete() userToSessionsDeleteUnique {
	var v userToSessionsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToSessionsDeleteUnique struct {
	query builder.Query
}

func (r userToSessionsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToSessionsDeleteUnique) userModel() {}

func (r userToSessionsDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToSessionsDeleteUnique) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToSessionsFindFirst struct {
	query builder.Query
}

func (r userToSessionsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToSessionsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToSessionsFindFirst) with()         {}
func (r userToSessionsFindFirst) userModel()    {}
func (r userToSessionsFindFirst) userRelation() {}

func (r userToSessionsFindFirst) With(params ...SessionRelationWith) userToSessionsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToSessionsFindFirst) OrderBy(params ...SessionOrderByParam) userToSessionsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToSessionsFindFirst) Skip(count int) userToSessionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToSessionsFindFirst) Take(count int) userToSessionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToSessionsFindFirst) Cursor(cursor UserCursorParam) userToSessionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToSessionsFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToSessionsFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToSessionsFindMany struct {
	query builder.Query
}

func (r userToSessionsFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToSessionsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToSessionsFindMany) with()         {}
func (r userToSessionsFindMany) userModel()    {}
func (r userToSessionsFindMany) userRelation() {}

func (r userToSessionsFindMany) With(params ...SessionRelationWith) userToSessionsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToSessionsFindMany) OrderBy(params ...SessionOrderByParam) userToSessionsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToSessionsFindMany) Skip(count int) userToSessionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToSessionsFindMany) Take(count int) userToSessionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToSessionsFindMany) Cursor(cursor UserCursorParam) userToSessionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToSessionsFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToSessionsFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToSessionsFindMany) Update(params ...UserSetParam) userToSessionsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToSessionsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToSessionsUpdateMany struct {
	query builder.Query
}

func (r userToSessionsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToSessionsUpdateMany) userModel() {}

func (r userToSessionsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToSessionsUpdateMany) Tx() userManyTxResult {
	v := NewuserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToSessionsFindMany) Delete() userToSessionsDeleteMany {
	var v userToSessionsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToSessionsDeleteMany struct {
	query builder.Query
}

func (r userToSessionsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToSessionsDeleteMany) userModel() {}

func (r userToSessionsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToSessionsDeleteMany) Tx() userManyTxResult {
	v := NewuserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userFindUnique struct {
	query builder.Query
}

func (r userFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindUnique) with()         {}
func (r userFindUnique) userModel()    {}
func (r userFindUnique) userRelation() {}

func (r userActions) FindUnique(
	params UserEqualsUniqueWhereParam,
) userFindUnique {
	var v userFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userFindUnique) With(params ...UserRelationWith) userFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) Update(params ...UserSetParam) userUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateUnique struct {
	query builder.Query
}

func (r userUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateUnique) userModel() {}

func (r userUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateUnique) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindUnique) Delete() userDeleteUnique {
	var v userDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userDeleteUnique struct {
	query builder.Query
}

func (r userDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteUnique) userModel() {}

func (r userDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteUnique) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userFindFirst struct {
	query builder.Query
}

func (r userFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindFirst) with()         {}
func (r userFindFirst) userModel()    {}
func (r userFindFirst) userRelation() {}

func (r userActions) FindFirst(
	params ...UserWhereParam,
) userFindFirst {
	var v userFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindFirst) With(params ...UserRelationWith) userFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindFirst) OrderBy(params ...UserOrderByParam) userFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindFirst) Skip(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindFirst) Take(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindFirst) Cursor(cursor UserCursorParam) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userFindMany struct {
	query builder.Query
}

func (r userFindMany) getQuery() builder.Query {
	return r.query
}

func (r userFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindMany) with()         {}
func (r userFindMany) userModel()    {}
func (r userFindMany) userRelation() {}

func (r userActions) FindMany(
	params ...UserWhereParam,
) userFindMany {
	var v userFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindMany) With(params ...UserRelationWith) userFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindMany) OrderBy(params ...UserOrderByParam) userFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindMany) Skip(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindMany) Take(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindMany) Cursor(cursor UserCursorParam) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) Update(params ...UserSetParam) userUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateMany struct {
	query builder.Query
}

func (r userUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateMany) userModel() {}

func (r userUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateMany) Tx() userManyTxResult {
	v := NewuserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindMany) Delete() userDeleteMany {
	var v userDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userDeleteMany struct {
	query builder.Query
}

func (r userDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteMany) userModel() {}

func (r userDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteMany) Tx() userManyTxResult {
	v := NewuserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type passwordToUserFindUnique struct {
	query builder.Query
}

func (r passwordToUserFindUnique) getQuery() builder.Query {
	return r.query
}

func (r passwordToUserFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r passwordToUserFindUnique) with()             {}
func (r passwordToUserFindUnique) passwordModel()    {}
func (r passwordToUserFindUnique) passwordRelation() {}

func (r passwordToUserFindUnique) With(params ...UserRelationWith) passwordToUserFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r passwordToUserFindUnique) Exec(ctx context.Context) (
	*PasswordModel,
	error,
) {
	var v *PasswordModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r passwordToUserFindUnique) ExecInner(ctx context.Context) (
	*InnerPassword,
	error,
) {
	var v *InnerPassword
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r passwordToUserFindUnique) Update(params ...PasswordSetParam) passwordToUserUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Password"

	var v passwordToUserUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type passwordToUserUpdateUnique struct {
	query builder.Query
}

func (r passwordToUserUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r passwordToUserUpdateUnique) passwordModel() {}

func (r passwordToUserUpdateUnique) Exec(ctx context.Context) (*PasswordModel, error) {
	var v PasswordModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r passwordToUserUpdateUnique) Tx() passwordUniqueTxResult {
	v := NewpasswordUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r passwordToUserFindUnique) Delete() passwordToUserDeleteUnique {
	var v passwordToUserDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Password"

	return v
}

type passwordToUserDeleteUnique struct {
	query builder.Query
}

func (r passwordToUserDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p passwordToUserDeleteUnique) passwordModel() {}

func (r passwordToUserDeleteUnique) Exec(ctx context.Context) (*PasswordModel, error) {
	var v PasswordModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r passwordToUserDeleteUnique) Tx() passwordUniqueTxResult {
	v := NewpasswordUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type passwordToUserFindFirst struct {
	query builder.Query
}

func (r passwordToUserFindFirst) getQuery() builder.Query {
	return r.query
}

func (r passwordToUserFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r passwordToUserFindFirst) with()             {}
func (r passwordToUserFindFirst) passwordModel()    {}
func (r passwordToUserFindFirst) passwordRelation() {}

func (r passwordToUserFindFirst) With(params ...UserRelationWith) passwordToUserFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r passwordToUserFindFirst) OrderBy(params ...UserOrderByParam) passwordToUserFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r passwordToUserFindFirst) Skip(count int) passwordToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r passwordToUserFindFirst) Take(count int) passwordToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r passwordToUserFindFirst) Cursor(cursor PasswordCursorParam) passwordToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r passwordToUserFindFirst) Exec(ctx context.Context) (
	*PasswordModel,
	error,
) {
	var v *PasswordModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r passwordToUserFindFirst) ExecInner(ctx context.Context) (
	*InnerPassword,
	error,
) {
	var v *InnerPassword
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type passwordToUserFindMany struct {
	query builder.Query
}

func (r passwordToUserFindMany) getQuery() builder.Query {
	return r.query
}

func (r passwordToUserFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r passwordToUserFindMany) with()             {}
func (r passwordToUserFindMany) passwordModel()    {}
func (r passwordToUserFindMany) passwordRelation() {}

func (r passwordToUserFindMany) With(params ...UserRelationWith) passwordToUserFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r passwordToUserFindMany) OrderBy(params ...UserOrderByParam) passwordToUserFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r passwordToUserFindMany) Skip(count int) passwordToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r passwordToUserFindMany) Take(count int) passwordToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r passwordToUserFindMany) Cursor(cursor PasswordCursorParam) passwordToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r passwordToUserFindMany) Exec(ctx context.Context) (
	[]PasswordModel,
	error,
) {
	var v []PasswordModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r passwordToUserFindMany) ExecInner(ctx context.Context) (
	[]InnerPassword,
	error,
) {
	var v []InnerPassword
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r passwordToUserFindMany) Update(params ...PasswordSetParam) passwordToUserUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Password"

	r.query.Outputs = countOutput

	var v passwordToUserUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type passwordToUserUpdateMany struct {
	query builder.Query
}

func (r passwordToUserUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r passwordToUserUpdateMany) passwordModel() {}

func (r passwordToUserUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r passwordToUserUpdateMany) Tx() passwordManyTxResult {
	v := NewpasswordManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r passwordToUserFindMany) Delete() passwordToUserDeleteMany {
	var v passwordToUserDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Password"

	v.query.Outputs = countOutput

	return v
}

type passwordToUserDeleteMany struct {
	query builder.Query
}

func (r passwordToUserDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p passwordToUserDeleteMany) passwordModel() {}

func (r passwordToUserDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r passwordToUserDeleteMany) Tx() passwordManyTxResult {
	v := NewpasswordManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type passwordFindUnique struct {
	query builder.Query
}

func (r passwordFindUnique) getQuery() builder.Query {
	return r.query
}

func (r passwordFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r passwordFindUnique) with()             {}
func (r passwordFindUnique) passwordModel()    {}
func (r passwordFindUnique) passwordRelation() {}

func (r passwordActions) FindUnique(
	params PasswordEqualsUniqueWhereParam,
) passwordFindUnique {
	var v passwordFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Password"
	v.query.Outputs = passwordOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r passwordFindUnique) With(params ...PasswordRelationWith) passwordFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r passwordFindUnique) Exec(ctx context.Context) (
	*PasswordModel,
	error,
) {
	var v *PasswordModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r passwordFindUnique) ExecInner(ctx context.Context) (
	*InnerPassword,
	error,
) {
	var v *InnerPassword
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r passwordFindUnique) Update(params ...PasswordSetParam) passwordUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Password"

	var v passwordUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type passwordUpdateUnique struct {
	query builder.Query
}

func (r passwordUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r passwordUpdateUnique) passwordModel() {}

func (r passwordUpdateUnique) Exec(ctx context.Context) (*PasswordModel, error) {
	var v PasswordModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r passwordUpdateUnique) Tx() passwordUniqueTxResult {
	v := NewpasswordUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r passwordFindUnique) Delete() passwordDeleteUnique {
	var v passwordDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Password"

	return v
}

type passwordDeleteUnique struct {
	query builder.Query
}

func (r passwordDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p passwordDeleteUnique) passwordModel() {}

func (r passwordDeleteUnique) Exec(ctx context.Context) (*PasswordModel, error) {
	var v PasswordModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r passwordDeleteUnique) Tx() passwordUniqueTxResult {
	v := NewpasswordUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type passwordFindFirst struct {
	query builder.Query
}

func (r passwordFindFirst) getQuery() builder.Query {
	return r.query
}

func (r passwordFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r passwordFindFirst) with()             {}
func (r passwordFindFirst) passwordModel()    {}
func (r passwordFindFirst) passwordRelation() {}

func (r passwordActions) FindFirst(
	params ...PasswordWhereParam,
) passwordFindFirst {
	var v passwordFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Password"
	v.query.Outputs = passwordOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r passwordFindFirst) With(params ...PasswordRelationWith) passwordFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r passwordFindFirst) OrderBy(params ...PasswordOrderByParam) passwordFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r passwordFindFirst) Skip(count int) passwordFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r passwordFindFirst) Take(count int) passwordFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r passwordFindFirst) Cursor(cursor PasswordCursorParam) passwordFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r passwordFindFirst) Exec(ctx context.Context) (
	*PasswordModel,
	error,
) {
	var v *PasswordModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r passwordFindFirst) ExecInner(ctx context.Context) (
	*InnerPassword,
	error,
) {
	var v *InnerPassword
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type passwordFindMany struct {
	query builder.Query
}

func (r passwordFindMany) getQuery() builder.Query {
	return r.query
}

func (r passwordFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r passwordFindMany) with()             {}
func (r passwordFindMany) passwordModel()    {}
func (r passwordFindMany) passwordRelation() {}

func (r passwordActions) FindMany(
	params ...PasswordWhereParam,
) passwordFindMany {
	var v passwordFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Password"
	v.query.Outputs = passwordOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r passwordFindMany) With(params ...PasswordRelationWith) passwordFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r passwordFindMany) OrderBy(params ...PasswordOrderByParam) passwordFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r passwordFindMany) Skip(count int) passwordFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r passwordFindMany) Take(count int) passwordFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r passwordFindMany) Cursor(cursor PasswordCursorParam) passwordFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r passwordFindMany) Exec(ctx context.Context) (
	[]PasswordModel,
	error,
) {
	var v []PasswordModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r passwordFindMany) ExecInner(ctx context.Context) (
	[]InnerPassword,
	error,
) {
	var v []InnerPassword
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r passwordFindMany) Update(params ...PasswordSetParam) passwordUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Password"

	r.query.Outputs = countOutput

	var v passwordUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type passwordUpdateMany struct {
	query builder.Query
}

func (r passwordUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r passwordUpdateMany) passwordModel() {}

func (r passwordUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r passwordUpdateMany) Tx() passwordManyTxResult {
	v := NewpasswordManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r passwordFindMany) Delete() passwordDeleteMany {
	var v passwordDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Password"

	v.query.Outputs = countOutput

	return v
}

type passwordDeleteMany struct {
	query builder.Query
}

func (r passwordDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p passwordDeleteMany) passwordModel() {}

func (r passwordDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r passwordDeleteMany) Tx() passwordManyTxResult {
	v := NewpasswordManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToAuthorFindUnique struct {
	query builder.Query
}

func (r netToAuthorFindUnique) getQuery() builder.Query {
	return r.query
}

func (r netToAuthorFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToAuthorFindUnique) with()        {}
func (r netToAuthorFindUnique) netModel()    {}
func (r netToAuthorFindUnique) netRelation() {}

func (r netToAuthorFindUnique) With(params ...UserRelationWith) netToAuthorFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToAuthorFindUnique) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToAuthorFindUnique) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToAuthorFindUnique) Update(params ...NetSetParam) netToAuthorUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Net"

	var v netToAuthorUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToAuthorUpdateUnique struct {
	query builder.Query
}

func (r netToAuthorUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToAuthorUpdateUnique) netModel() {}

func (r netToAuthorUpdateUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToAuthorUpdateUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToAuthorFindUnique) Delete() netToAuthorDeleteUnique {
	var v netToAuthorDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Net"

	return v
}

type netToAuthorDeleteUnique struct {
	query builder.Query
}

func (r netToAuthorDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p netToAuthorDeleteUnique) netModel() {}

func (r netToAuthorDeleteUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToAuthorDeleteUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToAuthorFindFirst struct {
	query builder.Query
}

func (r netToAuthorFindFirst) getQuery() builder.Query {
	return r.query
}

func (r netToAuthorFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r netToAuthorFindFirst) with()        {}
func (r netToAuthorFindFirst) netModel()    {}
func (r netToAuthorFindFirst) netRelation() {}

func (r netToAuthorFindFirst) With(params ...UserRelationWith) netToAuthorFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToAuthorFindFirst) OrderBy(params ...UserOrderByParam) netToAuthorFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToAuthorFindFirst) Skip(count int) netToAuthorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToAuthorFindFirst) Take(count int) netToAuthorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToAuthorFindFirst) Cursor(cursor NetCursorParam) netToAuthorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToAuthorFindFirst) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToAuthorFindFirst) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type netToAuthorFindMany struct {
	query builder.Query
}

func (r netToAuthorFindMany) getQuery() builder.Query {
	return r.query
}

func (r netToAuthorFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToAuthorFindMany) with()        {}
func (r netToAuthorFindMany) netModel()    {}
func (r netToAuthorFindMany) netRelation() {}

func (r netToAuthorFindMany) With(params ...UserRelationWith) netToAuthorFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToAuthorFindMany) OrderBy(params ...UserOrderByParam) netToAuthorFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToAuthorFindMany) Skip(count int) netToAuthorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToAuthorFindMany) Take(count int) netToAuthorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToAuthorFindMany) Cursor(cursor NetCursorParam) netToAuthorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToAuthorFindMany) Exec(ctx context.Context) (
	[]NetModel,
	error,
) {
	var v []NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToAuthorFindMany) ExecInner(ctx context.Context) (
	[]InnerNet,
	error,
) {
	var v []InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToAuthorFindMany) Update(params ...NetSetParam) netToAuthorUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Net"

	r.query.Outputs = countOutput

	var v netToAuthorUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToAuthorUpdateMany struct {
	query builder.Query
}

func (r netToAuthorUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToAuthorUpdateMany) netModel() {}

func (r netToAuthorUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToAuthorUpdateMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToAuthorFindMany) Delete() netToAuthorDeleteMany {
	var v netToAuthorDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Net"

	v.query.Outputs = countOutput

	return v
}

type netToAuthorDeleteMany struct {
	query builder.Query
}

func (r netToAuthorDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p netToAuthorDeleteMany) netModel() {}

func (r netToAuthorDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToAuthorDeleteMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToArcsFindUnique struct {
	query builder.Query
}

func (r netToArcsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r netToArcsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToArcsFindUnique) with()        {}
func (r netToArcsFindUnique) netModel()    {}
func (r netToArcsFindUnique) netRelation() {}

func (r netToArcsFindUnique) With(params ...ArcRelationWith) netToArcsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToArcsFindUnique) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToArcsFindUnique) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToArcsFindUnique) Update(params ...NetSetParam) netToArcsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Net"

	var v netToArcsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToArcsUpdateUnique struct {
	query builder.Query
}

func (r netToArcsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToArcsUpdateUnique) netModel() {}

func (r netToArcsUpdateUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToArcsUpdateUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToArcsFindUnique) Delete() netToArcsDeleteUnique {
	var v netToArcsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Net"

	return v
}

type netToArcsDeleteUnique struct {
	query builder.Query
}

func (r netToArcsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p netToArcsDeleteUnique) netModel() {}

func (r netToArcsDeleteUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToArcsDeleteUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToArcsFindFirst struct {
	query builder.Query
}

func (r netToArcsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r netToArcsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r netToArcsFindFirst) with()        {}
func (r netToArcsFindFirst) netModel()    {}
func (r netToArcsFindFirst) netRelation() {}

func (r netToArcsFindFirst) With(params ...ArcRelationWith) netToArcsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToArcsFindFirst) OrderBy(params ...ArcOrderByParam) netToArcsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToArcsFindFirst) Skip(count int) netToArcsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToArcsFindFirst) Take(count int) netToArcsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToArcsFindFirst) Cursor(cursor NetCursorParam) netToArcsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToArcsFindFirst) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToArcsFindFirst) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type netToArcsFindMany struct {
	query builder.Query
}

func (r netToArcsFindMany) getQuery() builder.Query {
	return r.query
}

func (r netToArcsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToArcsFindMany) with()        {}
func (r netToArcsFindMany) netModel()    {}
func (r netToArcsFindMany) netRelation() {}

func (r netToArcsFindMany) With(params ...ArcRelationWith) netToArcsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToArcsFindMany) OrderBy(params ...ArcOrderByParam) netToArcsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToArcsFindMany) Skip(count int) netToArcsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToArcsFindMany) Take(count int) netToArcsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToArcsFindMany) Cursor(cursor NetCursorParam) netToArcsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToArcsFindMany) Exec(ctx context.Context) (
	[]NetModel,
	error,
) {
	var v []NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToArcsFindMany) ExecInner(ctx context.Context) (
	[]InnerNet,
	error,
) {
	var v []InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToArcsFindMany) Update(params ...NetSetParam) netToArcsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Net"

	r.query.Outputs = countOutput

	var v netToArcsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToArcsUpdateMany struct {
	query builder.Query
}

func (r netToArcsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToArcsUpdateMany) netModel() {}

func (r netToArcsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToArcsUpdateMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToArcsFindMany) Delete() netToArcsDeleteMany {
	var v netToArcsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Net"

	v.query.Outputs = countOutput

	return v
}

type netToArcsDeleteMany struct {
	query builder.Query
}

func (r netToArcsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p netToArcsDeleteMany) netModel() {}

func (r netToArcsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToArcsDeleteMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToPlacesFindUnique struct {
	query builder.Query
}

func (r netToPlacesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r netToPlacesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToPlacesFindUnique) with()        {}
func (r netToPlacesFindUnique) netModel()    {}
func (r netToPlacesFindUnique) netRelation() {}

func (r netToPlacesFindUnique) With(params ...PlaceRelationWith) netToPlacesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToPlacesFindUnique) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToPlacesFindUnique) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToPlacesFindUnique) Update(params ...NetSetParam) netToPlacesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Net"

	var v netToPlacesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToPlacesUpdateUnique struct {
	query builder.Query
}

func (r netToPlacesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToPlacesUpdateUnique) netModel() {}

func (r netToPlacesUpdateUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToPlacesUpdateUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToPlacesFindUnique) Delete() netToPlacesDeleteUnique {
	var v netToPlacesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Net"

	return v
}

type netToPlacesDeleteUnique struct {
	query builder.Query
}

func (r netToPlacesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p netToPlacesDeleteUnique) netModel() {}

func (r netToPlacesDeleteUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToPlacesDeleteUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToPlacesFindFirst struct {
	query builder.Query
}

func (r netToPlacesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r netToPlacesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r netToPlacesFindFirst) with()        {}
func (r netToPlacesFindFirst) netModel()    {}
func (r netToPlacesFindFirst) netRelation() {}

func (r netToPlacesFindFirst) With(params ...PlaceRelationWith) netToPlacesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToPlacesFindFirst) OrderBy(params ...PlaceOrderByParam) netToPlacesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToPlacesFindFirst) Skip(count int) netToPlacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToPlacesFindFirst) Take(count int) netToPlacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToPlacesFindFirst) Cursor(cursor NetCursorParam) netToPlacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToPlacesFindFirst) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToPlacesFindFirst) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type netToPlacesFindMany struct {
	query builder.Query
}

func (r netToPlacesFindMany) getQuery() builder.Query {
	return r.query
}

func (r netToPlacesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToPlacesFindMany) with()        {}
func (r netToPlacesFindMany) netModel()    {}
func (r netToPlacesFindMany) netRelation() {}

func (r netToPlacesFindMany) With(params ...PlaceRelationWith) netToPlacesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToPlacesFindMany) OrderBy(params ...PlaceOrderByParam) netToPlacesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToPlacesFindMany) Skip(count int) netToPlacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToPlacesFindMany) Take(count int) netToPlacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToPlacesFindMany) Cursor(cursor NetCursorParam) netToPlacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToPlacesFindMany) Exec(ctx context.Context) (
	[]NetModel,
	error,
) {
	var v []NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToPlacesFindMany) ExecInner(ctx context.Context) (
	[]InnerNet,
	error,
) {
	var v []InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToPlacesFindMany) Update(params ...NetSetParam) netToPlacesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Net"

	r.query.Outputs = countOutput

	var v netToPlacesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToPlacesUpdateMany struct {
	query builder.Query
}

func (r netToPlacesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToPlacesUpdateMany) netModel() {}

func (r netToPlacesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToPlacesUpdateMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToPlacesFindMany) Delete() netToPlacesDeleteMany {
	var v netToPlacesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Net"

	v.query.Outputs = countOutput

	return v
}

type netToPlacesDeleteMany struct {
	query builder.Query
}

func (r netToPlacesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p netToPlacesDeleteMany) netModel() {}

func (r netToPlacesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToPlacesDeleteMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToTransitionsFindUnique struct {
	query builder.Query
}

func (r netToTransitionsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r netToTransitionsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToTransitionsFindUnique) with()        {}
func (r netToTransitionsFindUnique) netModel()    {}
func (r netToTransitionsFindUnique) netRelation() {}

func (r netToTransitionsFindUnique) With(params ...TransitionRelationWith) netToTransitionsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToTransitionsFindUnique) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToTransitionsFindUnique) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToTransitionsFindUnique) Update(params ...NetSetParam) netToTransitionsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Net"

	var v netToTransitionsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToTransitionsUpdateUnique struct {
	query builder.Query
}

func (r netToTransitionsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToTransitionsUpdateUnique) netModel() {}

func (r netToTransitionsUpdateUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToTransitionsUpdateUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToTransitionsFindUnique) Delete() netToTransitionsDeleteUnique {
	var v netToTransitionsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Net"

	return v
}

type netToTransitionsDeleteUnique struct {
	query builder.Query
}

func (r netToTransitionsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p netToTransitionsDeleteUnique) netModel() {}

func (r netToTransitionsDeleteUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToTransitionsDeleteUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToTransitionsFindFirst struct {
	query builder.Query
}

func (r netToTransitionsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r netToTransitionsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r netToTransitionsFindFirst) with()        {}
func (r netToTransitionsFindFirst) netModel()    {}
func (r netToTransitionsFindFirst) netRelation() {}

func (r netToTransitionsFindFirst) With(params ...TransitionRelationWith) netToTransitionsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToTransitionsFindFirst) OrderBy(params ...TransitionOrderByParam) netToTransitionsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToTransitionsFindFirst) Skip(count int) netToTransitionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToTransitionsFindFirst) Take(count int) netToTransitionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToTransitionsFindFirst) Cursor(cursor NetCursorParam) netToTransitionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToTransitionsFindFirst) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToTransitionsFindFirst) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type netToTransitionsFindMany struct {
	query builder.Query
}

func (r netToTransitionsFindMany) getQuery() builder.Query {
	return r.query
}

func (r netToTransitionsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToTransitionsFindMany) with()        {}
func (r netToTransitionsFindMany) netModel()    {}
func (r netToTransitionsFindMany) netRelation() {}

func (r netToTransitionsFindMany) With(params ...TransitionRelationWith) netToTransitionsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToTransitionsFindMany) OrderBy(params ...TransitionOrderByParam) netToTransitionsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToTransitionsFindMany) Skip(count int) netToTransitionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToTransitionsFindMany) Take(count int) netToTransitionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToTransitionsFindMany) Cursor(cursor NetCursorParam) netToTransitionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToTransitionsFindMany) Exec(ctx context.Context) (
	[]NetModel,
	error,
) {
	var v []NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToTransitionsFindMany) ExecInner(ctx context.Context) (
	[]InnerNet,
	error,
) {
	var v []InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToTransitionsFindMany) Update(params ...NetSetParam) netToTransitionsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Net"

	r.query.Outputs = countOutput

	var v netToTransitionsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToTransitionsUpdateMany struct {
	query builder.Query
}

func (r netToTransitionsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToTransitionsUpdateMany) netModel() {}

func (r netToTransitionsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToTransitionsUpdateMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToTransitionsFindMany) Delete() netToTransitionsDeleteMany {
	var v netToTransitionsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Net"

	v.query.Outputs = countOutput

	return v
}

type netToTransitionsDeleteMany struct {
	query builder.Query
}

func (r netToTransitionsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p netToTransitionsDeleteMany) netModel() {}

func (r netToTransitionsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToTransitionsDeleteMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToParentFindUnique struct {
	query builder.Query
}

func (r netToParentFindUnique) getQuery() builder.Query {
	return r.query
}

func (r netToParentFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToParentFindUnique) with()        {}
func (r netToParentFindUnique) netModel()    {}
func (r netToParentFindUnique) netRelation() {}

func (r netToParentFindUnique) With(params ...NetRelationWith) netToParentFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToParentFindUnique) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToParentFindUnique) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToParentFindUnique) Update(params ...NetSetParam) netToParentUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Net"

	var v netToParentUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToParentUpdateUnique struct {
	query builder.Query
}

func (r netToParentUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToParentUpdateUnique) netModel() {}

func (r netToParentUpdateUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToParentUpdateUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToParentFindUnique) Delete() netToParentDeleteUnique {
	var v netToParentDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Net"

	return v
}

type netToParentDeleteUnique struct {
	query builder.Query
}

func (r netToParentDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p netToParentDeleteUnique) netModel() {}

func (r netToParentDeleteUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToParentDeleteUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToParentFindFirst struct {
	query builder.Query
}

func (r netToParentFindFirst) getQuery() builder.Query {
	return r.query
}

func (r netToParentFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r netToParentFindFirst) with()        {}
func (r netToParentFindFirst) netModel()    {}
func (r netToParentFindFirst) netRelation() {}

func (r netToParentFindFirst) With(params ...NetRelationWith) netToParentFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToParentFindFirst) OrderBy(params ...NetOrderByParam) netToParentFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToParentFindFirst) Skip(count int) netToParentFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToParentFindFirst) Take(count int) netToParentFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToParentFindFirst) Cursor(cursor NetCursorParam) netToParentFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToParentFindFirst) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToParentFindFirst) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type netToParentFindMany struct {
	query builder.Query
}

func (r netToParentFindMany) getQuery() builder.Query {
	return r.query
}

func (r netToParentFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToParentFindMany) with()        {}
func (r netToParentFindMany) netModel()    {}
func (r netToParentFindMany) netRelation() {}

func (r netToParentFindMany) With(params ...NetRelationWith) netToParentFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToParentFindMany) OrderBy(params ...NetOrderByParam) netToParentFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToParentFindMany) Skip(count int) netToParentFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToParentFindMany) Take(count int) netToParentFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToParentFindMany) Cursor(cursor NetCursorParam) netToParentFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToParentFindMany) Exec(ctx context.Context) (
	[]NetModel,
	error,
) {
	var v []NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToParentFindMany) ExecInner(ctx context.Context) (
	[]InnerNet,
	error,
) {
	var v []InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToParentFindMany) Update(params ...NetSetParam) netToParentUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Net"

	r.query.Outputs = countOutput

	var v netToParentUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToParentUpdateMany struct {
	query builder.Query
}

func (r netToParentUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToParentUpdateMany) netModel() {}

func (r netToParentUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToParentUpdateMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToParentFindMany) Delete() netToParentDeleteMany {
	var v netToParentDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Net"

	v.query.Outputs = countOutput

	return v
}

type netToParentDeleteMany struct {
	query builder.Query
}

func (r netToParentDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p netToParentDeleteMany) netModel() {}

func (r netToParentDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToParentDeleteMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToChildrenFindUnique struct {
	query builder.Query
}

func (r netToChildrenFindUnique) getQuery() builder.Query {
	return r.query
}

func (r netToChildrenFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToChildrenFindUnique) with()        {}
func (r netToChildrenFindUnique) netModel()    {}
func (r netToChildrenFindUnique) netRelation() {}

func (r netToChildrenFindUnique) With(params ...NetRelationWith) netToChildrenFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToChildrenFindUnique) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToChildrenFindUnique) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToChildrenFindUnique) Update(params ...NetSetParam) netToChildrenUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Net"

	var v netToChildrenUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToChildrenUpdateUnique struct {
	query builder.Query
}

func (r netToChildrenUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToChildrenUpdateUnique) netModel() {}

func (r netToChildrenUpdateUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToChildrenUpdateUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToChildrenFindUnique) Delete() netToChildrenDeleteUnique {
	var v netToChildrenDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Net"

	return v
}

type netToChildrenDeleteUnique struct {
	query builder.Query
}

func (r netToChildrenDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p netToChildrenDeleteUnique) netModel() {}

func (r netToChildrenDeleteUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToChildrenDeleteUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToChildrenFindFirst struct {
	query builder.Query
}

func (r netToChildrenFindFirst) getQuery() builder.Query {
	return r.query
}

func (r netToChildrenFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r netToChildrenFindFirst) with()        {}
func (r netToChildrenFindFirst) netModel()    {}
func (r netToChildrenFindFirst) netRelation() {}

func (r netToChildrenFindFirst) With(params ...NetRelationWith) netToChildrenFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToChildrenFindFirst) OrderBy(params ...NetOrderByParam) netToChildrenFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToChildrenFindFirst) Skip(count int) netToChildrenFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToChildrenFindFirst) Take(count int) netToChildrenFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToChildrenFindFirst) Cursor(cursor NetCursorParam) netToChildrenFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToChildrenFindFirst) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToChildrenFindFirst) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type netToChildrenFindMany struct {
	query builder.Query
}

func (r netToChildrenFindMany) getQuery() builder.Query {
	return r.query
}

func (r netToChildrenFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToChildrenFindMany) with()        {}
func (r netToChildrenFindMany) netModel()    {}
func (r netToChildrenFindMany) netRelation() {}

func (r netToChildrenFindMany) With(params ...NetRelationWith) netToChildrenFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToChildrenFindMany) OrderBy(params ...NetOrderByParam) netToChildrenFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToChildrenFindMany) Skip(count int) netToChildrenFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToChildrenFindMany) Take(count int) netToChildrenFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToChildrenFindMany) Cursor(cursor NetCursorParam) netToChildrenFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToChildrenFindMany) Exec(ctx context.Context) (
	[]NetModel,
	error,
) {
	var v []NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToChildrenFindMany) ExecInner(ctx context.Context) (
	[]InnerNet,
	error,
) {
	var v []InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToChildrenFindMany) Update(params ...NetSetParam) netToChildrenUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Net"

	r.query.Outputs = countOutput

	var v netToChildrenUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToChildrenUpdateMany struct {
	query builder.Query
}

func (r netToChildrenUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToChildrenUpdateMany) netModel() {}

func (r netToChildrenUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToChildrenUpdateMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToChildrenFindMany) Delete() netToChildrenDeleteMany {
	var v netToChildrenDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Net"

	v.query.Outputs = countOutput

	return v
}

type netToChildrenDeleteMany struct {
	query builder.Query
}

func (r netToChildrenDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p netToChildrenDeleteMany) netModel() {}

func (r netToChildrenDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToChildrenDeleteMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToDevicesFindUnique struct {
	query builder.Query
}

func (r netToDevicesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r netToDevicesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToDevicesFindUnique) with()        {}
func (r netToDevicesFindUnique) netModel()    {}
func (r netToDevicesFindUnique) netRelation() {}

func (r netToDevicesFindUnique) With(params ...DevicesOnNetsRelationWith) netToDevicesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToDevicesFindUnique) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToDevicesFindUnique) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToDevicesFindUnique) Update(params ...NetSetParam) netToDevicesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Net"

	var v netToDevicesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToDevicesUpdateUnique struct {
	query builder.Query
}

func (r netToDevicesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToDevicesUpdateUnique) netModel() {}

func (r netToDevicesUpdateUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToDevicesUpdateUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToDevicesFindUnique) Delete() netToDevicesDeleteUnique {
	var v netToDevicesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Net"

	return v
}

type netToDevicesDeleteUnique struct {
	query builder.Query
}

func (r netToDevicesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p netToDevicesDeleteUnique) netModel() {}

func (r netToDevicesDeleteUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToDevicesDeleteUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToDevicesFindFirst struct {
	query builder.Query
}

func (r netToDevicesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r netToDevicesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r netToDevicesFindFirst) with()        {}
func (r netToDevicesFindFirst) netModel()    {}
func (r netToDevicesFindFirst) netRelation() {}

func (r netToDevicesFindFirst) With(params ...DevicesOnNetsRelationWith) netToDevicesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToDevicesFindFirst) OrderBy(params ...DevicesOnNetsOrderByParam) netToDevicesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToDevicesFindFirst) Skip(count int) netToDevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToDevicesFindFirst) Take(count int) netToDevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToDevicesFindFirst) Cursor(cursor NetCursorParam) netToDevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToDevicesFindFirst) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToDevicesFindFirst) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type netToDevicesFindMany struct {
	query builder.Query
}

func (r netToDevicesFindMany) getQuery() builder.Query {
	return r.query
}

func (r netToDevicesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToDevicesFindMany) with()        {}
func (r netToDevicesFindMany) netModel()    {}
func (r netToDevicesFindMany) netRelation() {}

func (r netToDevicesFindMany) With(params ...DevicesOnNetsRelationWith) netToDevicesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToDevicesFindMany) OrderBy(params ...DevicesOnNetsOrderByParam) netToDevicesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToDevicesFindMany) Skip(count int) netToDevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToDevicesFindMany) Take(count int) netToDevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToDevicesFindMany) Cursor(cursor NetCursorParam) netToDevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToDevicesFindMany) Exec(ctx context.Context) (
	[]NetModel,
	error,
) {
	var v []NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToDevicesFindMany) ExecInner(ctx context.Context) (
	[]InnerNet,
	error,
) {
	var v []InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToDevicesFindMany) Update(params ...NetSetParam) netToDevicesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Net"

	r.query.Outputs = countOutput

	var v netToDevicesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToDevicesUpdateMany struct {
	query builder.Query
}

func (r netToDevicesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToDevicesUpdateMany) netModel() {}

func (r netToDevicesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToDevicesUpdateMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToDevicesFindMany) Delete() netToDevicesDeleteMany {
	var v netToDevicesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Net"

	v.query.Outputs = countOutput

	return v
}

type netToDevicesDeleteMany struct {
	query builder.Query
}

func (r netToDevicesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p netToDevicesDeleteMany) netModel() {}

func (r netToDevicesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToDevicesDeleteMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToPlaceInterfacesFindUnique struct {
	query builder.Query
}

func (r netToPlaceInterfacesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r netToPlaceInterfacesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToPlaceInterfacesFindUnique) with()        {}
func (r netToPlaceInterfacesFindUnique) netModel()    {}
func (r netToPlaceInterfacesFindUnique) netRelation() {}

func (r netToPlaceInterfacesFindUnique) With(params ...PlaceInterfaceRelationWith) netToPlaceInterfacesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToPlaceInterfacesFindUnique) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToPlaceInterfacesFindUnique) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToPlaceInterfacesFindUnique) Update(params ...NetSetParam) netToPlaceInterfacesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Net"

	var v netToPlaceInterfacesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToPlaceInterfacesUpdateUnique struct {
	query builder.Query
}

func (r netToPlaceInterfacesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToPlaceInterfacesUpdateUnique) netModel() {}

func (r netToPlaceInterfacesUpdateUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToPlaceInterfacesUpdateUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToPlaceInterfacesFindUnique) Delete() netToPlaceInterfacesDeleteUnique {
	var v netToPlaceInterfacesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Net"

	return v
}

type netToPlaceInterfacesDeleteUnique struct {
	query builder.Query
}

func (r netToPlaceInterfacesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p netToPlaceInterfacesDeleteUnique) netModel() {}

func (r netToPlaceInterfacesDeleteUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToPlaceInterfacesDeleteUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToPlaceInterfacesFindFirst struct {
	query builder.Query
}

func (r netToPlaceInterfacesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r netToPlaceInterfacesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r netToPlaceInterfacesFindFirst) with()        {}
func (r netToPlaceInterfacesFindFirst) netModel()    {}
func (r netToPlaceInterfacesFindFirst) netRelation() {}

func (r netToPlaceInterfacesFindFirst) With(params ...PlaceInterfaceRelationWith) netToPlaceInterfacesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToPlaceInterfacesFindFirst) OrderBy(params ...PlaceInterfaceOrderByParam) netToPlaceInterfacesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToPlaceInterfacesFindFirst) Skip(count int) netToPlaceInterfacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToPlaceInterfacesFindFirst) Take(count int) netToPlaceInterfacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToPlaceInterfacesFindFirst) Cursor(cursor NetCursorParam) netToPlaceInterfacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToPlaceInterfacesFindFirst) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToPlaceInterfacesFindFirst) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type netToPlaceInterfacesFindMany struct {
	query builder.Query
}

func (r netToPlaceInterfacesFindMany) getQuery() builder.Query {
	return r.query
}

func (r netToPlaceInterfacesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToPlaceInterfacesFindMany) with()        {}
func (r netToPlaceInterfacesFindMany) netModel()    {}
func (r netToPlaceInterfacesFindMany) netRelation() {}

func (r netToPlaceInterfacesFindMany) With(params ...PlaceInterfaceRelationWith) netToPlaceInterfacesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToPlaceInterfacesFindMany) OrderBy(params ...PlaceInterfaceOrderByParam) netToPlaceInterfacesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToPlaceInterfacesFindMany) Skip(count int) netToPlaceInterfacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToPlaceInterfacesFindMany) Take(count int) netToPlaceInterfacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToPlaceInterfacesFindMany) Cursor(cursor NetCursorParam) netToPlaceInterfacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToPlaceInterfacesFindMany) Exec(ctx context.Context) (
	[]NetModel,
	error,
) {
	var v []NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToPlaceInterfacesFindMany) ExecInner(ctx context.Context) (
	[]InnerNet,
	error,
) {
	var v []InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToPlaceInterfacesFindMany) Update(params ...NetSetParam) netToPlaceInterfacesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Net"

	r.query.Outputs = countOutput

	var v netToPlaceInterfacesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToPlaceInterfacesUpdateMany struct {
	query builder.Query
}

func (r netToPlaceInterfacesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToPlaceInterfacesUpdateMany) netModel() {}

func (r netToPlaceInterfacesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToPlaceInterfacesUpdateMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToPlaceInterfacesFindMany) Delete() netToPlaceInterfacesDeleteMany {
	var v netToPlaceInterfacesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Net"

	v.query.Outputs = countOutput

	return v
}

type netToPlaceInterfacesDeleteMany struct {
	query builder.Query
}

func (r netToPlaceInterfacesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p netToPlaceInterfacesDeleteMany) netModel() {}

func (r netToPlaceInterfacesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToPlaceInterfacesDeleteMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToTransitionInterfacesFindUnique struct {
	query builder.Query
}

func (r netToTransitionInterfacesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r netToTransitionInterfacesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToTransitionInterfacesFindUnique) with()        {}
func (r netToTransitionInterfacesFindUnique) netModel()    {}
func (r netToTransitionInterfacesFindUnique) netRelation() {}

func (r netToTransitionInterfacesFindUnique) With(params ...TransitionInterfaceRelationWith) netToTransitionInterfacesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToTransitionInterfacesFindUnique) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToTransitionInterfacesFindUnique) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToTransitionInterfacesFindUnique) Update(params ...NetSetParam) netToTransitionInterfacesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Net"

	var v netToTransitionInterfacesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToTransitionInterfacesUpdateUnique struct {
	query builder.Query
}

func (r netToTransitionInterfacesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToTransitionInterfacesUpdateUnique) netModel() {}

func (r netToTransitionInterfacesUpdateUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToTransitionInterfacesUpdateUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToTransitionInterfacesFindUnique) Delete() netToTransitionInterfacesDeleteUnique {
	var v netToTransitionInterfacesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Net"

	return v
}

type netToTransitionInterfacesDeleteUnique struct {
	query builder.Query
}

func (r netToTransitionInterfacesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p netToTransitionInterfacesDeleteUnique) netModel() {}

func (r netToTransitionInterfacesDeleteUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToTransitionInterfacesDeleteUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToTransitionInterfacesFindFirst struct {
	query builder.Query
}

func (r netToTransitionInterfacesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r netToTransitionInterfacesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r netToTransitionInterfacesFindFirst) with()        {}
func (r netToTransitionInterfacesFindFirst) netModel()    {}
func (r netToTransitionInterfacesFindFirst) netRelation() {}

func (r netToTransitionInterfacesFindFirst) With(params ...TransitionInterfaceRelationWith) netToTransitionInterfacesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToTransitionInterfacesFindFirst) OrderBy(params ...TransitionInterfaceOrderByParam) netToTransitionInterfacesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToTransitionInterfacesFindFirst) Skip(count int) netToTransitionInterfacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToTransitionInterfacesFindFirst) Take(count int) netToTransitionInterfacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToTransitionInterfacesFindFirst) Cursor(cursor NetCursorParam) netToTransitionInterfacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToTransitionInterfacesFindFirst) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToTransitionInterfacesFindFirst) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type netToTransitionInterfacesFindMany struct {
	query builder.Query
}

func (r netToTransitionInterfacesFindMany) getQuery() builder.Query {
	return r.query
}

func (r netToTransitionInterfacesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToTransitionInterfacesFindMany) with()        {}
func (r netToTransitionInterfacesFindMany) netModel()    {}
func (r netToTransitionInterfacesFindMany) netRelation() {}

func (r netToTransitionInterfacesFindMany) With(params ...TransitionInterfaceRelationWith) netToTransitionInterfacesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToTransitionInterfacesFindMany) OrderBy(params ...TransitionInterfaceOrderByParam) netToTransitionInterfacesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToTransitionInterfacesFindMany) Skip(count int) netToTransitionInterfacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToTransitionInterfacesFindMany) Take(count int) netToTransitionInterfacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToTransitionInterfacesFindMany) Cursor(cursor NetCursorParam) netToTransitionInterfacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToTransitionInterfacesFindMany) Exec(ctx context.Context) (
	[]NetModel,
	error,
) {
	var v []NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToTransitionInterfacesFindMany) ExecInner(ctx context.Context) (
	[]InnerNet,
	error,
) {
	var v []InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToTransitionInterfacesFindMany) Update(params ...NetSetParam) netToTransitionInterfacesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Net"

	r.query.Outputs = countOutput

	var v netToTransitionInterfacesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToTransitionInterfacesUpdateMany struct {
	query builder.Query
}

func (r netToTransitionInterfacesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToTransitionInterfacesUpdateMany) netModel() {}

func (r netToTransitionInterfacesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToTransitionInterfacesUpdateMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToTransitionInterfacesFindMany) Delete() netToTransitionInterfacesDeleteMany {
	var v netToTransitionInterfacesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Net"

	v.query.Outputs = countOutput

	return v
}

type netToTransitionInterfacesDeleteMany struct {
	query builder.Query
}

func (r netToTransitionInterfacesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p netToTransitionInterfacesDeleteMany) netModel() {}

func (r netToTransitionInterfacesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToTransitionInterfacesDeleteMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToRunsFindUnique struct {
	query builder.Query
}

func (r netToRunsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r netToRunsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToRunsFindUnique) with()        {}
func (r netToRunsFindUnique) netModel()    {}
func (r netToRunsFindUnique) netRelation() {}

func (r netToRunsFindUnique) With(params ...RunRelationWith) netToRunsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToRunsFindUnique) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToRunsFindUnique) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToRunsFindUnique) Update(params ...NetSetParam) netToRunsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Net"

	var v netToRunsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToRunsUpdateUnique struct {
	query builder.Query
}

func (r netToRunsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netToRunsUpdateUnique) netModel() {}

func (r netToRunsUpdateUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToRunsUpdateUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToRunsFindUnique) Delete() netToRunsDeleteUnique {
	var v netToRunsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Net"

	return v
}

type netToRunsDeleteUnique struct {
	query builder.Query
}

func (r netToRunsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p netToRunsDeleteUnique) netModel() {}

func (r netToRunsDeleteUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToRunsDeleteUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netToRunsFindFirst struct {
	query builder.Query
}

func (r netToRunsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r netToRunsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r netToRunsFindFirst) with()        {}
func (r netToRunsFindFirst) netModel()    {}
func (r netToRunsFindFirst) netRelation() {}

func (r netToRunsFindFirst) With(params ...RunRelationWith) netToRunsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToRunsFindFirst) OrderBy(params ...RunOrderByParam) netToRunsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToRunsFindFirst) Skip(count int) netToRunsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToRunsFindFirst) Take(count int) netToRunsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToRunsFindFirst) Cursor(cursor NetCursorParam) netToRunsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToRunsFindFirst) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netToRunsFindFirst) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type netToRunsFindMany struct {
	query builder.Query
}

func (r netToRunsFindMany) getQuery() builder.Query {
	return r.query
}

func (r netToRunsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToRunsFindMany) with()        {}
func (r netToRunsFindMany) netModel()    {}
func (r netToRunsFindMany) netRelation() {}

func (r netToRunsFindMany) With(params ...RunRelationWith) netToRunsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netToRunsFindMany) OrderBy(params ...RunOrderByParam) netToRunsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netToRunsFindMany) Skip(count int) netToRunsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netToRunsFindMany) Take(count int) netToRunsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netToRunsFindMany) Cursor(cursor NetCursorParam) netToRunsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netToRunsFindMany) Exec(ctx context.Context) (
	[]NetModel,
	error,
) {
	var v []NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToRunsFindMany) ExecInner(ctx context.Context) (
	[]InnerNet,
	error,
) {
	var v []InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netToRunsFindMany) Update(params ...NetSetParam) netToRunsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Net"

	r.query.Outputs = countOutput

	var v netToRunsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netToRunsUpdateMany struct {
	query builder.Query
}

func (r netToRunsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netToRunsUpdateMany) netModel() {}

func (r netToRunsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToRunsUpdateMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netToRunsFindMany) Delete() netToRunsDeleteMany {
	var v netToRunsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Net"

	v.query.Outputs = countOutput

	return v
}

type netToRunsDeleteMany struct {
	query builder.Query
}

func (r netToRunsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p netToRunsDeleteMany) netModel() {}

func (r netToRunsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netToRunsDeleteMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netFindUnique struct {
	query builder.Query
}

func (r netFindUnique) getQuery() builder.Query {
	return r.query
}

func (r netFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netFindUnique) with()        {}
func (r netFindUnique) netModel()    {}
func (r netFindUnique) netRelation() {}

func (r netActions) FindUnique(
	params NetEqualsUniqueWhereParam,
) netFindUnique {
	var v netFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Net"
	v.query.Outputs = netOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r netFindUnique) With(params ...NetRelationWith) netFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netFindUnique) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netFindUnique) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netFindUnique) Update(params ...NetSetParam) netUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Net"

	var v netUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netUpdateUnique struct {
	query builder.Query
}

func (r netUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r netUpdateUnique) netModel() {}

func (r netUpdateUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netUpdateUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netFindUnique) Delete() netDeleteUnique {
	var v netDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Net"

	return v
}

type netDeleteUnique struct {
	query builder.Query
}

func (r netDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p netDeleteUnique) netModel() {}

func (r netDeleteUnique) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netDeleteUnique) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netFindFirst struct {
	query builder.Query
}

func (r netFindFirst) getQuery() builder.Query {
	return r.query
}

func (r netFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r netFindFirst) with()        {}
func (r netFindFirst) netModel()    {}
func (r netFindFirst) netRelation() {}

func (r netActions) FindFirst(
	params ...NetWhereParam,
) netFindFirst {
	var v netFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Net"
	v.query.Outputs = netOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r netFindFirst) With(params ...NetRelationWith) netFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netFindFirst) OrderBy(params ...NetOrderByParam) netFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netFindFirst) Skip(count int) netFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netFindFirst) Take(count int) netFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netFindFirst) Cursor(cursor NetCursorParam) netFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netFindFirst) Exec(ctx context.Context) (
	*NetModel,
	error,
) {
	var v *NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r netFindFirst) ExecInner(ctx context.Context) (
	*InnerNet,
	error,
) {
	var v *InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type netFindMany struct {
	query builder.Query
}

func (r netFindMany) getQuery() builder.Query {
	return r.query
}

func (r netFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netFindMany) with()        {}
func (r netFindMany) netModel()    {}
func (r netFindMany) netRelation() {}

func (r netActions) FindMany(
	params ...NetWhereParam,
) netFindMany {
	var v netFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Net"
	v.query.Outputs = netOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r netFindMany) With(params ...NetRelationWith) netFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r netFindMany) OrderBy(params ...NetOrderByParam) netFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r netFindMany) Skip(count int) netFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r netFindMany) Take(count int) netFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r netFindMany) Cursor(cursor NetCursorParam) netFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r netFindMany) Exec(ctx context.Context) (
	[]NetModel,
	error,
) {
	var v []NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netFindMany) ExecInner(ctx context.Context) (
	[]InnerNet,
	error,
) {
	var v []InnerNet
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r netFindMany) Update(params ...NetSetParam) netUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Net"

	r.query.Outputs = countOutput

	var v netUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type netUpdateMany struct {
	query builder.Query
}

func (r netUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r netUpdateMany) netModel() {}

func (r netUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netUpdateMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r netFindMany) Delete() netDeleteMany {
	var v netDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Net"

	v.query.Outputs = countOutput

	return v
}

type netDeleteMany struct {
	query builder.Query
}

func (r netDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p netDeleteMany) netModel() {}

func (r netDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netDeleteMany) Tx() netManyTxResult {
	v := NewnetManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type placeInterfaceToNetFindUnique struct {
	query builder.Query
}

func (r placeInterfaceToNetFindUnique) getQuery() builder.Query {
	return r.query
}

func (r placeInterfaceToNetFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r placeInterfaceToNetFindUnique) with()                   {}
func (r placeInterfaceToNetFindUnique) placeInterfaceModel()    {}
func (r placeInterfaceToNetFindUnique) placeInterfaceRelation() {}

func (r placeInterfaceToNetFindUnique) With(params ...NetRelationWith) placeInterfaceToNetFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeInterfaceToNetFindUnique) Exec(ctx context.Context) (
	*PlaceInterfaceModel,
	error,
) {
	var v *PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeInterfaceToNetFindUnique) ExecInner(ctx context.Context) (
	*InnerPlaceInterface,
	error,
) {
	var v *InnerPlaceInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeInterfaceToNetFindUnique) Update(params ...PlaceInterfaceSetParam) placeInterfaceToNetUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "PlaceInterface"

	var v placeInterfaceToNetUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type placeInterfaceToNetUpdateUnique struct {
	query builder.Query
}

func (r placeInterfaceToNetUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r placeInterfaceToNetUpdateUnique) placeInterfaceModel() {}

func (r placeInterfaceToNetUpdateUnique) Exec(ctx context.Context) (*PlaceInterfaceModel, error) {
	var v PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeInterfaceToNetUpdateUnique) Tx() placeInterfaceUniqueTxResult {
	v := NewplaceInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r placeInterfaceToNetFindUnique) Delete() placeInterfaceToNetDeleteUnique {
	var v placeInterfaceToNetDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "PlaceInterface"

	return v
}

type placeInterfaceToNetDeleteUnique struct {
	query builder.Query
}

func (r placeInterfaceToNetDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p placeInterfaceToNetDeleteUnique) placeInterfaceModel() {}

func (r placeInterfaceToNetDeleteUnique) Exec(ctx context.Context) (*PlaceInterfaceModel, error) {
	var v PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeInterfaceToNetDeleteUnique) Tx() placeInterfaceUniqueTxResult {
	v := NewplaceInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type placeInterfaceToNetFindFirst struct {
	query builder.Query
}

func (r placeInterfaceToNetFindFirst) getQuery() builder.Query {
	return r.query
}

func (r placeInterfaceToNetFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r placeInterfaceToNetFindFirst) with()                   {}
func (r placeInterfaceToNetFindFirst) placeInterfaceModel()    {}
func (r placeInterfaceToNetFindFirst) placeInterfaceRelation() {}

func (r placeInterfaceToNetFindFirst) With(params ...NetRelationWith) placeInterfaceToNetFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeInterfaceToNetFindFirst) OrderBy(params ...NetOrderByParam) placeInterfaceToNetFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r placeInterfaceToNetFindFirst) Skip(count int) placeInterfaceToNetFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r placeInterfaceToNetFindFirst) Take(count int) placeInterfaceToNetFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r placeInterfaceToNetFindFirst) Cursor(cursor PlaceInterfaceCursorParam) placeInterfaceToNetFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r placeInterfaceToNetFindFirst) Exec(ctx context.Context) (
	*PlaceInterfaceModel,
	error,
) {
	var v *PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeInterfaceToNetFindFirst) ExecInner(ctx context.Context) (
	*InnerPlaceInterface,
	error,
) {
	var v *InnerPlaceInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type placeInterfaceToNetFindMany struct {
	query builder.Query
}

func (r placeInterfaceToNetFindMany) getQuery() builder.Query {
	return r.query
}

func (r placeInterfaceToNetFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r placeInterfaceToNetFindMany) with()                   {}
func (r placeInterfaceToNetFindMany) placeInterfaceModel()    {}
func (r placeInterfaceToNetFindMany) placeInterfaceRelation() {}

func (r placeInterfaceToNetFindMany) With(params ...NetRelationWith) placeInterfaceToNetFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeInterfaceToNetFindMany) OrderBy(params ...NetOrderByParam) placeInterfaceToNetFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r placeInterfaceToNetFindMany) Skip(count int) placeInterfaceToNetFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r placeInterfaceToNetFindMany) Take(count int) placeInterfaceToNetFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r placeInterfaceToNetFindMany) Cursor(cursor PlaceInterfaceCursorParam) placeInterfaceToNetFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r placeInterfaceToNetFindMany) Exec(ctx context.Context) (
	[]PlaceInterfaceModel,
	error,
) {
	var v []PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r placeInterfaceToNetFindMany) ExecInner(ctx context.Context) (
	[]InnerPlaceInterface,
	error,
) {
	var v []InnerPlaceInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r placeInterfaceToNetFindMany) Update(params ...PlaceInterfaceSetParam) placeInterfaceToNetUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "PlaceInterface"

	r.query.Outputs = countOutput

	var v placeInterfaceToNetUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type placeInterfaceToNetUpdateMany struct {
	query builder.Query
}

func (r placeInterfaceToNetUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r placeInterfaceToNetUpdateMany) placeInterfaceModel() {}

func (r placeInterfaceToNetUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeInterfaceToNetUpdateMany) Tx() placeInterfaceManyTxResult {
	v := NewplaceInterfaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r placeInterfaceToNetFindMany) Delete() placeInterfaceToNetDeleteMany {
	var v placeInterfaceToNetDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "PlaceInterface"

	v.query.Outputs = countOutput

	return v
}

type placeInterfaceToNetDeleteMany struct {
	query builder.Query
}

func (r placeInterfaceToNetDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p placeInterfaceToNetDeleteMany) placeInterfaceModel() {}

func (r placeInterfaceToNetDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeInterfaceToNetDeleteMany) Tx() placeInterfaceManyTxResult {
	v := NewplaceInterfaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type placeInterfaceToPlacesFindUnique struct {
	query builder.Query
}

func (r placeInterfaceToPlacesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r placeInterfaceToPlacesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r placeInterfaceToPlacesFindUnique) with()                   {}
func (r placeInterfaceToPlacesFindUnique) placeInterfaceModel()    {}
func (r placeInterfaceToPlacesFindUnique) placeInterfaceRelation() {}

func (r placeInterfaceToPlacesFindUnique) With(params ...PlaceRelationWith) placeInterfaceToPlacesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeInterfaceToPlacesFindUnique) Exec(ctx context.Context) (
	*PlaceInterfaceModel,
	error,
) {
	var v *PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeInterfaceToPlacesFindUnique) ExecInner(ctx context.Context) (
	*InnerPlaceInterface,
	error,
) {
	var v *InnerPlaceInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeInterfaceToPlacesFindUnique) Update(params ...PlaceInterfaceSetParam) placeInterfaceToPlacesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "PlaceInterface"

	var v placeInterfaceToPlacesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type placeInterfaceToPlacesUpdateUnique struct {
	query builder.Query
}

func (r placeInterfaceToPlacesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r placeInterfaceToPlacesUpdateUnique) placeInterfaceModel() {}

func (r placeInterfaceToPlacesUpdateUnique) Exec(ctx context.Context) (*PlaceInterfaceModel, error) {
	var v PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeInterfaceToPlacesUpdateUnique) Tx() placeInterfaceUniqueTxResult {
	v := NewplaceInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r placeInterfaceToPlacesFindUnique) Delete() placeInterfaceToPlacesDeleteUnique {
	var v placeInterfaceToPlacesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "PlaceInterface"

	return v
}

type placeInterfaceToPlacesDeleteUnique struct {
	query builder.Query
}

func (r placeInterfaceToPlacesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p placeInterfaceToPlacesDeleteUnique) placeInterfaceModel() {}

func (r placeInterfaceToPlacesDeleteUnique) Exec(ctx context.Context) (*PlaceInterfaceModel, error) {
	var v PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeInterfaceToPlacesDeleteUnique) Tx() placeInterfaceUniqueTxResult {
	v := NewplaceInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type placeInterfaceToPlacesFindFirst struct {
	query builder.Query
}

func (r placeInterfaceToPlacesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r placeInterfaceToPlacesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r placeInterfaceToPlacesFindFirst) with()                   {}
func (r placeInterfaceToPlacesFindFirst) placeInterfaceModel()    {}
func (r placeInterfaceToPlacesFindFirst) placeInterfaceRelation() {}

func (r placeInterfaceToPlacesFindFirst) With(params ...PlaceRelationWith) placeInterfaceToPlacesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeInterfaceToPlacesFindFirst) OrderBy(params ...PlaceOrderByParam) placeInterfaceToPlacesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r placeInterfaceToPlacesFindFirst) Skip(count int) placeInterfaceToPlacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r placeInterfaceToPlacesFindFirst) Take(count int) placeInterfaceToPlacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r placeInterfaceToPlacesFindFirst) Cursor(cursor PlaceInterfaceCursorParam) placeInterfaceToPlacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r placeInterfaceToPlacesFindFirst) Exec(ctx context.Context) (
	*PlaceInterfaceModel,
	error,
) {
	var v *PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeInterfaceToPlacesFindFirst) ExecInner(ctx context.Context) (
	*InnerPlaceInterface,
	error,
) {
	var v *InnerPlaceInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type placeInterfaceToPlacesFindMany struct {
	query builder.Query
}

func (r placeInterfaceToPlacesFindMany) getQuery() builder.Query {
	return r.query
}

func (r placeInterfaceToPlacesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r placeInterfaceToPlacesFindMany) with()                   {}
func (r placeInterfaceToPlacesFindMany) placeInterfaceModel()    {}
func (r placeInterfaceToPlacesFindMany) placeInterfaceRelation() {}

func (r placeInterfaceToPlacesFindMany) With(params ...PlaceRelationWith) placeInterfaceToPlacesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeInterfaceToPlacesFindMany) OrderBy(params ...PlaceOrderByParam) placeInterfaceToPlacesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r placeInterfaceToPlacesFindMany) Skip(count int) placeInterfaceToPlacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r placeInterfaceToPlacesFindMany) Take(count int) placeInterfaceToPlacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r placeInterfaceToPlacesFindMany) Cursor(cursor PlaceInterfaceCursorParam) placeInterfaceToPlacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r placeInterfaceToPlacesFindMany) Exec(ctx context.Context) (
	[]PlaceInterfaceModel,
	error,
) {
	var v []PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r placeInterfaceToPlacesFindMany) ExecInner(ctx context.Context) (
	[]InnerPlaceInterface,
	error,
) {
	var v []InnerPlaceInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r placeInterfaceToPlacesFindMany) Update(params ...PlaceInterfaceSetParam) placeInterfaceToPlacesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "PlaceInterface"

	r.query.Outputs = countOutput

	var v placeInterfaceToPlacesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type placeInterfaceToPlacesUpdateMany struct {
	query builder.Query
}

func (r placeInterfaceToPlacesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r placeInterfaceToPlacesUpdateMany) placeInterfaceModel() {}

func (r placeInterfaceToPlacesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeInterfaceToPlacesUpdateMany) Tx() placeInterfaceManyTxResult {
	v := NewplaceInterfaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r placeInterfaceToPlacesFindMany) Delete() placeInterfaceToPlacesDeleteMany {
	var v placeInterfaceToPlacesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "PlaceInterface"

	v.query.Outputs = countOutput

	return v
}

type placeInterfaceToPlacesDeleteMany struct {
	query builder.Query
}

func (r placeInterfaceToPlacesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p placeInterfaceToPlacesDeleteMany) placeInterfaceModel() {}

func (r placeInterfaceToPlacesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeInterfaceToPlacesDeleteMany) Tx() placeInterfaceManyTxResult {
	v := NewplaceInterfaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type placeInterfaceFindUnique struct {
	query builder.Query
}

func (r placeInterfaceFindUnique) getQuery() builder.Query {
	return r.query
}

func (r placeInterfaceFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r placeInterfaceFindUnique) with()                   {}
func (r placeInterfaceFindUnique) placeInterfaceModel()    {}
func (r placeInterfaceFindUnique) placeInterfaceRelation() {}

func (r placeInterfaceActions) FindUnique(
	params PlaceInterfaceEqualsUniqueWhereParam,
) placeInterfaceFindUnique {
	var v placeInterfaceFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "PlaceInterface"
	v.query.Outputs = placeInterfaceOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r placeInterfaceFindUnique) With(params ...PlaceInterfaceRelationWith) placeInterfaceFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeInterfaceFindUnique) Exec(ctx context.Context) (
	*PlaceInterfaceModel,
	error,
) {
	var v *PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeInterfaceFindUnique) ExecInner(ctx context.Context) (
	*InnerPlaceInterface,
	error,
) {
	var v *InnerPlaceInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeInterfaceFindUnique) Update(params ...PlaceInterfaceSetParam) placeInterfaceUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "PlaceInterface"

	var v placeInterfaceUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type placeInterfaceUpdateUnique struct {
	query builder.Query
}

func (r placeInterfaceUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r placeInterfaceUpdateUnique) placeInterfaceModel() {}

func (r placeInterfaceUpdateUnique) Exec(ctx context.Context) (*PlaceInterfaceModel, error) {
	var v PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeInterfaceUpdateUnique) Tx() placeInterfaceUniqueTxResult {
	v := NewplaceInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r placeInterfaceFindUnique) Delete() placeInterfaceDeleteUnique {
	var v placeInterfaceDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "PlaceInterface"

	return v
}

type placeInterfaceDeleteUnique struct {
	query builder.Query
}

func (r placeInterfaceDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p placeInterfaceDeleteUnique) placeInterfaceModel() {}

func (r placeInterfaceDeleteUnique) Exec(ctx context.Context) (*PlaceInterfaceModel, error) {
	var v PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeInterfaceDeleteUnique) Tx() placeInterfaceUniqueTxResult {
	v := NewplaceInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type placeInterfaceFindFirst struct {
	query builder.Query
}

func (r placeInterfaceFindFirst) getQuery() builder.Query {
	return r.query
}

func (r placeInterfaceFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r placeInterfaceFindFirst) with()                   {}
func (r placeInterfaceFindFirst) placeInterfaceModel()    {}
func (r placeInterfaceFindFirst) placeInterfaceRelation() {}

func (r placeInterfaceActions) FindFirst(
	params ...PlaceInterfaceWhereParam,
) placeInterfaceFindFirst {
	var v placeInterfaceFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "PlaceInterface"
	v.query.Outputs = placeInterfaceOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r placeInterfaceFindFirst) With(params ...PlaceInterfaceRelationWith) placeInterfaceFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeInterfaceFindFirst) OrderBy(params ...PlaceInterfaceOrderByParam) placeInterfaceFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r placeInterfaceFindFirst) Skip(count int) placeInterfaceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r placeInterfaceFindFirst) Take(count int) placeInterfaceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r placeInterfaceFindFirst) Cursor(cursor PlaceInterfaceCursorParam) placeInterfaceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r placeInterfaceFindFirst) Exec(ctx context.Context) (
	*PlaceInterfaceModel,
	error,
) {
	var v *PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeInterfaceFindFirst) ExecInner(ctx context.Context) (
	*InnerPlaceInterface,
	error,
) {
	var v *InnerPlaceInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type placeInterfaceFindMany struct {
	query builder.Query
}

func (r placeInterfaceFindMany) getQuery() builder.Query {
	return r.query
}

func (r placeInterfaceFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r placeInterfaceFindMany) with()                   {}
func (r placeInterfaceFindMany) placeInterfaceModel()    {}
func (r placeInterfaceFindMany) placeInterfaceRelation() {}

func (r placeInterfaceActions) FindMany(
	params ...PlaceInterfaceWhereParam,
) placeInterfaceFindMany {
	var v placeInterfaceFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "PlaceInterface"
	v.query.Outputs = placeInterfaceOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r placeInterfaceFindMany) With(params ...PlaceInterfaceRelationWith) placeInterfaceFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeInterfaceFindMany) OrderBy(params ...PlaceInterfaceOrderByParam) placeInterfaceFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r placeInterfaceFindMany) Skip(count int) placeInterfaceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r placeInterfaceFindMany) Take(count int) placeInterfaceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r placeInterfaceFindMany) Cursor(cursor PlaceInterfaceCursorParam) placeInterfaceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r placeInterfaceFindMany) Exec(ctx context.Context) (
	[]PlaceInterfaceModel,
	error,
) {
	var v []PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r placeInterfaceFindMany) ExecInner(ctx context.Context) (
	[]InnerPlaceInterface,
	error,
) {
	var v []InnerPlaceInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r placeInterfaceFindMany) Update(params ...PlaceInterfaceSetParam) placeInterfaceUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "PlaceInterface"

	r.query.Outputs = countOutput

	var v placeInterfaceUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type placeInterfaceUpdateMany struct {
	query builder.Query
}

func (r placeInterfaceUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r placeInterfaceUpdateMany) placeInterfaceModel() {}

func (r placeInterfaceUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeInterfaceUpdateMany) Tx() placeInterfaceManyTxResult {
	v := NewplaceInterfaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r placeInterfaceFindMany) Delete() placeInterfaceDeleteMany {
	var v placeInterfaceDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "PlaceInterface"

	v.query.Outputs = countOutput

	return v
}

type placeInterfaceDeleteMany struct {
	query builder.Query
}

func (r placeInterfaceDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p placeInterfaceDeleteMany) placeInterfaceModel() {}

func (r placeInterfaceDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeInterfaceDeleteMany) Tx() placeInterfaceManyTxResult {
	v := NewplaceInterfaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionInterfaceToNetFindUnique struct {
	query builder.Query
}

func (r transitionInterfaceToNetFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToNetFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToNetFindUnique) with()                        {}
func (r transitionInterfaceToNetFindUnique) transitionInterfaceModel()    {}
func (r transitionInterfaceToNetFindUnique) transitionInterfaceRelation() {}

func (r transitionInterfaceToNetFindUnique) With(params ...NetRelationWith) transitionInterfaceToNetFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionInterfaceToNetFindUnique) Exec(ctx context.Context) (
	*TransitionInterfaceModel,
	error,
) {
	var v *TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionInterfaceToNetFindUnique) ExecInner(ctx context.Context) (
	*InnerTransitionInterface,
	error,
) {
	var v *InnerTransitionInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionInterfaceToNetFindUnique) Update(params ...TransitionInterfaceSetParam) transitionInterfaceToNetUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "TransitionInterface"

	var v transitionInterfaceToNetUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionInterfaceToNetUpdateUnique struct {
	query builder.Query
}

func (r transitionInterfaceToNetUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToNetUpdateUnique) transitionInterfaceModel() {}

func (r transitionInterfaceToNetUpdateUnique) Exec(ctx context.Context) (*TransitionInterfaceModel, error) {
	var v TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceToNetUpdateUnique) Tx() transitionInterfaceUniqueTxResult {
	v := NewtransitionInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionInterfaceToNetFindUnique) Delete() transitionInterfaceToNetDeleteUnique {
	var v transitionInterfaceToNetDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "TransitionInterface"

	return v
}

type transitionInterfaceToNetDeleteUnique struct {
	query builder.Query
}

func (r transitionInterfaceToNetDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionInterfaceToNetDeleteUnique) transitionInterfaceModel() {}

func (r transitionInterfaceToNetDeleteUnique) Exec(ctx context.Context) (*TransitionInterfaceModel, error) {
	var v TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceToNetDeleteUnique) Tx() transitionInterfaceUniqueTxResult {
	v := NewtransitionInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionInterfaceToNetFindFirst struct {
	query builder.Query
}

func (r transitionInterfaceToNetFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToNetFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToNetFindFirst) with()                        {}
func (r transitionInterfaceToNetFindFirst) transitionInterfaceModel()    {}
func (r transitionInterfaceToNetFindFirst) transitionInterfaceRelation() {}

func (r transitionInterfaceToNetFindFirst) With(params ...NetRelationWith) transitionInterfaceToNetFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionInterfaceToNetFindFirst) OrderBy(params ...NetOrderByParam) transitionInterfaceToNetFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionInterfaceToNetFindFirst) Skip(count int) transitionInterfaceToNetFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionInterfaceToNetFindFirst) Take(count int) transitionInterfaceToNetFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionInterfaceToNetFindFirst) Cursor(cursor TransitionInterfaceCursorParam) transitionInterfaceToNetFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionInterfaceToNetFindFirst) Exec(ctx context.Context) (
	*TransitionInterfaceModel,
	error,
) {
	var v *TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionInterfaceToNetFindFirst) ExecInner(ctx context.Context) (
	*InnerTransitionInterface,
	error,
) {
	var v *InnerTransitionInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transitionInterfaceToNetFindMany struct {
	query builder.Query
}

func (r transitionInterfaceToNetFindMany) getQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToNetFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToNetFindMany) with()                        {}
func (r transitionInterfaceToNetFindMany) transitionInterfaceModel()    {}
func (r transitionInterfaceToNetFindMany) transitionInterfaceRelation() {}

func (r transitionInterfaceToNetFindMany) With(params ...NetRelationWith) transitionInterfaceToNetFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionInterfaceToNetFindMany) OrderBy(params ...NetOrderByParam) transitionInterfaceToNetFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionInterfaceToNetFindMany) Skip(count int) transitionInterfaceToNetFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionInterfaceToNetFindMany) Take(count int) transitionInterfaceToNetFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionInterfaceToNetFindMany) Cursor(cursor TransitionInterfaceCursorParam) transitionInterfaceToNetFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionInterfaceToNetFindMany) Exec(ctx context.Context) (
	[]TransitionInterfaceModel,
	error,
) {
	var v []TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionInterfaceToNetFindMany) ExecInner(ctx context.Context) (
	[]InnerTransitionInterface,
	error,
) {
	var v []InnerTransitionInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionInterfaceToNetFindMany) Update(params ...TransitionInterfaceSetParam) transitionInterfaceToNetUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "TransitionInterface"

	r.query.Outputs = countOutput

	var v transitionInterfaceToNetUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionInterfaceToNetUpdateMany struct {
	query builder.Query
}

func (r transitionInterfaceToNetUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToNetUpdateMany) transitionInterfaceModel() {}

func (r transitionInterfaceToNetUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceToNetUpdateMany) Tx() transitionInterfaceManyTxResult {
	v := NewtransitionInterfaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionInterfaceToNetFindMany) Delete() transitionInterfaceToNetDeleteMany {
	var v transitionInterfaceToNetDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "TransitionInterface"

	v.query.Outputs = countOutput

	return v
}

type transitionInterfaceToNetDeleteMany struct {
	query builder.Query
}

func (r transitionInterfaceToNetDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionInterfaceToNetDeleteMany) transitionInterfaceModel() {}

func (r transitionInterfaceToNetDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceToNetDeleteMany) Tx() transitionInterfaceManyTxResult {
	v := NewtransitionInterfaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionInterfaceToEventsFindUnique struct {
	query builder.Query
}

func (r transitionInterfaceToEventsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToEventsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToEventsFindUnique) with()                        {}
func (r transitionInterfaceToEventsFindUnique) transitionInterfaceModel()    {}
func (r transitionInterfaceToEventsFindUnique) transitionInterfaceRelation() {}

func (r transitionInterfaceToEventsFindUnique) With(params ...EventRelationWith) transitionInterfaceToEventsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionInterfaceToEventsFindUnique) Exec(ctx context.Context) (
	*TransitionInterfaceModel,
	error,
) {
	var v *TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionInterfaceToEventsFindUnique) ExecInner(ctx context.Context) (
	*InnerTransitionInterface,
	error,
) {
	var v *InnerTransitionInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionInterfaceToEventsFindUnique) Update(params ...TransitionInterfaceSetParam) transitionInterfaceToEventsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "TransitionInterface"

	var v transitionInterfaceToEventsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionInterfaceToEventsUpdateUnique struct {
	query builder.Query
}

func (r transitionInterfaceToEventsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToEventsUpdateUnique) transitionInterfaceModel() {}

func (r transitionInterfaceToEventsUpdateUnique) Exec(ctx context.Context) (*TransitionInterfaceModel, error) {
	var v TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceToEventsUpdateUnique) Tx() transitionInterfaceUniqueTxResult {
	v := NewtransitionInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionInterfaceToEventsFindUnique) Delete() transitionInterfaceToEventsDeleteUnique {
	var v transitionInterfaceToEventsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "TransitionInterface"

	return v
}

type transitionInterfaceToEventsDeleteUnique struct {
	query builder.Query
}

func (r transitionInterfaceToEventsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionInterfaceToEventsDeleteUnique) transitionInterfaceModel() {}

func (r transitionInterfaceToEventsDeleteUnique) Exec(ctx context.Context) (*TransitionInterfaceModel, error) {
	var v TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceToEventsDeleteUnique) Tx() transitionInterfaceUniqueTxResult {
	v := NewtransitionInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionInterfaceToEventsFindFirst struct {
	query builder.Query
}

func (r transitionInterfaceToEventsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToEventsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToEventsFindFirst) with()                        {}
func (r transitionInterfaceToEventsFindFirst) transitionInterfaceModel()    {}
func (r transitionInterfaceToEventsFindFirst) transitionInterfaceRelation() {}

func (r transitionInterfaceToEventsFindFirst) With(params ...EventRelationWith) transitionInterfaceToEventsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionInterfaceToEventsFindFirst) OrderBy(params ...EventOrderByParam) transitionInterfaceToEventsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionInterfaceToEventsFindFirst) Skip(count int) transitionInterfaceToEventsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionInterfaceToEventsFindFirst) Take(count int) transitionInterfaceToEventsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionInterfaceToEventsFindFirst) Cursor(cursor TransitionInterfaceCursorParam) transitionInterfaceToEventsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionInterfaceToEventsFindFirst) Exec(ctx context.Context) (
	*TransitionInterfaceModel,
	error,
) {
	var v *TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionInterfaceToEventsFindFirst) ExecInner(ctx context.Context) (
	*InnerTransitionInterface,
	error,
) {
	var v *InnerTransitionInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transitionInterfaceToEventsFindMany struct {
	query builder.Query
}

func (r transitionInterfaceToEventsFindMany) getQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToEventsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToEventsFindMany) with()                        {}
func (r transitionInterfaceToEventsFindMany) transitionInterfaceModel()    {}
func (r transitionInterfaceToEventsFindMany) transitionInterfaceRelation() {}

func (r transitionInterfaceToEventsFindMany) With(params ...EventRelationWith) transitionInterfaceToEventsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionInterfaceToEventsFindMany) OrderBy(params ...EventOrderByParam) transitionInterfaceToEventsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionInterfaceToEventsFindMany) Skip(count int) transitionInterfaceToEventsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionInterfaceToEventsFindMany) Take(count int) transitionInterfaceToEventsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionInterfaceToEventsFindMany) Cursor(cursor TransitionInterfaceCursorParam) transitionInterfaceToEventsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionInterfaceToEventsFindMany) Exec(ctx context.Context) (
	[]TransitionInterfaceModel,
	error,
) {
	var v []TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionInterfaceToEventsFindMany) ExecInner(ctx context.Context) (
	[]InnerTransitionInterface,
	error,
) {
	var v []InnerTransitionInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionInterfaceToEventsFindMany) Update(params ...TransitionInterfaceSetParam) transitionInterfaceToEventsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "TransitionInterface"

	r.query.Outputs = countOutput

	var v transitionInterfaceToEventsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionInterfaceToEventsUpdateMany struct {
	query builder.Query
}

func (r transitionInterfaceToEventsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToEventsUpdateMany) transitionInterfaceModel() {}

func (r transitionInterfaceToEventsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceToEventsUpdateMany) Tx() transitionInterfaceManyTxResult {
	v := NewtransitionInterfaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionInterfaceToEventsFindMany) Delete() transitionInterfaceToEventsDeleteMany {
	var v transitionInterfaceToEventsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "TransitionInterface"

	v.query.Outputs = countOutput

	return v
}

type transitionInterfaceToEventsDeleteMany struct {
	query builder.Query
}

func (r transitionInterfaceToEventsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionInterfaceToEventsDeleteMany) transitionInterfaceModel() {}

func (r transitionInterfaceToEventsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceToEventsDeleteMany) Tx() transitionInterfaceManyTxResult {
	v := NewtransitionInterfaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionInterfaceToTransitionsFindUnique struct {
	query builder.Query
}

func (r transitionInterfaceToTransitionsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToTransitionsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToTransitionsFindUnique) with()                        {}
func (r transitionInterfaceToTransitionsFindUnique) transitionInterfaceModel()    {}
func (r transitionInterfaceToTransitionsFindUnique) transitionInterfaceRelation() {}

func (r transitionInterfaceToTransitionsFindUnique) With(params ...TransitionRelationWith) transitionInterfaceToTransitionsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionInterfaceToTransitionsFindUnique) Exec(ctx context.Context) (
	*TransitionInterfaceModel,
	error,
) {
	var v *TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionInterfaceToTransitionsFindUnique) ExecInner(ctx context.Context) (
	*InnerTransitionInterface,
	error,
) {
	var v *InnerTransitionInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionInterfaceToTransitionsFindUnique) Update(params ...TransitionInterfaceSetParam) transitionInterfaceToTransitionsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "TransitionInterface"

	var v transitionInterfaceToTransitionsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionInterfaceToTransitionsUpdateUnique struct {
	query builder.Query
}

func (r transitionInterfaceToTransitionsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToTransitionsUpdateUnique) transitionInterfaceModel() {}

func (r transitionInterfaceToTransitionsUpdateUnique) Exec(ctx context.Context) (*TransitionInterfaceModel, error) {
	var v TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceToTransitionsUpdateUnique) Tx() transitionInterfaceUniqueTxResult {
	v := NewtransitionInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionInterfaceToTransitionsFindUnique) Delete() transitionInterfaceToTransitionsDeleteUnique {
	var v transitionInterfaceToTransitionsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "TransitionInterface"

	return v
}

type transitionInterfaceToTransitionsDeleteUnique struct {
	query builder.Query
}

func (r transitionInterfaceToTransitionsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionInterfaceToTransitionsDeleteUnique) transitionInterfaceModel() {}

func (r transitionInterfaceToTransitionsDeleteUnique) Exec(ctx context.Context) (*TransitionInterfaceModel, error) {
	var v TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceToTransitionsDeleteUnique) Tx() transitionInterfaceUniqueTxResult {
	v := NewtransitionInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionInterfaceToTransitionsFindFirst struct {
	query builder.Query
}

func (r transitionInterfaceToTransitionsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToTransitionsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToTransitionsFindFirst) with()                        {}
func (r transitionInterfaceToTransitionsFindFirst) transitionInterfaceModel()    {}
func (r transitionInterfaceToTransitionsFindFirst) transitionInterfaceRelation() {}

func (r transitionInterfaceToTransitionsFindFirst) With(params ...TransitionRelationWith) transitionInterfaceToTransitionsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionInterfaceToTransitionsFindFirst) OrderBy(params ...TransitionOrderByParam) transitionInterfaceToTransitionsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionInterfaceToTransitionsFindFirst) Skip(count int) transitionInterfaceToTransitionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionInterfaceToTransitionsFindFirst) Take(count int) transitionInterfaceToTransitionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionInterfaceToTransitionsFindFirst) Cursor(cursor TransitionInterfaceCursorParam) transitionInterfaceToTransitionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionInterfaceToTransitionsFindFirst) Exec(ctx context.Context) (
	*TransitionInterfaceModel,
	error,
) {
	var v *TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionInterfaceToTransitionsFindFirst) ExecInner(ctx context.Context) (
	*InnerTransitionInterface,
	error,
) {
	var v *InnerTransitionInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transitionInterfaceToTransitionsFindMany struct {
	query builder.Query
}

func (r transitionInterfaceToTransitionsFindMany) getQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToTransitionsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToTransitionsFindMany) with()                        {}
func (r transitionInterfaceToTransitionsFindMany) transitionInterfaceModel()    {}
func (r transitionInterfaceToTransitionsFindMany) transitionInterfaceRelation() {}

func (r transitionInterfaceToTransitionsFindMany) With(params ...TransitionRelationWith) transitionInterfaceToTransitionsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionInterfaceToTransitionsFindMany) OrderBy(params ...TransitionOrderByParam) transitionInterfaceToTransitionsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionInterfaceToTransitionsFindMany) Skip(count int) transitionInterfaceToTransitionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionInterfaceToTransitionsFindMany) Take(count int) transitionInterfaceToTransitionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionInterfaceToTransitionsFindMany) Cursor(cursor TransitionInterfaceCursorParam) transitionInterfaceToTransitionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionInterfaceToTransitionsFindMany) Exec(ctx context.Context) (
	[]TransitionInterfaceModel,
	error,
) {
	var v []TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionInterfaceToTransitionsFindMany) ExecInner(ctx context.Context) (
	[]InnerTransitionInterface,
	error,
) {
	var v []InnerTransitionInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionInterfaceToTransitionsFindMany) Update(params ...TransitionInterfaceSetParam) transitionInterfaceToTransitionsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "TransitionInterface"

	r.query.Outputs = countOutput

	var v transitionInterfaceToTransitionsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionInterfaceToTransitionsUpdateMany struct {
	query builder.Query
}

func (r transitionInterfaceToTransitionsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceToTransitionsUpdateMany) transitionInterfaceModel() {}

func (r transitionInterfaceToTransitionsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceToTransitionsUpdateMany) Tx() transitionInterfaceManyTxResult {
	v := NewtransitionInterfaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionInterfaceToTransitionsFindMany) Delete() transitionInterfaceToTransitionsDeleteMany {
	var v transitionInterfaceToTransitionsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "TransitionInterface"

	v.query.Outputs = countOutput

	return v
}

type transitionInterfaceToTransitionsDeleteMany struct {
	query builder.Query
}

func (r transitionInterfaceToTransitionsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionInterfaceToTransitionsDeleteMany) transitionInterfaceModel() {}

func (r transitionInterfaceToTransitionsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceToTransitionsDeleteMany) Tx() transitionInterfaceManyTxResult {
	v := NewtransitionInterfaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionInterfaceFindUnique struct {
	query builder.Query
}

func (r transitionInterfaceFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceFindUnique) with()                        {}
func (r transitionInterfaceFindUnique) transitionInterfaceModel()    {}
func (r transitionInterfaceFindUnique) transitionInterfaceRelation() {}

func (r transitionInterfaceActions) FindUnique(
	params TransitionInterfaceEqualsUniqueWhereParam,
) transitionInterfaceFindUnique {
	var v transitionInterfaceFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "TransitionInterface"
	v.query.Outputs = transitionInterfaceOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r transitionInterfaceFindUnique) With(params ...TransitionInterfaceRelationWith) transitionInterfaceFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionInterfaceFindUnique) Exec(ctx context.Context) (
	*TransitionInterfaceModel,
	error,
) {
	var v *TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionInterfaceFindUnique) ExecInner(ctx context.Context) (
	*InnerTransitionInterface,
	error,
) {
	var v *InnerTransitionInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionInterfaceFindUnique) Update(params ...TransitionInterfaceSetParam) transitionInterfaceUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "TransitionInterface"

	var v transitionInterfaceUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionInterfaceUpdateUnique struct {
	query builder.Query
}

func (r transitionInterfaceUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceUpdateUnique) transitionInterfaceModel() {}

func (r transitionInterfaceUpdateUnique) Exec(ctx context.Context) (*TransitionInterfaceModel, error) {
	var v TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceUpdateUnique) Tx() transitionInterfaceUniqueTxResult {
	v := NewtransitionInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionInterfaceFindUnique) Delete() transitionInterfaceDeleteUnique {
	var v transitionInterfaceDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "TransitionInterface"

	return v
}

type transitionInterfaceDeleteUnique struct {
	query builder.Query
}

func (r transitionInterfaceDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionInterfaceDeleteUnique) transitionInterfaceModel() {}

func (r transitionInterfaceDeleteUnique) Exec(ctx context.Context) (*TransitionInterfaceModel, error) {
	var v TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceDeleteUnique) Tx() transitionInterfaceUniqueTxResult {
	v := NewtransitionInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionInterfaceFindFirst struct {
	query builder.Query
}

func (r transitionInterfaceFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceFindFirst) with()                        {}
func (r transitionInterfaceFindFirst) transitionInterfaceModel()    {}
func (r transitionInterfaceFindFirst) transitionInterfaceRelation() {}

func (r transitionInterfaceActions) FindFirst(
	params ...TransitionInterfaceWhereParam,
) transitionInterfaceFindFirst {
	var v transitionInterfaceFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "TransitionInterface"
	v.query.Outputs = transitionInterfaceOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transitionInterfaceFindFirst) With(params ...TransitionInterfaceRelationWith) transitionInterfaceFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionInterfaceFindFirst) OrderBy(params ...TransitionInterfaceOrderByParam) transitionInterfaceFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionInterfaceFindFirst) Skip(count int) transitionInterfaceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionInterfaceFindFirst) Take(count int) transitionInterfaceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionInterfaceFindFirst) Cursor(cursor TransitionInterfaceCursorParam) transitionInterfaceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionInterfaceFindFirst) Exec(ctx context.Context) (
	*TransitionInterfaceModel,
	error,
) {
	var v *TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionInterfaceFindFirst) ExecInner(ctx context.Context) (
	*InnerTransitionInterface,
	error,
) {
	var v *InnerTransitionInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transitionInterfaceFindMany struct {
	query builder.Query
}

func (r transitionInterfaceFindMany) getQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceFindMany) with()                        {}
func (r transitionInterfaceFindMany) transitionInterfaceModel()    {}
func (r transitionInterfaceFindMany) transitionInterfaceRelation() {}

func (r transitionInterfaceActions) FindMany(
	params ...TransitionInterfaceWhereParam,
) transitionInterfaceFindMany {
	var v transitionInterfaceFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "TransitionInterface"
	v.query.Outputs = transitionInterfaceOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transitionInterfaceFindMany) With(params ...TransitionInterfaceRelationWith) transitionInterfaceFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionInterfaceFindMany) OrderBy(params ...TransitionInterfaceOrderByParam) transitionInterfaceFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionInterfaceFindMany) Skip(count int) transitionInterfaceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionInterfaceFindMany) Take(count int) transitionInterfaceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionInterfaceFindMany) Cursor(cursor TransitionInterfaceCursorParam) transitionInterfaceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionInterfaceFindMany) Exec(ctx context.Context) (
	[]TransitionInterfaceModel,
	error,
) {
	var v []TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionInterfaceFindMany) ExecInner(ctx context.Context) (
	[]InnerTransitionInterface,
	error,
) {
	var v []InnerTransitionInterface
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionInterfaceFindMany) Update(params ...TransitionInterfaceSetParam) transitionInterfaceUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "TransitionInterface"

	r.query.Outputs = countOutput

	var v transitionInterfaceUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionInterfaceUpdateMany struct {
	query builder.Query
}

func (r transitionInterfaceUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceUpdateMany) transitionInterfaceModel() {}

func (r transitionInterfaceUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceUpdateMany) Tx() transitionInterfaceManyTxResult {
	v := NewtransitionInterfaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionInterfaceFindMany) Delete() transitionInterfaceDeleteMany {
	var v transitionInterfaceDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "TransitionInterface"

	v.query.Outputs = countOutput

	return v
}

type transitionInterfaceDeleteMany struct {
	query builder.Query
}

func (r transitionInterfaceDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionInterfaceDeleteMany) transitionInterfaceModel() {}

func (r transitionInterfaceDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceDeleteMany) Tx() transitionInterfaceManyTxResult {
	v := NewtransitionInterfaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type placeToArcsFindUnique struct {
	query builder.Query
}

func (r placeToArcsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r placeToArcsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r placeToArcsFindUnique) with()          {}
func (r placeToArcsFindUnique) placeModel()    {}
func (r placeToArcsFindUnique) placeRelation() {}

func (r placeToArcsFindUnique) With(params ...ArcRelationWith) placeToArcsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeToArcsFindUnique) Exec(ctx context.Context) (
	*PlaceModel,
	error,
) {
	var v *PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeToArcsFindUnique) ExecInner(ctx context.Context) (
	*InnerPlace,
	error,
) {
	var v *InnerPlace
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeToArcsFindUnique) Update(params ...PlaceSetParam) placeToArcsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Place"

	var v placeToArcsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type placeToArcsUpdateUnique struct {
	query builder.Query
}

func (r placeToArcsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r placeToArcsUpdateUnique) placeModel() {}

func (r placeToArcsUpdateUnique) Exec(ctx context.Context) (*PlaceModel, error) {
	var v PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeToArcsUpdateUnique) Tx() placeUniqueTxResult {
	v := NewplaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r placeToArcsFindUnique) Delete() placeToArcsDeleteUnique {
	var v placeToArcsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Place"

	return v
}

type placeToArcsDeleteUnique struct {
	query builder.Query
}

func (r placeToArcsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p placeToArcsDeleteUnique) placeModel() {}

func (r placeToArcsDeleteUnique) Exec(ctx context.Context) (*PlaceModel, error) {
	var v PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeToArcsDeleteUnique) Tx() placeUniqueTxResult {
	v := NewplaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type placeToArcsFindFirst struct {
	query builder.Query
}

func (r placeToArcsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r placeToArcsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r placeToArcsFindFirst) with()          {}
func (r placeToArcsFindFirst) placeModel()    {}
func (r placeToArcsFindFirst) placeRelation() {}

func (r placeToArcsFindFirst) With(params ...ArcRelationWith) placeToArcsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeToArcsFindFirst) OrderBy(params ...ArcOrderByParam) placeToArcsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r placeToArcsFindFirst) Skip(count int) placeToArcsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r placeToArcsFindFirst) Take(count int) placeToArcsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r placeToArcsFindFirst) Cursor(cursor PlaceCursorParam) placeToArcsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r placeToArcsFindFirst) Exec(ctx context.Context) (
	*PlaceModel,
	error,
) {
	var v *PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeToArcsFindFirst) ExecInner(ctx context.Context) (
	*InnerPlace,
	error,
) {
	var v *InnerPlace
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type placeToArcsFindMany struct {
	query builder.Query
}

func (r placeToArcsFindMany) getQuery() builder.Query {
	return r.query
}

func (r placeToArcsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r placeToArcsFindMany) with()          {}
func (r placeToArcsFindMany) placeModel()    {}
func (r placeToArcsFindMany) placeRelation() {}

func (r placeToArcsFindMany) With(params ...ArcRelationWith) placeToArcsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeToArcsFindMany) OrderBy(params ...ArcOrderByParam) placeToArcsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r placeToArcsFindMany) Skip(count int) placeToArcsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r placeToArcsFindMany) Take(count int) placeToArcsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r placeToArcsFindMany) Cursor(cursor PlaceCursorParam) placeToArcsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r placeToArcsFindMany) Exec(ctx context.Context) (
	[]PlaceModel,
	error,
) {
	var v []PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r placeToArcsFindMany) ExecInner(ctx context.Context) (
	[]InnerPlace,
	error,
) {
	var v []InnerPlace
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r placeToArcsFindMany) Update(params ...PlaceSetParam) placeToArcsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Place"

	r.query.Outputs = countOutput

	var v placeToArcsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type placeToArcsUpdateMany struct {
	query builder.Query
}

func (r placeToArcsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r placeToArcsUpdateMany) placeModel() {}

func (r placeToArcsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeToArcsUpdateMany) Tx() placeManyTxResult {
	v := NewplaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r placeToArcsFindMany) Delete() placeToArcsDeleteMany {
	var v placeToArcsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Place"

	v.query.Outputs = countOutput

	return v
}

type placeToArcsDeleteMany struct {
	query builder.Query
}

func (r placeToArcsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p placeToArcsDeleteMany) placeModel() {}

func (r placeToArcsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeToArcsDeleteMany) Tx() placeManyTxResult {
	v := NewplaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type placeToNetsFindUnique struct {
	query builder.Query
}

func (r placeToNetsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r placeToNetsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r placeToNetsFindUnique) with()          {}
func (r placeToNetsFindUnique) placeModel()    {}
func (r placeToNetsFindUnique) placeRelation() {}

func (r placeToNetsFindUnique) With(params ...NetRelationWith) placeToNetsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeToNetsFindUnique) Exec(ctx context.Context) (
	*PlaceModel,
	error,
) {
	var v *PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeToNetsFindUnique) ExecInner(ctx context.Context) (
	*InnerPlace,
	error,
) {
	var v *InnerPlace
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeToNetsFindUnique) Update(params ...PlaceSetParam) placeToNetsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Place"

	var v placeToNetsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type placeToNetsUpdateUnique struct {
	query builder.Query
}

func (r placeToNetsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r placeToNetsUpdateUnique) placeModel() {}

func (r placeToNetsUpdateUnique) Exec(ctx context.Context) (*PlaceModel, error) {
	var v PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeToNetsUpdateUnique) Tx() placeUniqueTxResult {
	v := NewplaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r placeToNetsFindUnique) Delete() placeToNetsDeleteUnique {
	var v placeToNetsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Place"

	return v
}

type placeToNetsDeleteUnique struct {
	query builder.Query
}

func (r placeToNetsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p placeToNetsDeleteUnique) placeModel() {}

func (r placeToNetsDeleteUnique) Exec(ctx context.Context) (*PlaceModel, error) {
	var v PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeToNetsDeleteUnique) Tx() placeUniqueTxResult {
	v := NewplaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type placeToNetsFindFirst struct {
	query builder.Query
}

func (r placeToNetsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r placeToNetsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r placeToNetsFindFirst) with()          {}
func (r placeToNetsFindFirst) placeModel()    {}
func (r placeToNetsFindFirst) placeRelation() {}

func (r placeToNetsFindFirst) With(params ...NetRelationWith) placeToNetsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeToNetsFindFirst) OrderBy(params ...NetOrderByParam) placeToNetsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r placeToNetsFindFirst) Skip(count int) placeToNetsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r placeToNetsFindFirst) Take(count int) placeToNetsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r placeToNetsFindFirst) Cursor(cursor PlaceCursorParam) placeToNetsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r placeToNetsFindFirst) Exec(ctx context.Context) (
	*PlaceModel,
	error,
) {
	var v *PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeToNetsFindFirst) ExecInner(ctx context.Context) (
	*InnerPlace,
	error,
) {
	var v *InnerPlace
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type placeToNetsFindMany struct {
	query builder.Query
}

func (r placeToNetsFindMany) getQuery() builder.Query {
	return r.query
}

func (r placeToNetsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r placeToNetsFindMany) with()          {}
func (r placeToNetsFindMany) placeModel()    {}
func (r placeToNetsFindMany) placeRelation() {}

func (r placeToNetsFindMany) With(params ...NetRelationWith) placeToNetsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeToNetsFindMany) OrderBy(params ...NetOrderByParam) placeToNetsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r placeToNetsFindMany) Skip(count int) placeToNetsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r placeToNetsFindMany) Take(count int) placeToNetsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r placeToNetsFindMany) Cursor(cursor PlaceCursorParam) placeToNetsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r placeToNetsFindMany) Exec(ctx context.Context) (
	[]PlaceModel,
	error,
) {
	var v []PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r placeToNetsFindMany) ExecInner(ctx context.Context) (
	[]InnerPlace,
	error,
) {
	var v []InnerPlace
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r placeToNetsFindMany) Update(params ...PlaceSetParam) placeToNetsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Place"

	r.query.Outputs = countOutput

	var v placeToNetsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type placeToNetsUpdateMany struct {
	query builder.Query
}

func (r placeToNetsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r placeToNetsUpdateMany) placeModel() {}

func (r placeToNetsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeToNetsUpdateMany) Tx() placeManyTxResult {
	v := NewplaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r placeToNetsFindMany) Delete() placeToNetsDeleteMany {
	var v placeToNetsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Place"

	v.query.Outputs = countOutput

	return v
}

type placeToNetsDeleteMany struct {
	query builder.Query
}

func (r placeToNetsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p placeToNetsDeleteMany) placeModel() {}

func (r placeToNetsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeToNetsDeleteMany) Tx() placeManyTxResult {
	v := NewplaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type placeToInterfacesFindUnique struct {
	query builder.Query
}

func (r placeToInterfacesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r placeToInterfacesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r placeToInterfacesFindUnique) with()          {}
func (r placeToInterfacesFindUnique) placeModel()    {}
func (r placeToInterfacesFindUnique) placeRelation() {}

func (r placeToInterfacesFindUnique) With(params ...PlaceInterfaceRelationWith) placeToInterfacesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeToInterfacesFindUnique) Exec(ctx context.Context) (
	*PlaceModel,
	error,
) {
	var v *PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeToInterfacesFindUnique) ExecInner(ctx context.Context) (
	*InnerPlace,
	error,
) {
	var v *InnerPlace
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeToInterfacesFindUnique) Update(params ...PlaceSetParam) placeToInterfacesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Place"

	var v placeToInterfacesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type placeToInterfacesUpdateUnique struct {
	query builder.Query
}

func (r placeToInterfacesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r placeToInterfacesUpdateUnique) placeModel() {}

func (r placeToInterfacesUpdateUnique) Exec(ctx context.Context) (*PlaceModel, error) {
	var v PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeToInterfacesUpdateUnique) Tx() placeUniqueTxResult {
	v := NewplaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r placeToInterfacesFindUnique) Delete() placeToInterfacesDeleteUnique {
	var v placeToInterfacesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Place"

	return v
}

type placeToInterfacesDeleteUnique struct {
	query builder.Query
}

func (r placeToInterfacesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p placeToInterfacesDeleteUnique) placeModel() {}

func (r placeToInterfacesDeleteUnique) Exec(ctx context.Context) (*PlaceModel, error) {
	var v PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeToInterfacesDeleteUnique) Tx() placeUniqueTxResult {
	v := NewplaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type placeToInterfacesFindFirst struct {
	query builder.Query
}

func (r placeToInterfacesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r placeToInterfacesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r placeToInterfacesFindFirst) with()          {}
func (r placeToInterfacesFindFirst) placeModel()    {}
func (r placeToInterfacesFindFirst) placeRelation() {}

func (r placeToInterfacesFindFirst) With(params ...PlaceInterfaceRelationWith) placeToInterfacesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeToInterfacesFindFirst) OrderBy(params ...PlaceInterfaceOrderByParam) placeToInterfacesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r placeToInterfacesFindFirst) Skip(count int) placeToInterfacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r placeToInterfacesFindFirst) Take(count int) placeToInterfacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r placeToInterfacesFindFirst) Cursor(cursor PlaceCursorParam) placeToInterfacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r placeToInterfacesFindFirst) Exec(ctx context.Context) (
	*PlaceModel,
	error,
) {
	var v *PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeToInterfacesFindFirst) ExecInner(ctx context.Context) (
	*InnerPlace,
	error,
) {
	var v *InnerPlace
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type placeToInterfacesFindMany struct {
	query builder.Query
}

func (r placeToInterfacesFindMany) getQuery() builder.Query {
	return r.query
}

func (r placeToInterfacesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r placeToInterfacesFindMany) with()          {}
func (r placeToInterfacesFindMany) placeModel()    {}
func (r placeToInterfacesFindMany) placeRelation() {}

func (r placeToInterfacesFindMany) With(params ...PlaceInterfaceRelationWith) placeToInterfacesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeToInterfacesFindMany) OrderBy(params ...PlaceInterfaceOrderByParam) placeToInterfacesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r placeToInterfacesFindMany) Skip(count int) placeToInterfacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r placeToInterfacesFindMany) Take(count int) placeToInterfacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r placeToInterfacesFindMany) Cursor(cursor PlaceCursorParam) placeToInterfacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r placeToInterfacesFindMany) Exec(ctx context.Context) (
	[]PlaceModel,
	error,
) {
	var v []PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r placeToInterfacesFindMany) ExecInner(ctx context.Context) (
	[]InnerPlace,
	error,
) {
	var v []InnerPlace
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r placeToInterfacesFindMany) Update(params ...PlaceSetParam) placeToInterfacesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Place"

	r.query.Outputs = countOutput

	var v placeToInterfacesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type placeToInterfacesUpdateMany struct {
	query builder.Query
}

func (r placeToInterfacesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r placeToInterfacesUpdateMany) placeModel() {}

func (r placeToInterfacesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeToInterfacesUpdateMany) Tx() placeManyTxResult {
	v := NewplaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r placeToInterfacesFindMany) Delete() placeToInterfacesDeleteMany {
	var v placeToInterfacesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Place"

	v.query.Outputs = countOutput

	return v
}

type placeToInterfacesDeleteMany struct {
	query builder.Query
}

func (r placeToInterfacesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p placeToInterfacesDeleteMany) placeModel() {}

func (r placeToInterfacesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeToInterfacesDeleteMany) Tx() placeManyTxResult {
	v := NewplaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type placeFindUnique struct {
	query builder.Query
}

func (r placeFindUnique) getQuery() builder.Query {
	return r.query
}

func (r placeFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r placeFindUnique) with()          {}
func (r placeFindUnique) placeModel()    {}
func (r placeFindUnique) placeRelation() {}

func (r placeActions) FindUnique(
	params PlaceEqualsUniqueWhereParam,
) placeFindUnique {
	var v placeFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Place"
	v.query.Outputs = placeOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r placeFindUnique) With(params ...PlaceRelationWith) placeFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeFindUnique) Exec(ctx context.Context) (
	*PlaceModel,
	error,
) {
	var v *PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeFindUnique) ExecInner(ctx context.Context) (
	*InnerPlace,
	error,
) {
	var v *InnerPlace
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeFindUnique) Update(params ...PlaceSetParam) placeUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Place"

	var v placeUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type placeUpdateUnique struct {
	query builder.Query
}

func (r placeUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r placeUpdateUnique) placeModel() {}

func (r placeUpdateUnique) Exec(ctx context.Context) (*PlaceModel, error) {
	var v PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeUpdateUnique) Tx() placeUniqueTxResult {
	v := NewplaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r placeFindUnique) Delete() placeDeleteUnique {
	var v placeDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Place"

	return v
}

type placeDeleteUnique struct {
	query builder.Query
}

func (r placeDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p placeDeleteUnique) placeModel() {}

func (r placeDeleteUnique) Exec(ctx context.Context) (*PlaceModel, error) {
	var v PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeDeleteUnique) Tx() placeUniqueTxResult {
	v := NewplaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type placeFindFirst struct {
	query builder.Query
}

func (r placeFindFirst) getQuery() builder.Query {
	return r.query
}

func (r placeFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r placeFindFirst) with()          {}
func (r placeFindFirst) placeModel()    {}
func (r placeFindFirst) placeRelation() {}

func (r placeActions) FindFirst(
	params ...PlaceWhereParam,
) placeFindFirst {
	var v placeFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Place"
	v.query.Outputs = placeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r placeFindFirst) With(params ...PlaceRelationWith) placeFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeFindFirst) OrderBy(params ...PlaceOrderByParam) placeFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r placeFindFirst) Skip(count int) placeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r placeFindFirst) Take(count int) placeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r placeFindFirst) Cursor(cursor PlaceCursorParam) placeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r placeFindFirst) Exec(ctx context.Context) (
	*PlaceModel,
	error,
) {
	var v *PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r placeFindFirst) ExecInner(ctx context.Context) (
	*InnerPlace,
	error,
) {
	var v *InnerPlace
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type placeFindMany struct {
	query builder.Query
}

func (r placeFindMany) getQuery() builder.Query {
	return r.query
}

func (r placeFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r placeFindMany) with()          {}
func (r placeFindMany) placeModel()    {}
func (r placeFindMany) placeRelation() {}

func (r placeActions) FindMany(
	params ...PlaceWhereParam,
) placeFindMany {
	var v placeFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Place"
	v.query.Outputs = placeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r placeFindMany) With(params ...PlaceRelationWith) placeFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r placeFindMany) OrderBy(params ...PlaceOrderByParam) placeFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r placeFindMany) Skip(count int) placeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r placeFindMany) Take(count int) placeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r placeFindMany) Cursor(cursor PlaceCursorParam) placeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r placeFindMany) Exec(ctx context.Context) (
	[]PlaceModel,
	error,
) {
	var v []PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r placeFindMany) ExecInner(ctx context.Context) (
	[]InnerPlace,
	error,
) {
	var v []InnerPlace
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r placeFindMany) Update(params ...PlaceSetParam) placeUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Place"

	r.query.Outputs = countOutput

	var v placeUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type placeUpdateMany struct {
	query builder.Query
}

func (r placeUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r placeUpdateMany) placeModel() {}

func (r placeUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeUpdateMany) Tx() placeManyTxResult {
	v := NewplaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r placeFindMany) Delete() placeDeleteMany {
	var v placeDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Place"

	v.query.Outputs = countOutput

	return v
}

type placeDeleteMany struct {
	query builder.Query
}

func (r placeDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p placeDeleteMany) placeModel() {}

func (r placeDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeDeleteMany) Tx() placeManyTxResult {
	v := NewplaceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionToArcsFindUnique struct {
	query builder.Query
}

func (r transitionToArcsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transitionToArcsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToArcsFindUnique) with()               {}
func (r transitionToArcsFindUnique) transitionModel()    {}
func (r transitionToArcsFindUnique) transitionRelation() {}

func (r transitionToArcsFindUnique) With(params ...ArcRelationWith) transitionToArcsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionToArcsFindUnique) Exec(ctx context.Context) (
	*TransitionModel,
	error,
) {
	var v *TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionToArcsFindUnique) ExecInner(ctx context.Context) (
	*InnerTransition,
	error,
) {
	var v *InnerTransition
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionToArcsFindUnique) Update(params ...TransitionSetParam) transitionToArcsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Transition"

	var v transitionToArcsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionToArcsUpdateUnique struct {
	query builder.Query
}

func (r transitionToArcsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToArcsUpdateUnique) transitionModel() {}

func (r transitionToArcsUpdateUnique) Exec(ctx context.Context) (*TransitionModel, error) {
	var v TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionToArcsUpdateUnique) Tx() transitionUniqueTxResult {
	v := NewtransitionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionToArcsFindUnique) Delete() transitionToArcsDeleteUnique {
	var v transitionToArcsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Transition"

	return v
}

type transitionToArcsDeleteUnique struct {
	query builder.Query
}

func (r transitionToArcsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionToArcsDeleteUnique) transitionModel() {}

func (r transitionToArcsDeleteUnique) Exec(ctx context.Context) (*TransitionModel, error) {
	var v TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionToArcsDeleteUnique) Tx() transitionUniqueTxResult {
	v := NewtransitionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionToArcsFindFirst struct {
	query builder.Query
}

func (r transitionToArcsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transitionToArcsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToArcsFindFirst) with()               {}
func (r transitionToArcsFindFirst) transitionModel()    {}
func (r transitionToArcsFindFirst) transitionRelation() {}

func (r transitionToArcsFindFirst) With(params ...ArcRelationWith) transitionToArcsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionToArcsFindFirst) OrderBy(params ...ArcOrderByParam) transitionToArcsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionToArcsFindFirst) Skip(count int) transitionToArcsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionToArcsFindFirst) Take(count int) transitionToArcsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionToArcsFindFirst) Cursor(cursor TransitionCursorParam) transitionToArcsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionToArcsFindFirst) Exec(ctx context.Context) (
	*TransitionModel,
	error,
) {
	var v *TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionToArcsFindFirst) ExecInner(ctx context.Context) (
	*InnerTransition,
	error,
) {
	var v *InnerTransition
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transitionToArcsFindMany struct {
	query builder.Query
}

func (r transitionToArcsFindMany) getQuery() builder.Query {
	return r.query
}

func (r transitionToArcsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToArcsFindMany) with()               {}
func (r transitionToArcsFindMany) transitionModel()    {}
func (r transitionToArcsFindMany) transitionRelation() {}

func (r transitionToArcsFindMany) With(params ...ArcRelationWith) transitionToArcsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionToArcsFindMany) OrderBy(params ...ArcOrderByParam) transitionToArcsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionToArcsFindMany) Skip(count int) transitionToArcsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionToArcsFindMany) Take(count int) transitionToArcsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionToArcsFindMany) Cursor(cursor TransitionCursorParam) transitionToArcsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionToArcsFindMany) Exec(ctx context.Context) (
	[]TransitionModel,
	error,
) {
	var v []TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionToArcsFindMany) ExecInner(ctx context.Context) (
	[]InnerTransition,
	error,
) {
	var v []InnerTransition
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionToArcsFindMany) Update(params ...TransitionSetParam) transitionToArcsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Transition"

	r.query.Outputs = countOutput

	var v transitionToArcsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionToArcsUpdateMany struct {
	query builder.Query
}

func (r transitionToArcsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToArcsUpdateMany) transitionModel() {}

func (r transitionToArcsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionToArcsUpdateMany) Tx() transitionManyTxResult {
	v := NewtransitionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionToArcsFindMany) Delete() transitionToArcsDeleteMany {
	var v transitionToArcsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Transition"

	v.query.Outputs = countOutput

	return v
}

type transitionToArcsDeleteMany struct {
	query builder.Query
}

func (r transitionToArcsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionToArcsDeleteMany) transitionModel() {}

func (r transitionToArcsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionToArcsDeleteMany) Tx() transitionManyTxResult {
	v := NewtransitionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionToEventsFindUnique struct {
	query builder.Query
}

func (r transitionToEventsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transitionToEventsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToEventsFindUnique) with()               {}
func (r transitionToEventsFindUnique) transitionModel()    {}
func (r transitionToEventsFindUnique) transitionRelation() {}

func (r transitionToEventsFindUnique) With(params ...EventRelationWith) transitionToEventsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionToEventsFindUnique) Exec(ctx context.Context) (
	*TransitionModel,
	error,
) {
	var v *TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionToEventsFindUnique) ExecInner(ctx context.Context) (
	*InnerTransition,
	error,
) {
	var v *InnerTransition
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionToEventsFindUnique) Update(params ...TransitionSetParam) transitionToEventsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Transition"

	var v transitionToEventsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionToEventsUpdateUnique struct {
	query builder.Query
}

func (r transitionToEventsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToEventsUpdateUnique) transitionModel() {}

func (r transitionToEventsUpdateUnique) Exec(ctx context.Context) (*TransitionModel, error) {
	var v TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionToEventsUpdateUnique) Tx() transitionUniqueTxResult {
	v := NewtransitionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionToEventsFindUnique) Delete() transitionToEventsDeleteUnique {
	var v transitionToEventsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Transition"

	return v
}

type transitionToEventsDeleteUnique struct {
	query builder.Query
}

func (r transitionToEventsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionToEventsDeleteUnique) transitionModel() {}

func (r transitionToEventsDeleteUnique) Exec(ctx context.Context) (*TransitionModel, error) {
	var v TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionToEventsDeleteUnique) Tx() transitionUniqueTxResult {
	v := NewtransitionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionToEventsFindFirst struct {
	query builder.Query
}

func (r transitionToEventsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transitionToEventsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToEventsFindFirst) with()               {}
func (r transitionToEventsFindFirst) transitionModel()    {}
func (r transitionToEventsFindFirst) transitionRelation() {}

func (r transitionToEventsFindFirst) With(params ...EventRelationWith) transitionToEventsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionToEventsFindFirst) OrderBy(params ...EventOrderByParam) transitionToEventsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionToEventsFindFirst) Skip(count int) transitionToEventsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionToEventsFindFirst) Take(count int) transitionToEventsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionToEventsFindFirst) Cursor(cursor TransitionCursorParam) transitionToEventsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionToEventsFindFirst) Exec(ctx context.Context) (
	*TransitionModel,
	error,
) {
	var v *TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionToEventsFindFirst) ExecInner(ctx context.Context) (
	*InnerTransition,
	error,
) {
	var v *InnerTransition
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transitionToEventsFindMany struct {
	query builder.Query
}

func (r transitionToEventsFindMany) getQuery() builder.Query {
	return r.query
}

func (r transitionToEventsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToEventsFindMany) with()               {}
func (r transitionToEventsFindMany) transitionModel()    {}
func (r transitionToEventsFindMany) transitionRelation() {}

func (r transitionToEventsFindMany) With(params ...EventRelationWith) transitionToEventsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionToEventsFindMany) OrderBy(params ...EventOrderByParam) transitionToEventsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionToEventsFindMany) Skip(count int) transitionToEventsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionToEventsFindMany) Take(count int) transitionToEventsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionToEventsFindMany) Cursor(cursor TransitionCursorParam) transitionToEventsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionToEventsFindMany) Exec(ctx context.Context) (
	[]TransitionModel,
	error,
) {
	var v []TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionToEventsFindMany) ExecInner(ctx context.Context) (
	[]InnerTransition,
	error,
) {
	var v []InnerTransition
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionToEventsFindMany) Update(params ...TransitionSetParam) transitionToEventsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Transition"

	r.query.Outputs = countOutput

	var v transitionToEventsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionToEventsUpdateMany struct {
	query builder.Query
}

func (r transitionToEventsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToEventsUpdateMany) transitionModel() {}

func (r transitionToEventsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionToEventsUpdateMany) Tx() transitionManyTxResult {
	v := NewtransitionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionToEventsFindMany) Delete() transitionToEventsDeleteMany {
	var v transitionToEventsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Transition"

	v.query.Outputs = countOutput

	return v
}

type transitionToEventsDeleteMany struct {
	query builder.Query
}

func (r transitionToEventsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionToEventsDeleteMany) transitionModel() {}

func (r transitionToEventsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionToEventsDeleteMany) Tx() transitionManyTxResult {
	v := NewtransitionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionToNetsFindUnique struct {
	query builder.Query
}

func (r transitionToNetsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transitionToNetsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToNetsFindUnique) with()               {}
func (r transitionToNetsFindUnique) transitionModel()    {}
func (r transitionToNetsFindUnique) transitionRelation() {}

func (r transitionToNetsFindUnique) With(params ...NetRelationWith) transitionToNetsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionToNetsFindUnique) Exec(ctx context.Context) (
	*TransitionModel,
	error,
) {
	var v *TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionToNetsFindUnique) ExecInner(ctx context.Context) (
	*InnerTransition,
	error,
) {
	var v *InnerTransition
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionToNetsFindUnique) Update(params ...TransitionSetParam) transitionToNetsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Transition"

	var v transitionToNetsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionToNetsUpdateUnique struct {
	query builder.Query
}

func (r transitionToNetsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToNetsUpdateUnique) transitionModel() {}

func (r transitionToNetsUpdateUnique) Exec(ctx context.Context) (*TransitionModel, error) {
	var v TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionToNetsUpdateUnique) Tx() transitionUniqueTxResult {
	v := NewtransitionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionToNetsFindUnique) Delete() transitionToNetsDeleteUnique {
	var v transitionToNetsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Transition"

	return v
}

type transitionToNetsDeleteUnique struct {
	query builder.Query
}

func (r transitionToNetsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionToNetsDeleteUnique) transitionModel() {}

func (r transitionToNetsDeleteUnique) Exec(ctx context.Context) (*TransitionModel, error) {
	var v TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionToNetsDeleteUnique) Tx() transitionUniqueTxResult {
	v := NewtransitionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionToNetsFindFirst struct {
	query builder.Query
}

func (r transitionToNetsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transitionToNetsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToNetsFindFirst) with()               {}
func (r transitionToNetsFindFirst) transitionModel()    {}
func (r transitionToNetsFindFirst) transitionRelation() {}

func (r transitionToNetsFindFirst) With(params ...NetRelationWith) transitionToNetsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionToNetsFindFirst) OrderBy(params ...NetOrderByParam) transitionToNetsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionToNetsFindFirst) Skip(count int) transitionToNetsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionToNetsFindFirst) Take(count int) transitionToNetsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionToNetsFindFirst) Cursor(cursor TransitionCursorParam) transitionToNetsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionToNetsFindFirst) Exec(ctx context.Context) (
	*TransitionModel,
	error,
) {
	var v *TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionToNetsFindFirst) ExecInner(ctx context.Context) (
	*InnerTransition,
	error,
) {
	var v *InnerTransition
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transitionToNetsFindMany struct {
	query builder.Query
}

func (r transitionToNetsFindMany) getQuery() builder.Query {
	return r.query
}

func (r transitionToNetsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToNetsFindMany) with()               {}
func (r transitionToNetsFindMany) transitionModel()    {}
func (r transitionToNetsFindMany) transitionRelation() {}

func (r transitionToNetsFindMany) With(params ...NetRelationWith) transitionToNetsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionToNetsFindMany) OrderBy(params ...NetOrderByParam) transitionToNetsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionToNetsFindMany) Skip(count int) transitionToNetsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionToNetsFindMany) Take(count int) transitionToNetsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionToNetsFindMany) Cursor(cursor TransitionCursorParam) transitionToNetsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionToNetsFindMany) Exec(ctx context.Context) (
	[]TransitionModel,
	error,
) {
	var v []TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionToNetsFindMany) ExecInner(ctx context.Context) (
	[]InnerTransition,
	error,
) {
	var v []InnerTransition
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionToNetsFindMany) Update(params ...TransitionSetParam) transitionToNetsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Transition"

	r.query.Outputs = countOutput

	var v transitionToNetsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionToNetsUpdateMany struct {
	query builder.Query
}

func (r transitionToNetsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToNetsUpdateMany) transitionModel() {}

func (r transitionToNetsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionToNetsUpdateMany) Tx() transitionManyTxResult {
	v := NewtransitionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionToNetsFindMany) Delete() transitionToNetsDeleteMany {
	var v transitionToNetsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Transition"

	v.query.Outputs = countOutput

	return v
}

type transitionToNetsDeleteMany struct {
	query builder.Query
}

func (r transitionToNetsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionToNetsDeleteMany) transitionModel() {}

func (r transitionToNetsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionToNetsDeleteMany) Tx() transitionManyTxResult {
	v := NewtransitionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionToInterfacesFindUnique struct {
	query builder.Query
}

func (r transitionToInterfacesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transitionToInterfacesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToInterfacesFindUnique) with()               {}
func (r transitionToInterfacesFindUnique) transitionModel()    {}
func (r transitionToInterfacesFindUnique) transitionRelation() {}

func (r transitionToInterfacesFindUnique) With(params ...TransitionInterfaceRelationWith) transitionToInterfacesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionToInterfacesFindUnique) Exec(ctx context.Context) (
	*TransitionModel,
	error,
) {
	var v *TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionToInterfacesFindUnique) ExecInner(ctx context.Context) (
	*InnerTransition,
	error,
) {
	var v *InnerTransition
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionToInterfacesFindUnique) Update(params ...TransitionSetParam) transitionToInterfacesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Transition"

	var v transitionToInterfacesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionToInterfacesUpdateUnique struct {
	query builder.Query
}

func (r transitionToInterfacesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToInterfacesUpdateUnique) transitionModel() {}

func (r transitionToInterfacesUpdateUnique) Exec(ctx context.Context) (*TransitionModel, error) {
	var v TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionToInterfacesUpdateUnique) Tx() transitionUniqueTxResult {
	v := NewtransitionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionToInterfacesFindUnique) Delete() transitionToInterfacesDeleteUnique {
	var v transitionToInterfacesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Transition"

	return v
}

type transitionToInterfacesDeleteUnique struct {
	query builder.Query
}

func (r transitionToInterfacesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionToInterfacesDeleteUnique) transitionModel() {}

func (r transitionToInterfacesDeleteUnique) Exec(ctx context.Context) (*TransitionModel, error) {
	var v TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionToInterfacesDeleteUnique) Tx() transitionUniqueTxResult {
	v := NewtransitionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionToInterfacesFindFirst struct {
	query builder.Query
}

func (r transitionToInterfacesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transitionToInterfacesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToInterfacesFindFirst) with()               {}
func (r transitionToInterfacesFindFirst) transitionModel()    {}
func (r transitionToInterfacesFindFirst) transitionRelation() {}

func (r transitionToInterfacesFindFirst) With(params ...TransitionInterfaceRelationWith) transitionToInterfacesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionToInterfacesFindFirst) OrderBy(params ...TransitionInterfaceOrderByParam) transitionToInterfacesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionToInterfacesFindFirst) Skip(count int) transitionToInterfacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionToInterfacesFindFirst) Take(count int) transitionToInterfacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionToInterfacesFindFirst) Cursor(cursor TransitionCursorParam) transitionToInterfacesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionToInterfacesFindFirst) Exec(ctx context.Context) (
	*TransitionModel,
	error,
) {
	var v *TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionToInterfacesFindFirst) ExecInner(ctx context.Context) (
	*InnerTransition,
	error,
) {
	var v *InnerTransition
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transitionToInterfacesFindMany struct {
	query builder.Query
}

func (r transitionToInterfacesFindMany) getQuery() builder.Query {
	return r.query
}

func (r transitionToInterfacesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToInterfacesFindMany) with()               {}
func (r transitionToInterfacesFindMany) transitionModel()    {}
func (r transitionToInterfacesFindMany) transitionRelation() {}

func (r transitionToInterfacesFindMany) With(params ...TransitionInterfaceRelationWith) transitionToInterfacesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionToInterfacesFindMany) OrderBy(params ...TransitionInterfaceOrderByParam) transitionToInterfacesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionToInterfacesFindMany) Skip(count int) transitionToInterfacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionToInterfacesFindMany) Take(count int) transitionToInterfacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionToInterfacesFindMany) Cursor(cursor TransitionCursorParam) transitionToInterfacesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionToInterfacesFindMany) Exec(ctx context.Context) (
	[]TransitionModel,
	error,
) {
	var v []TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionToInterfacesFindMany) ExecInner(ctx context.Context) (
	[]InnerTransition,
	error,
) {
	var v []InnerTransition
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionToInterfacesFindMany) Update(params ...TransitionSetParam) transitionToInterfacesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Transition"

	r.query.Outputs = countOutput

	var v transitionToInterfacesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionToInterfacesUpdateMany struct {
	query builder.Query
}

func (r transitionToInterfacesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionToInterfacesUpdateMany) transitionModel() {}

func (r transitionToInterfacesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionToInterfacesUpdateMany) Tx() transitionManyTxResult {
	v := NewtransitionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionToInterfacesFindMany) Delete() transitionToInterfacesDeleteMany {
	var v transitionToInterfacesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Transition"

	v.query.Outputs = countOutput

	return v
}

type transitionToInterfacesDeleteMany struct {
	query builder.Query
}

func (r transitionToInterfacesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionToInterfacesDeleteMany) transitionModel() {}

func (r transitionToInterfacesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionToInterfacesDeleteMany) Tx() transitionManyTxResult {
	v := NewtransitionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionFindUnique struct {
	query builder.Query
}

func (r transitionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transitionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionFindUnique) with()               {}
func (r transitionFindUnique) transitionModel()    {}
func (r transitionFindUnique) transitionRelation() {}

func (r transitionActions) FindUnique(
	params TransitionEqualsUniqueWhereParam,
) transitionFindUnique {
	var v transitionFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Transition"
	v.query.Outputs = transitionOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r transitionFindUnique) With(params ...TransitionRelationWith) transitionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionFindUnique) Exec(ctx context.Context) (
	*TransitionModel,
	error,
) {
	var v *TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionFindUnique) ExecInner(ctx context.Context) (
	*InnerTransition,
	error,
) {
	var v *InnerTransition
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionFindUnique) Update(params ...TransitionSetParam) transitionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Transition"

	var v transitionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionUpdateUnique struct {
	query builder.Query
}

func (r transitionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionUpdateUnique) transitionModel() {}

func (r transitionUpdateUnique) Exec(ctx context.Context) (*TransitionModel, error) {
	var v TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionUpdateUnique) Tx() transitionUniqueTxResult {
	v := NewtransitionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionFindUnique) Delete() transitionDeleteUnique {
	var v transitionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Transition"

	return v
}

type transitionDeleteUnique struct {
	query builder.Query
}

func (r transitionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionDeleteUnique) transitionModel() {}

func (r transitionDeleteUnique) Exec(ctx context.Context) (*TransitionModel, error) {
	var v TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionDeleteUnique) Tx() transitionUniqueTxResult {
	v := NewtransitionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionFindFirst struct {
	query builder.Query
}

func (r transitionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transitionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionFindFirst) with()               {}
func (r transitionFindFirst) transitionModel()    {}
func (r transitionFindFirst) transitionRelation() {}

func (r transitionActions) FindFirst(
	params ...TransitionWhereParam,
) transitionFindFirst {
	var v transitionFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Transition"
	v.query.Outputs = transitionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transitionFindFirst) With(params ...TransitionRelationWith) transitionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionFindFirst) OrderBy(params ...TransitionOrderByParam) transitionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionFindFirst) Skip(count int) transitionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionFindFirst) Take(count int) transitionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionFindFirst) Cursor(cursor TransitionCursorParam) transitionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionFindFirst) Exec(ctx context.Context) (
	*TransitionModel,
	error,
) {
	var v *TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transitionFindFirst) ExecInner(ctx context.Context) (
	*InnerTransition,
	error,
) {
	var v *InnerTransition
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transitionFindMany struct {
	query builder.Query
}

func (r transitionFindMany) getQuery() builder.Query {
	return r.query
}

func (r transitionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionFindMany) with()               {}
func (r transitionFindMany) transitionModel()    {}
func (r transitionFindMany) transitionRelation() {}

func (r transitionActions) FindMany(
	params ...TransitionWhereParam,
) transitionFindMany {
	var v transitionFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Transition"
	v.query.Outputs = transitionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transitionFindMany) With(params ...TransitionRelationWith) transitionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transitionFindMany) OrderBy(params ...TransitionOrderByParam) transitionFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transitionFindMany) Skip(count int) transitionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transitionFindMany) Take(count int) transitionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transitionFindMany) Cursor(cursor TransitionCursorParam) transitionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transitionFindMany) Exec(ctx context.Context) (
	[]TransitionModel,
	error,
) {
	var v []TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionFindMany) ExecInner(ctx context.Context) (
	[]InnerTransition,
	error,
) {
	var v []InnerTransition
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transitionFindMany) Update(params ...TransitionSetParam) transitionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Transition"

	r.query.Outputs = countOutput

	var v transitionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transitionUpdateMany struct {
	query builder.Query
}

func (r transitionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionUpdateMany) transitionModel() {}

func (r transitionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionUpdateMany) Tx() transitionManyTxResult {
	v := NewtransitionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transitionFindMany) Delete() transitionDeleteMany {
	var v transitionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Transition"

	v.query.Outputs = countOutput

	return v
}

type transitionDeleteMany struct {
	query builder.Query
}

func (r transitionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transitionDeleteMany) transitionModel() {}

func (r transitionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionDeleteMany) Tx() transitionManyTxResult {
	v := NewtransitionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type arcToNetFindUnique struct {
	query builder.Query
}

func (r arcToNetFindUnique) getQuery() builder.Query {
	return r.query
}

func (r arcToNetFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r arcToNetFindUnique) with()        {}
func (r arcToNetFindUnique) arcModel()    {}
func (r arcToNetFindUnique) arcRelation() {}

func (r arcToNetFindUnique) With(params ...NetRelationWith) arcToNetFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r arcToNetFindUnique) Exec(ctx context.Context) (
	*ArcModel,
	error,
) {
	var v *ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r arcToNetFindUnique) ExecInner(ctx context.Context) (
	*InnerArc,
	error,
) {
	var v *InnerArc
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r arcToNetFindUnique) Update(params ...ArcSetParam) arcToNetUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Arc"

	var v arcToNetUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type arcToNetUpdateUnique struct {
	query builder.Query
}

func (r arcToNetUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r arcToNetUpdateUnique) arcModel() {}

func (r arcToNetUpdateUnique) Exec(ctx context.Context) (*ArcModel, error) {
	var v ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcToNetUpdateUnique) Tx() arcUniqueTxResult {
	v := NewarcUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r arcToNetFindUnique) Delete() arcToNetDeleteUnique {
	var v arcToNetDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Arc"

	return v
}

type arcToNetDeleteUnique struct {
	query builder.Query
}

func (r arcToNetDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p arcToNetDeleteUnique) arcModel() {}

func (r arcToNetDeleteUnique) Exec(ctx context.Context) (*ArcModel, error) {
	var v ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcToNetDeleteUnique) Tx() arcUniqueTxResult {
	v := NewarcUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type arcToNetFindFirst struct {
	query builder.Query
}

func (r arcToNetFindFirst) getQuery() builder.Query {
	return r.query
}

func (r arcToNetFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r arcToNetFindFirst) with()        {}
func (r arcToNetFindFirst) arcModel()    {}
func (r arcToNetFindFirst) arcRelation() {}

func (r arcToNetFindFirst) With(params ...NetRelationWith) arcToNetFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r arcToNetFindFirst) OrderBy(params ...NetOrderByParam) arcToNetFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r arcToNetFindFirst) Skip(count int) arcToNetFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r arcToNetFindFirst) Take(count int) arcToNetFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r arcToNetFindFirst) Cursor(cursor ArcCursorParam) arcToNetFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r arcToNetFindFirst) Exec(ctx context.Context) (
	*ArcModel,
	error,
) {
	var v *ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r arcToNetFindFirst) ExecInner(ctx context.Context) (
	*InnerArc,
	error,
) {
	var v *InnerArc
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type arcToNetFindMany struct {
	query builder.Query
}

func (r arcToNetFindMany) getQuery() builder.Query {
	return r.query
}

func (r arcToNetFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r arcToNetFindMany) with()        {}
func (r arcToNetFindMany) arcModel()    {}
func (r arcToNetFindMany) arcRelation() {}

func (r arcToNetFindMany) With(params ...NetRelationWith) arcToNetFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r arcToNetFindMany) OrderBy(params ...NetOrderByParam) arcToNetFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r arcToNetFindMany) Skip(count int) arcToNetFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r arcToNetFindMany) Take(count int) arcToNetFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r arcToNetFindMany) Cursor(cursor ArcCursorParam) arcToNetFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r arcToNetFindMany) Exec(ctx context.Context) (
	[]ArcModel,
	error,
) {
	var v []ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r arcToNetFindMany) ExecInner(ctx context.Context) (
	[]InnerArc,
	error,
) {
	var v []InnerArc
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r arcToNetFindMany) Update(params ...ArcSetParam) arcToNetUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Arc"

	r.query.Outputs = countOutput

	var v arcToNetUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type arcToNetUpdateMany struct {
	query builder.Query
}

func (r arcToNetUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r arcToNetUpdateMany) arcModel() {}

func (r arcToNetUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcToNetUpdateMany) Tx() arcManyTxResult {
	v := NewarcManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r arcToNetFindMany) Delete() arcToNetDeleteMany {
	var v arcToNetDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Arc"

	v.query.Outputs = countOutput

	return v
}

type arcToNetDeleteMany struct {
	query builder.Query
}

func (r arcToNetDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p arcToNetDeleteMany) arcModel() {}

func (r arcToNetDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcToNetDeleteMany) Tx() arcManyTxResult {
	v := NewarcManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type arcToPlaceFindUnique struct {
	query builder.Query
}

func (r arcToPlaceFindUnique) getQuery() builder.Query {
	return r.query
}

func (r arcToPlaceFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r arcToPlaceFindUnique) with()        {}
func (r arcToPlaceFindUnique) arcModel()    {}
func (r arcToPlaceFindUnique) arcRelation() {}

func (r arcToPlaceFindUnique) With(params ...PlaceRelationWith) arcToPlaceFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r arcToPlaceFindUnique) Exec(ctx context.Context) (
	*ArcModel,
	error,
) {
	var v *ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r arcToPlaceFindUnique) ExecInner(ctx context.Context) (
	*InnerArc,
	error,
) {
	var v *InnerArc
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r arcToPlaceFindUnique) Update(params ...ArcSetParam) arcToPlaceUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Arc"

	var v arcToPlaceUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type arcToPlaceUpdateUnique struct {
	query builder.Query
}

func (r arcToPlaceUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r arcToPlaceUpdateUnique) arcModel() {}

func (r arcToPlaceUpdateUnique) Exec(ctx context.Context) (*ArcModel, error) {
	var v ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcToPlaceUpdateUnique) Tx() arcUniqueTxResult {
	v := NewarcUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r arcToPlaceFindUnique) Delete() arcToPlaceDeleteUnique {
	var v arcToPlaceDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Arc"

	return v
}

type arcToPlaceDeleteUnique struct {
	query builder.Query
}

func (r arcToPlaceDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p arcToPlaceDeleteUnique) arcModel() {}

func (r arcToPlaceDeleteUnique) Exec(ctx context.Context) (*ArcModel, error) {
	var v ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcToPlaceDeleteUnique) Tx() arcUniqueTxResult {
	v := NewarcUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type arcToPlaceFindFirst struct {
	query builder.Query
}

func (r arcToPlaceFindFirst) getQuery() builder.Query {
	return r.query
}

func (r arcToPlaceFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r arcToPlaceFindFirst) with()        {}
func (r arcToPlaceFindFirst) arcModel()    {}
func (r arcToPlaceFindFirst) arcRelation() {}

func (r arcToPlaceFindFirst) With(params ...PlaceRelationWith) arcToPlaceFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r arcToPlaceFindFirst) OrderBy(params ...PlaceOrderByParam) arcToPlaceFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r arcToPlaceFindFirst) Skip(count int) arcToPlaceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r arcToPlaceFindFirst) Take(count int) arcToPlaceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r arcToPlaceFindFirst) Cursor(cursor ArcCursorParam) arcToPlaceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r arcToPlaceFindFirst) Exec(ctx context.Context) (
	*ArcModel,
	error,
) {
	var v *ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r arcToPlaceFindFirst) ExecInner(ctx context.Context) (
	*InnerArc,
	error,
) {
	var v *InnerArc
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type arcToPlaceFindMany struct {
	query builder.Query
}

func (r arcToPlaceFindMany) getQuery() builder.Query {
	return r.query
}

func (r arcToPlaceFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r arcToPlaceFindMany) with()        {}
func (r arcToPlaceFindMany) arcModel()    {}
func (r arcToPlaceFindMany) arcRelation() {}

func (r arcToPlaceFindMany) With(params ...PlaceRelationWith) arcToPlaceFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r arcToPlaceFindMany) OrderBy(params ...PlaceOrderByParam) arcToPlaceFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r arcToPlaceFindMany) Skip(count int) arcToPlaceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r arcToPlaceFindMany) Take(count int) arcToPlaceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r arcToPlaceFindMany) Cursor(cursor ArcCursorParam) arcToPlaceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r arcToPlaceFindMany) Exec(ctx context.Context) (
	[]ArcModel,
	error,
) {
	var v []ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r arcToPlaceFindMany) ExecInner(ctx context.Context) (
	[]InnerArc,
	error,
) {
	var v []InnerArc
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r arcToPlaceFindMany) Update(params ...ArcSetParam) arcToPlaceUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Arc"

	r.query.Outputs = countOutput

	var v arcToPlaceUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type arcToPlaceUpdateMany struct {
	query builder.Query
}

func (r arcToPlaceUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r arcToPlaceUpdateMany) arcModel() {}

func (r arcToPlaceUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcToPlaceUpdateMany) Tx() arcManyTxResult {
	v := NewarcManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r arcToPlaceFindMany) Delete() arcToPlaceDeleteMany {
	var v arcToPlaceDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Arc"

	v.query.Outputs = countOutput

	return v
}

type arcToPlaceDeleteMany struct {
	query builder.Query
}

func (r arcToPlaceDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p arcToPlaceDeleteMany) arcModel() {}

func (r arcToPlaceDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcToPlaceDeleteMany) Tx() arcManyTxResult {
	v := NewarcManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type arcToTransitionFindUnique struct {
	query builder.Query
}

func (r arcToTransitionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r arcToTransitionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r arcToTransitionFindUnique) with()        {}
func (r arcToTransitionFindUnique) arcModel()    {}
func (r arcToTransitionFindUnique) arcRelation() {}

func (r arcToTransitionFindUnique) With(params ...TransitionRelationWith) arcToTransitionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r arcToTransitionFindUnique) Exec(ctx context.Context) (
	*ArcModel,
	error,
) {
	var v *ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r arcToTransitionFindUnique) ExecInner(ctx context.Context) (
	*InnerArc,
	error,
) {
	var v *InnerArc
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r arcToTransitionFindUnique) Update(params ...ArcSetParam) arcToTransitionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Arc"

	var v arcToTransitionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type arcToTransitionUpdateUnique struct {
	query builder.Query
}

func (r arcToTransitionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r arcToTransitionUpdateUnique) arcModel() {}

func (r arcToTransitionUpdateUnique) Exec(ctx context.Context) (*ArcModel, error) {
	var v ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcToTransitionUpdateUnique) Tx() arcUniqueTxResult {
	v := NewarcUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r arcToTransitionFindUnique) Delete() arcToTransitionDeleteUnique {
	var v arcToTransitionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Arc"

	return v
}

type arcToTransitionDeleteUnique struct {
	query builder.Query
}

func (r arcToTransitionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p arcToTransitionDeleteUnique) arcModel() {}

func (r arcToTransitionDeleteUnique) Exec(ctx context.Context) (*ArcModel, error) {
	var v ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcToTransitionDeleteUnique) Tx() arcUniqueTxResult {
	v := NewarcUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type arcToTransitionFindFirst struct {
	query builder.Query
}

func (r arcToTransitionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r arcToTransitionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r arcToTransitionFindFirst) with()        {}
func (r arcToTransitionFindFirst) arcModel()    {}
func (r arcToTransitionFindFirst) arcRelation() {}

func (r arcToTransitionFindFirst) With(params ...TransitionRelationWith) arcToTransitionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r arcToTransitionFindFirst) OrderBy(params ...TransitionOrderByParam) arcToTransitionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r arcToTransitionFindFirst) Skip(count int) arcToTransitionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r arcToTransitionFindFirst) Take(count int) arcToTransitionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r arcToTransitionFindFirst) Cursor(cursor ArcCursorParam) arcToTransitionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r arcToTransitionFindFirst) Exec(ctx context.Context) (
	*ArcModel,
	error,
) {
	var v *ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r arcToTransitionFindFirst) ExecInner(ctx context.Context) (
	*InnerArc,
	error,
) {
	var v *InnerArc
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type arcToTransitionFindMany struct {
	query builder.Query
}

func (r arcToTransitionFindMany) getQuery() builder.Query {
	return r.query
}

func (r arcToTransitionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r arcToTransitionFindMany) with()        {}
func (r arcToTransitionFindMany) arcModel()    {}
func (r arcToTransitionFindMany) arcRelation() {}

func (r arcToTransitionFindMany) With(params ...TransitionRelationWith) arcToTransitionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r arcToTransitionFindMany) OrderBy(params ...TransitionOrderByParam) arcToTransitionFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r arcToTransitionFindMany) Skip(count int) arcToTransitionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r arcToTransitionFindMany) Take(count int) arcToTransitionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r arcToTransitionFindMany) Cursor(cursor ArcCursorParam) arcToTransitionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r arcToTransitionFindMany) Exec(ctx context.Context) (
	[]ArcModel,
	error,
) {
	var v []ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r arcToTransitionFindMany) ExecInner(ctx context.Context) (
	[]InnerArc,
	error,
) {
	var v []InnerArc
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r arcToTransitionFindMany) Update(params ...ArcSetParam) arcToTransitionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Arc"

	r.query.Outputs = countOutput

	var v arcToTransitionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type arcToTransitionUpdateMany struct {
	query builder.Query
}

func (r arcToTransitionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r arcToTransitionUpdateMany) arcModel() {}

func (r arcToTransitionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcToTransitionUpdateMany) Tx() arcManyTxResult {
	v := NewarcManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r arcToTransitionFindMany) Delete() arcToTransitionDeleteMany {
	var v arcToTransitionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Arc"

	v.query.Outputs = countOutput

	return v
}

type arcToTransitionDeleteMany struct {
	query builder.Query
}

func (r arcToTransitionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p arcToTransitionDeleteMany) arcModel() {}

func (r arcToTransitionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcToTransitionDeleteMany) Tx() arcManyTxResult {
	v := NewarcManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type arcFindUnique struct {
	query builder.Query
}

func (r arcFindUnique) getQuery() builder.Query {
	return r.query
}

func (r arcFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r arcFindUnique) with()        {}
func (r arcFindUnique) arcModel()    {}
func (r arcFindUnique) arcRelation() {}

func (r arcActions) FindUnique(
	params ArcEqualsUniqueWhereParam,
) arcFindUnique {
	var v arcFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Arc"
	v.query.Outputs = arcOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r arcFindUnique) With(params ...ArcRelationWith) arcFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r arcFindUnique) Exec(ctx context.Context) (
	*ArcModel,
	error,
) {
	var v *ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r arcFindUnique) ExecInner(ctx context.Context) (
	*InnerArc,
	error,
) {
	var v *InnerArc
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r arcFindUnique) Update(params ...ArcSetParam) arcUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Arc"

	var v arcUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type arcUpdateUnique struct {
	query builder.Query
}

func (r arcUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r arcUpdateUnique) arcModel() {}

func (r arcUpdateUnique) Exec(ctx context.Context) (*ArcModel, error) {
	var v ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcUpdateUnique) Tx() arcUniqueTxResult {
	v := NewarcUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r arcFindUnique) Delete() arcDeleteUnique {
	var v arcDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Arc"

	return v
}

type arcDeleteUnique struct {
	query builder.Query
}

func (r arcDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p arcDeleteUnique) arcModel() {}

func (r arcDeleteUnique) Exec(ctx context.Context) (*ArcModel, error) {
	var v ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcDeleteUnique) Tx() arcUniqueTxResult {
	v := NewarcUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type arcFindFirst struct {
	query builder.Query
}

func (r arcFindFirst) getQuery() builder.Query {
	return r.query
}

func (r arcFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r arcFindFirst) with()        {}
func (r arcFindFirst) arcModel()    {}
func (r arcFindFirst) arcRelation() {}

func (r arcActions) FindFirst(
	params ...ArcWhereParam,
) arcFindFirst {
	var v arcFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Arc"
	v.query.Outputs = arcOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r arcFindFirst) With(params ...ArcRelationWith) arcFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r arcFindFirst) OrderBy(params ...ArcOrderByParam) arcFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r arcFindFirst) Skip(count int) arcFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r arcFindFirst) Take(count int) arcFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r arcFindFirst) Cursor(cursor ArcCursorParam) arcFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r arcFindFirst) Exec(ctx context.Context) (
	*ArcModel,
	error,
) {
	var v *ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r arcFindFirst) ExecInner(ctx context.Context) (
	*InnerArc,
	error,
) {
	var v *InnerArc
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type arcFindMany struct {
	query builder.Query
}

func (r arcFindMany) getQuery() builder.Query {
	return r.query
}

func (r arcFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r arcFindMany) with()        {}
func (r arcFindMany) arcModel()    {}
func (r arcFindMany) arcRelation() {}

func (r arcActions) FindMany(
	params ...ArcWhereParam,
) arcFindMany {
	var v arcFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Arc"
	v.query.Outputs = arcOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r arcFindMany) With(params ...ArcRelationWith) arcFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r arcFindMany) OrderBy(params ...ArcOrderByParam) arcFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r arcFindMany) Skip(count int) arcFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r arcFindMany) Take(count int) arcFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r arcFindMany) Cursor(cursor ArcCursorParam) arcFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r arcFindMany) Exec(ctx context.Context) (
	[]ArcModel,
	error,
) {
	var v []ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r arcFindMany) ExecInner(ctx context.Context) (
	[]InnerArc,
	error,
) {
	var v []InnerArc
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r arcFindMany) Update(params ...ArcSetParam) arcUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Arc"

	r.query.Outputs = countOutput

	var v arcUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type arcUpdateMany struct {
	query builder.Query
}

func (r arcUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r arcUpdateMany) arcModel() {}

func (r arcUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcUpdateMany) Tx() arcManyTxResult {
	v := NewarcManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r arcFindMany) Delete() arcDeleteMany {
	var v arcDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Arc"

	v.query.Outputs = countOutput

	return v
}

type arcDeleteMany struct {
	query builder.Query
}

func (r arcDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p arcDeleteMany) arcModel() {}

func (r arcDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcDeleteMany) Tx() arcManyTxResult {
	v := NewarcManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type devicesOnNetsToDeviceFindUnique struct {
	query builder.Query
}

func (r devicesOnNetsToDeviceFindUnique) getQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsToDeviceFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsToDeviceFindUnique) with()                  {}
func (r devicesOnNetsToDeviceFindUnique) devicesOnNetsModel()    {}
func (r devicesOnNetsToDeviceFindUnique) devicesOnNetsRelation() {}

func (r devicesOnNetsToDeviceFindUnique) With(params ...DeviceRelationWith) devicesOnNetsToDeviceFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesOnNetsToDeviceFindUnique) Exec(ctx context.Context) (
	*DevicesOnNetsModel,
	error,
) {
	var v *DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesOnNetsToDeviceFindUnique) ExecInner(ctx context.Context) (
	*InnerDevicesOnNets,
	error,
) {
	var v *InnerDevicesOnNets
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesOnNetsToDeviceFindUnique) Update(params ...DevicesOnNetsSetParam) devicesOnNetsToDeviceUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "DevicesOnNets"

	var v devicesOnNetsToDeviceUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type devicesOnNetsToDeviceUpdateUnique struct {
	query builder.Query
}

func (r devicesOnNetsToDeviceUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsToDeviceUpdateUnique) devicesOnNetsModel() {}

func (r devicesOnNetsToDeviceUpdateUnique) Exec(ctx context.Context) (*DevicesOnNetsModel, error) {
	var v DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesOnNetsToDeviceUpdateUnique) Tx() devicesOnNetsUniqueTxResult {
	v := NewdevicesOnNetsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r devicesOnNetsToDeviceFindUnique) Delete() devicesOnNetsToDeviceDeleteUnique {
	var v devicesOnNetsToDeviceDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "DevicesOnNets"

	return v
}

type devicesOnNetsToDeviceDeleteUnique struct {
	query builder.Query
}

func (r devicesOnNetsToDeviceDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p devicesOnNetsToDeviceDeleteUnique) devicesOnNetsModel() {}

func (r devicesOnNetsToDeviceDeleteUnique) Exec(ctx context.Context) (*DevicesOnNetsModel, error) {
	var v DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesOnNetsToDeviceDeleteUnique) Tx() devicesOnNetsUniqueTxResult {
	v := NewdevicesOnNetsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type devicesOnNetsToDeviceFindFirst struct {
	query builder.Query
}

func (r devicesOnNetsToDeviceFindFirst) getQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsToDeviceFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsToDeviceFindFirst) with()                  {}
func (r devicesOnNetsToDeviceFindFirst) devicesOnNetsModel()    {}
func (r devicesOnNetsToDeviceFindFirst) devicesOnNetsRelation() {}

func (r devicesOnNetsToDeviceFindFirst) With(params ...DeviceRelationWith) devicesOnNetsToDeviceFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesOnNetsToDeviceFindFirst) OrderBy(params ...DeviceOrderByParam) devicesOnNetsToDeviceFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r devicesOnNetsToDeviceFindFirst) Skip(count int) devicesOnNetsToDeviceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r devicesOnNetsToDeviceFindFirst) Take(count int) devicesOnNetsToDeviceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r devicesOnNetsToDeviceFindFirst) Cursor(cursor DevicesOnNetsCursorParam) devicesOnNetsToDeviceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r devicesOnNetsToDeviceFindFirst) Exec(ctx context.Context) (
	*DevicesOnNetsModel,
	error,
) {
	var v *DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesOnNetsToDeviceFindFirst) ExecInner(ctx context.Context) (
	*InnerDevicesOnNets,
	error,
) {
	var v *InnerDevicesOnNets
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type devicesOnNetsToDeviceFindMany struct {
	query builder.Query
}

func (r devicesOnNetsToDeviceFindMany) getQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsToDeviceFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsToDeviceFindMany) with()                  {}
func (r devicesOnNetsToDeviceFindMany) devicesOnNetsModel()    {}
func (r devicesOnNetsToDeviceFindMany) devicesOnNetsRelation() {}

func (r devicesOnNetsToDeviceFindMany) With(params ...DeviceRelationWith) devicesOnNetsToDeviceFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesOnNetsToDeviceFindMany) OrderBy(params ...DeviceOrderByParam) devicesOnNetsToDeviceFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r devicesOnNetsToDeviceFindMany) Skip(count int) devicesOnNetsToDeviceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r devicesOnNetsToDeviceFindMany) Take(count int) devicesOnNetsToDeviceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r devicesOnNetsToDeviceFindMany) Cursor(cursor DevicesOnNetsCursorParam) devicesOnNetsToDeviceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r devicesOnNetsToDeviceFindMany) Exec(ctx context.Context) (
	[]DevicesOnNetsModel,
	error,
) {
	var v []DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r devicesOnNetsToDeviceFindMany) ExecInner(ctx context.Context) (
	[]InnerDevicesOnNets,
	error,
) {
	var v []InnerDevicesOnNets
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r devicesOnNetsToDeviceFindMany) Update(params ...DevicesOnNetsSetParam) devicesOnNetsToDeviceUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "DevicesOnNets"

	r.query.Outputs = countOutput

	var v devicesOnNetsToDeviceUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type devicesOnNetsToDeviceUpdateMany struct {
	query builder.Query
}

func (r devicesOnNetsToDeviceUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsToDeviceUpdateMany) devicesOnNetsModel() {}

func (r devicesOnNetsToDeviceUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesOnNetsToDeviceUpdateMany) Tx() devicesOnNetsManyTxResult {
	v := NewdevicesOnNetsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r devicesOnNetsToDeviceFindMany) Delete() devicesOnNetsToDeviceDeleteMany {
	var v devicesOnNetsToDeviceDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "DevicesOnNets"

	v.query.Outputs = countOutput

	return v
}

type devicesOnNetsToDeviceDeleteMany struct {
	query builder.Query
}

func (r devicesOnNetsToDeviceDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p devicesOnNetsToDeviceDeleteMany) devicesOnNetsModel() {}

func (r devicesOnNetsToDeviceDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesOnNetsToDeviceDeleteMany) Tx() devicesOnNetsManyTxResult {
	v := NewdevicesOnNetsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type devicesOnNetsToNetFindUnique struct {
	query builder.Query
}

func (r devicesOnNetsToNetFindUnique) getQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsToNetFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsToNetFindUnique) with()                  {}
func (r devicesOnNetsToNetFindUnique) devicesOnNetsModel()    {}
func (r devicesOnNetsToNetFindUnique) devicesOnNetsRelation() {}

func (r devicesOnNetsToNetFindUnique) With(params ...NetRelationWith) devicesOnNetsToNetFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesOnNetsToNetFindUnique) Exec(ctx context.Context) (
	*DevicesOnNetsModel,
	error,
) {
	var v *DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesOnNetsToNetFindUnique) ExecInner(ctx context.Context) (
	*InnerDevicesOnNets,
	error,
) {
	var v *InnerDevicesOnNets
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesOnNetsToNetFindUnique) Update(params ...DevicesOnNetsSetParam) devicesOnNetsToNetUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "DevicesOnNets"

	var v devicesOnNetsToNetUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type devicesOnNetsToNetUpdateUnique struct {
	query builder.Query
}

func (r devicesOnNetsToNetUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsToNetUpdateUnique) devicesOnNetsModel() {}

func (r devicesOnNetsToNetUpdateUnique) Exec(ctx context.Context) (*DevicesOnNetsModel, error) {
	var v DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesOnNetsToNetUpdateUnique) Tx() devicesOnNetsUniqueTxResult {
	v := NewdevicesOnNetsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r devicesOnNetsToNetFindUnique) Delete() devicesOnNetsToNetDeleteUnique {
	var v devicesOnNetsToNetDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "DevicesOnNets"

	return v
}

type devicesOnNetsToNetDeleteUnique struct {
	query builder.Query
}

func (r devicesOnNetsToNetDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p devicesOnNetsToNetDeleteUnique) devicesOnNetsModel() {}

func (r devicesOnNetsToNetDeleteUnique) Exec(ctx context.Context) (*DevicesOnNetsModel, error) {
	var v DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesOnNetsToNetDeleteUnique) Tx() devicesOnNetsUniqueTxResult {
	v := NewdevicesOnNetsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type devicesOnNetsToNetFindFirst struct {
	query builder.Query
}

func (r devicesOnNetsToNetFindFirst) getQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsToNetFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsToNetFindFirst) with()                  {}
func (r devicesOnNetsToNetFindFirst) devicesOnNetsModel()    {}
func (r devicesOnNetsToNetFindFirst) devicesOnNetsRelation() {}

func (r devicesOnNetsToNetFindFirst) With(params ...NetRelationWith) devicesOnNetsToNetFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesOnNetsToNetFindFirst) OrderBy(params ...NetOrderByParam) devicesOnNetsToNetFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r devicesOnNetsToNetFindFirst) Skip(count int) devicesOnNetsToNetFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r devicesOnNetsToNetFindFirst) Take(count int) devicesOnNetsToNetFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r devicesOnNetsToNetFindFirst) Cursor(cursor DevicesOnNetsCursorParam) devicesOnNetsToNetFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r devicesOnNetsToNetFindFirst) Exec(ctx context.Context) (
	*DevicesOnNetsModel,
	error,
) {
	var v *DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesOnNetsToNetFindFirst) ExecInner(ctx context.Context) (
	*InnerDevicesOnNets,
	error,
) {
	var v *InnerDevicesOnNets
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type devicesOnNetsToNetFindMany struct {
	query builder.Query
}

func (r devicesOnNetsToNetFindMany) getQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsToNetFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsToNetFindMany) with()                  {}
func (r devicesOnNetsToNetFindMany) devicesOnNetsModel()    {}
func (r devicesOnNetsToNetFindMany) devicesOnNetsRelation() {}

func (r devicesOnNetsToNetFindMany) With(params ...NetRelationWith) devicesOnNetsToNetFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesOnNetsToNetFindMany) OrderBy(params ...NetOrderByParam) devicesOnNetsToNetFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r devicesOnNetsToNetFindMany) Skip(count int) devicesOnNetsToNetFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r devicesOnNetsToNetFindMany) Take(count int) devicesOnNetsToNetFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r devicesOnNetsToNetFindMany) Cursor(cursor DevicesOnNetsCursorParam) devicesOnNetsToNetFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r devicesOnNetsToNetFindMany) Exec(ctx context.Context) (
	[]DevicesOnNetsModel,
	error,
) {
	var v []DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r devicesOnNetsToNetFindMany) ExecInner(ctx context.Context) (
	[]InnerDevicesOnNets,
	error,
) {
	var v []InnerDevicesOnNets
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r devicesOnNetsToNetFindMany) Update(params ...DevicesOnNetsSetParam) devicesOnNetsToNetUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "DevicesOnNets"

	r.query.Outputs = countOutput

	var v devicesOnNetsToNetUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type devicesOnNetsToNetUpdateMany struct {
	query builder.Query
}

func (r devicesOnNetsToNetUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsToNetUpdateMany) devicesOnNetsModel() {}

func (r devicesOnNetsToNetUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesOnNetsToNetUpdateMany) Tx() devicesOnNetsManyTxResult {
	v := NewdevicesOnNetsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r devicesOnNetsToNetFindMany) Delete() devicesOnNetsToNetDeleteMany {
	var v devicesOnNetsToNetDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "DevicesOnNets"

	v.query.Outputs = countOutput

	return v
}

type devicesOnNetsToNetDeleteMany struct {
	query builder.Query
}

func (r devicesOnNetsToNetDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p devicesOnNetsToNetDeleteMany) devicesOnNetsModel() {}

func (r devicesOnNetsToNetDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesOnNetsToNetDeleteMany) Tx() devicesOnNetsManyTxResult {
	v := NewdevicesOnNetsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type devicesOnNetsFindUnique struct {
	query builder.Query
}

func (r devicesOnNetsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsFindUnique) with()                  {}
func (r devicesOnNetsFindUnique) devicesOnNetsModel()    {}
func (r devicesOnNetsFindUnique) devicesOnNetsRelation() {}

func (r devicesOnNetsActions) FindUnique(
	params DevicesOnNetsEqualsUniqueWhereParam,
) devicesOnNetsFindUnique {
	var v devicesOnNetsFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "DevicesOnNets"
	v.query.Outputs = devicesOnNetsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r devicesOnNetsFindUnique) With(params ...DevicesOnNetsRelationWith) devicesOnNetsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesOnNetsFindUnique) Exec(ctx context.Context) (
	*DevicesOnNetsModel,
	error,
) {
	var v *DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesOnNetsFindUnique) ExecInner(ctx context.Context) (
	*InnerDevicesOnNets,
	error,
) {
	var v *InnerDevicesOnNets
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesOnNetsFindUnique) Update(params ...DevicesOnNetsSetParam) devicesOnNetsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "DevicesOnNets"

	var v devicesOnNetsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type devicesOnNetsUpdateUnique struct {
	query builder.Query
}

func (r devicesOnNetsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsUpdateUnique) devicesOnNetsModel() {}

func (r devicesOnNetsUpdateUnique) Exec(ctx context.Context) (*DevicesOnNetsModel, error) {
	var v DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesOnNetsUpdateUnique) Tx() devicesOnNetsUniqueTxResult {
	v := NewdevicesOnNetsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r devicesOnNetsFindUnique) Delete() devicesOnNetsDeleteUnique {
	var v devicesOnNetsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "DevicesOnNets"

	return v
}

type devicesOnNetsDeleteUnique struct {
	query builder.Query
}

func (r devicesOnNetsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p devicesOnNetsDeleteUnique) devicesOnNetsModel() {}

func (r devicesOnNetsDeleteUnique) Exec(ctx context.Context) (*DevicesOnNetsModel, error) {
	var v DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesOnNetsDeleteUnique) Tx() devicesOnNetsUniqueTxResult {
	v := NewdevicesOnNetsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type devicesOnNetsFindFirst struct {
	query builder.Query
}

func (r devicesOnNetsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsFindFirst) with()                  {}
func (r devicesOnNetsFindFirst) devicesOnNetsModel()    {}
func (r devicesOnNetsFindFirst) devicesOnNetsRelation() {}

func (r devicesOnNetsActions) FindFirst(
	params ...DevicesOnNetsWhereParam,
) devicesOnNetsFindFirst {
	var v devicesOnNetsFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "DevicesOnNets"
	v.query.Outputs = devicesOnNetsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r devicesOnNetsFindFirst) With(params ...DevicesOnNetsRelationWith) devicesOnNetsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesOnNetsFindFirst) OrderBy(params ...DevicesOnNetsOrderByParam) devicesOnNetsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r devicesOnNetsFindFirst) Skip(count int) devicesOnNetsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r devicesOnNetsFindFirst) Take(count int) devicesOnNetsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r devicesOnNetsFindFirst) Cursor(cursor DevicesOnNetsCursorParam) devicesOnNetsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r devicesOnNetsFindFirst) Exec(ctx context.Context) (
	*DevicesOnNetsModel,
	error,
) {
	var v *DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesOnNetsFindFirst) ExecInner(ctx context.Context) (
	*InnerDevicesOnNets,
	error,
) {
	var v *InnerDevicesOnNets
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type devicesOnNetsFindMany struct {
	query builder.Query
}

func (r devicesOnNetsFindMany) getQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsFindMany) with()                  {}
func (r devicesOnNetsFindMany) devicesOnNetsModel()    {}
func (r devicesOnNetsFindMany) devicesOnNetsRelation() {}

func (r devicesOnNetsActions) FindMany(
	params ...DevicesOnNetsWhereParam,
) devicesOnNetsFindMany {
	var v devicesOnNetsFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "DevicesOnNets"
	v.query.Outputs = devicesOnNetsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r devicesOnNetsFindMany) With(params ...DevicesOnNetsRelationWith) devicesOnNetsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesOnNetsFindMany) OrderBy(params ...DevicesOnNetsOrderByParam) devicesOnNetsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r devicesOnNetsFindMany) Skip(count int) devicesOnNetsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r devicesOnNetsFindMany) Take(count int) devicesOnNetsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r devicesOnNetsFindMany) Cursor(cursor DevicesOnNetsCursorParam) devicesOnNetsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r devicesOnNetsFindMany) Exec(ctx context.Context) (
	[]DevicesOnNetsModel,
	error,
) {
	var v []DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r devicesOnNetsFindMany) ExecInner(ctx context.Context) (
	[]InnerDevicesOnNets,
	error,
) {
	var v []InnerDevicesOnNets
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r devicesOnNetsFindMany) Update(params ...DevicesOnNetsSetParam) devicesOnNetsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "DevicesOnNets"

	r.query.Outputs = countOutput

	var v devicesOnNetsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type devicesOnNetsUpdateMany struct {
	query builder.Query
}

func (r devicesOnNetsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsUpdateMany) devicesOnNetsModel() {}

func (r devicesOnNetsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesOnNetsUpdateMany) Tx() devicesOnNetsManyTxResult {
	v := NewdevicesOnNetsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r devicesOnNetsFindMany) Delete() devicesOnNetsDeleteMany {
	var v devicesOnNetsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "DevicesOnNets"

	v.query.Outputs = countOutput

	return v
}

type devicesOnNetsDeleteMany struct {
	query builder.Query
}

func (r devicesOnNetsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p devicesOnNetsDeleteMany) devicesOnNetsModel() {}

func (r devicesOnNetsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesOnNetsDeleteMany) Tx() devicesOnNetsManyTxResult {
	v := NewdevicesOnNetsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fieldToEventFindUnique struct {
	query builder.Query
}

func (r fieldToEventFindUnique) getQuery() builder.Query {
	return r.query
}

func (r fieldToEventFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r fieldToEventFindUnique) with()          {}
func (r fieldToEventFindUnique) fieldModel()    {}
func (r fieldToEventFindUnique) fieldRelation() {}

func (r fieldToEventFindUnique) With(params ...EventRelationWith) fieldToEventFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fieldToEventFindUnique) Exec(ctx context.Context) (
	*FieldModel,
	error,
) {
	var v *FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fieldToEventFindUnique) ExecInner(ctx context.Context) (
	*InnerField,
	error,
) {
	var v *InnerField
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fieldToEventFindUnique) Update(params ...FieldSetParam) fieldToEventUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Field"

	var v fieldToEventUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type fieldToEventUpdateUnique struct {
	query builder.Query
}

func (r fieldToEventUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r fieldToEventUpdateUnique) fieldModel() {}

func (r fieldToEventUpdateUnique) Exec(ctx context.Context) (*FieldModel, error) {
	var v FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fieldToEventUpdateUnique) Tx() fieldUniqueTxResult {
	v := NewfieldUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r fieldToEventFindUnique) Delete() fieldToEventDeleteUnique {
	var v fieldToEventDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Field"

	return v
}

type fieldToEventDeleteUnique struct {
	query builder.Query
}

func (r fieldToEventDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p fieldToEventDeleteUnique) fieldModel() {}

func (r fieldToEventDeleteUnique) Exec(ctx context.Context) (*FieldModel, error) {
	var v FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fieldToEventDeleteUnique) Tx() fieldUniqueTxResult {
	v := NewfieldUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fieldToEventFindFirst struct {
	query builder.Query
}

func (r fieldToEventFindFirst) getQuery() builder.Query {
	return r.query
}

func (r fieldToEventFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r fieldToEventFindFirst) with()          {}
func (r fieldToEventFindFirst) fieldModel()    {}
func (r fieldToEventFindFirst) fieldRelation() {}

func (r fieldToEventFindFirst) With(params ...EventRelationWith) fieldToEventFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fieldToEventFindFirst) OrderBy(params ...EventOrderByParam) fieldToEventFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r fieldToEventFindFirst) Skip(count int) fieldToEventFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r fieldToEventFindFirst) Take(count int) fieldToEventFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r fieldToEventFindFirst) Cursor(cursor FieldCursorParam) fieldToEventFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r fieldToEventFindFirst) Exec(ctx context.Context) (
	*FieldModel,
	error,
) {
	var v *FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fieldToEventFindFirst) ExecInner(ctx context.Context) (
	*InnerField,
	error,
) {
	var v *InnerField
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type fieldToEventFindMany struct {
	query builder.Query
}

func (r fieldToEventFindMany) getQuery() builder.Query {
	return r.query
}

func (r fieldToEventFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r fieldToEventFindMany) with()          {}
func (r fieldToEventFindMany) fieldModel()    {}
func (r fieldToEventFindMany) fieldRelation() {}

func (r fieldToEventFindMany) With(params ...EventRelationWith) fieldToEventFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fieldToEventFindMany) OrderBy(params ...EventOrderByParam) fieldToEventFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r fieldToEventFindMany) Skip(count int) fieldToEventFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r fieldToEventFindMany) Take(count int) fieldToEventFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r fieldToEventFindMany) Cursor(cursor FieldCursorParam) fieldToEventFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r fieldToEventFindMany) Exec(ctx context.Context) (
	[]FieldModel,
	error,
) {
	var v []FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r fieldToEventFindMany) ExecInner(ctx context.Context) (
	[]InnerField,
	error,
) {
	var v []InnerField
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r fieldToEventFindMany) Update(params ...FieldSetParam) fieldToEventUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Field"

	r.query.Outputs = countOutput

	var v fieldToEventUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type fieldToEventUpdateMany struct {
	query builder.Query
}

func (r fieldToEventUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r fieldToEventUpdateMany) fieldModel() {}

func (r fieldToEventUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fieldToEventUpdateMany) Tx() fieldManyTxResult {
	v := NewfieldManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r fieldToEventFindMany) Delete() fieldToEventDeleteMany {
	var v fieldToEventDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Field"

	v.query.Outputs = countOutput

	return v
}

type fieldToEventDeleteMany struct {
	query builder.Query
}

func (r fieldToEventDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p fieldToEventDeleteMany) fieldModel() {}

func (r fieldToEventDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fieldToEventDeleteMany) Tx() fieldManyTxResult {
	v := NewfieldManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fieldToConstantsFindUnique struct {
	query builder.Query
}

func (r fieldToConstantsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r fieldToConstantsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r fieldToConstantsFindUnique) with()          {}
func (r fieldToConstantsFindUnique) fieldModel()    {}
func (r fieldToConstantsFindUnique) fieldRelation() {}

func (r fieldToConstantsFindUnique) With(params ...ConstantRelationWith) fieldToConstantsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fieldToConstantsFindUnique) Exec(ctx context.Context) (
	*FieldModel,
	error,
) {
	var v *FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fieldToConstantsFindUnique) ExecInner(ctx context.Context) (
	*InnerField,
	error,
) {
	var v *InnerField
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fieldToConstantsFindUnique) Update(params ...FieldSetParam) fieldToConstantsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Field"

	var v fieldToConstantsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type fieldToConstantsUpdateUnique struct {
	query builder.Query
}

func (r fieldToConstantsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r fieldToConstantsUpdateUnique) fieldModel() {}

func (r fieldToConstantsUpdateUnique) Exec(ctx context.Context) (*FieldModel, error) {
	var v FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fieldToConstantsUpdateUnique) Tx() fieldUniqueTxResult {
	v := NewfieldUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r fieldToConstantsFindUnique) Delete() fieldToConstantsDeleteUnique {
	var v fieldToConstantsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Field"

	return v
}

type fieldToConstantsDeleteUnique struct {
	query builder.Query
}

func (r fieldToConstantsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p fieldToConstantsDeleteUnique) fieldModel() {}

func (r fieldToConstantsDeleteUnique) Exec(ctx context.Context) (*FieldModel, error) {
	var v FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fieldToConstantsDeleteUnique) Tx() fieldUniqueTxResult {
	v := NewfieldUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fieldToConstantsFindFirst struct {
	query builder.Query
}

func (r fieldToConstantsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r fieldToConstantsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r fieldToConstantsFindFirst) with()          {}
func (r fieldToConstantsFindFirst) fieldModel()    {}
func (r fieldToConstantsFindFirst) fieldRelation() {}

func (r fieldToConstantsFindFirst) With(params ...ConstantRelationWith) fieldToConstantsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fieldToConstantsFindFirst) OrderBy(params ...ConstantOrderByParam) fieldToConstantsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r fieldToConstantsFindFirst) Skip(count int) fieldToConstantsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r fieldToConstantsFindFirst) Take(count int) fieldToConstantsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r fieldToConstantsFindFirst) Cursor(cursor FieldCursorParam) fieldToConstantsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r fieldToConstantsFindFirst) Exec(ctx context.Context) (
	*FieldModel,
	error,
) {
	var v *FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fieldToConstantsFindFirst) ExecInner(ctx context.Context) (
	*InnerField,
	error,
) {
	var v *InnerField
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type fieldToConstantsFindMany struct {
	query builder.Query
}

func (r fieldToConstantsFindMany) getQuery() builder.Query {
	return r.query
}

func (r fieldToConstantsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r fieldToConstantsFindMany) with()          {}
func (r fieldToConstantsFindMany) fieldModel()    {}
func (r fieldToConstantsFindMany) fieldRelation() {}

func (r fieldToConstantsFindMany) With(params ...ConstantRelationWith) fieldToConstantsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fieldToConstantsFindMany) OrderBy(params ...ConstantOrderByParam) fieldToConstantsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r fieldToConstantsFindMany) Skip(count int) fieldToConstantsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r fieldToConstantsFindMany) Take(count int) fieldToConstantsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r fieldToConstantsFindMany) Cursor(cursor FieldCursorParam) fieldToConstantsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r fieldToConstantsFindMany) Exec(ctx context.Context) (
	[]FieldModel,
	error,
) {
	var v []FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r fieldToConstantsFindMany) ExecInner(ctx context.Context) (
	[]InnerField,
	error,
) {
	var v []InnerField
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r fieldToConstantsFindMany) Update(params ...FieldSetParam) fieldToConstantsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Field"

	r.query.Outputs = countOutput

	var v fieldToConstantsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type fieldToConstantsUpdateMany struct {
	query builder.Query
}

func (r fieldToConstantsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r fieldToConstantsUpdateMany) fieldModel() {}

func (r fieldToConstantsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fieldToConstantsUpdateMany) Tx() fieldManyTxResult {
	v := NewfieldManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r fieldToConstantsFindMany) Delete() fieldToConstantsDeleteMany {
	var v fieldToConstantsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Field"

	v.query.Outputs = countOutput

	return v
}

type fieldToConstantsDeleteMany struct {
	query builder.Query
}

func (r fieldToConstantsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p fieldToConstantsDeleteMany) fieldModel() {}

func (r fieldToConstantsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fieldToConstantsDeleteMany) Tx() fieldManyTxResult {
	v := NewfieldManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fieldFindUnique struct {
	query builder.Query
}

func (r fieldFindUnique) getQuery() builder.Query {
	return r.query
}

func (r fieldFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r fieldFindUnique) with()          {}
func (r fieldFindUnique) fieldModel()    {}
func (r fieldFindUnique) fieldRelation() {}

func (r fieldActions) FindUnique(
	params FieldEqualsUniqueWhereParam,
) fieldFindUnique {
	var v fieldFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Field"
	v.query.Outputs = fieldOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r fieldFindUnique) With(params ...FieldRelationWith) fieldFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fieldFindUnique) Exec(ctx context.Context) (
	*FieldModel,
	error,
) {
	var v *FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fieldFindUnique) ExecInner(ctx context.Context) (
	*InnerField,
	error,
) {
	var v *InnerField
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fieldFindUnique) Update(params ...FieldSetParam) fieldUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Field"

	var v fieldUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type fieldUpdateUnique struct {
	query builder.Query
}

func (r fieldUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r fieldUpdateUnique) fieldModel() {}

func (r fieldUpdateUnique) Exec(ctx context.Context) (*FieldModel, error) {
	var v FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fieldUpdateUnique) Tx() fieldUniqueTxResult {
	v := NewfieldUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r fieldFindUnique) Delete() fieldDeleteUnique {
	var v fieldDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Field"

	return v
}

type fieldDeleteUnique struct {
	query builder.Query
}

func (r fieldDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p fieldDeleteUnique) fieldModel() {}

func (r fieldDeleteUnique) Exec(ctx context.Context) (*FieldModel, error) {
	var v FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fieldDeleteUnique) Tx() fieldUniqueTxResult {
	v := NewfieldUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fieldFindFirst struct {
	query builder.Query
}

func (r fieldFindFirst) getQuery() builder.Query {
	return r.query
}

func (r fieldFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r fieldFindFirst) with()          {}
func (r fieldFindFirst) fieldModel()    {}
func (r fieldFindFirst) fieldRelation() {}

func (r fieldActions) FindFirst(
	params ...FieldWhereParam,
) fieldFindFirst {
	var v fieldFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Field"
	v.query.Outputs = fieldOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r fieldFindFirst) With(params ...FieldRelationWith) fieldFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fieldFindFirst) OrderBy(params ...FieldOrderByParam) fieldFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r fieldFindFirst) Skip(count int) fieldFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r fieldFindFirst) Take(count int) fieldFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r fieldFindFirst) Cursor(cursor FieldCursorParam) fieldFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r fieldFindFirst) Exec(ctx context.Context) (
	*FieldModel,
	error,
) {
	var v *FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fieldFindFirst) ExecInner(ctx context.Context) (
	*InnerField,
	error,
) {
	var v *InnerField
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type fieldFindMany struct {
	query builder.Query
}

func (r fieldFindMany) getQuery() builder.Query {
	return r.query
}

func (r fieldFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r fieldFindMany) with()          {}
func (r fieldFindMany) fieldModel()    {}
func (r fieldFindMany) fieldRelation() {}

func (r fieldActions) FindMany(
	params ...FieldWhereParam,
) fieldFindMany {
	var v fieldFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Field"
	v.query.Outputs = fieldOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r fieldFindMany) With(params ...FieldRelationWith) fieldFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fieldFindMany) OrderBy(params ...FieldOrderByParam) fieldFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r fieldFindMany) Skip(count int) fieldFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r fieldFindMany) Take(count int) fieldFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r fieldFindMany) Cursor(cursor FieldCursorParam) fieldFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r fieldFindMany) Exec(ctx context.Context) (
	[]FieldModel,
	error,
) {
	var v []FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r fieldFindMany) ExecInner(ctx context.Context) (
	[]InnerField,
	error,
) {
	var v []InnerField
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r fieldFindMany) Update(params ...FieldSetParam) fieldUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Field"

	r.query.Outputs = countOutput

	var v fieldUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type fieldUpdateMany struct {
	query builder.Query
}

func (r fieldUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r fieldUpdateMany) fieldModel() {}

func (r fieldUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fieldUpdateMany) Tx() fieldManyTxResult {
	v := NewfieldManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r fieldFindMany) Delete() fieldDeleteMany {
	var v fieldDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Field"

	v.query.Outputs = countOutput

	return v
}

type fieldDeleteMany struct {
	query builder.Query
}

func (r fieldDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p fieldDeleteMany) fieldModel() {}

func (r fieldDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fieldDeleteMany) Tx() fieldManyTxResult {
	v := NewfieldManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type eventToTransitionsFindUnique struct {
	query builder.Query
}

func (r eventToTransitionsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r eventToTransitionsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToTransitionsFindUnique) with()          {}
func (r eventToTransitionsFindUnique) eventModel()    {}
func (r eventToTransitionsFindUnique) eventRelation() {}

func (r eventToTransitionsFindUnique) With(params ...TransitionRelationWith) eventToTransitionsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventToTransitionsFindUnique) Exec(ctx context.Context) (
	*EventModel,
	error,
) {
	var v *EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventToTransitionsFindUnique) ExecInner(ctx context.Context) (
	*InnerEvent,
	error,
) {
	var v *InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventToTransitionsFindUnique) Update(params ...EventSetParam) eventToTransitionsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Event"

	var v eventToTransitionsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type eventToTransitionsUpdateUnique struct {
	query builder.Query
}

func (r eventToTransitionsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToTransitionsUpdateUnique) eventModel() {}

func (r eventToTransitionsUpdateUnique) Exec(ctx context.Context) (*EventModel, error) {
	var v EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToTransitionsUpdateUnique) Tx() eventUniqueTxResult {
	v := NeweventUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r eventToTransitionsFindUnique) Delete() eventToTransitionsDeleteUnique {
	var v eventToTransitionsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Event"

	return v
}

type eventToTransitionsDeleteUnique struct {
	query builder.Query
}

func (r eventToTransitionsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p eventToTransitionsDeleteUnique) eventModel() {}

func (r eventToTransitionsDeleteUnique) Exec(ctx context.Context) (*EventModel, error) {
	var v EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToTransitionsDeleteUnique) Tx() eventUniqueTxResult {
	v := NeweventUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type eventToTransitionsFindFirst struct {
	query builder.Query
}

func (r eventToTransitionsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r eventToTransitionsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToTransitionsFindFirst) with()          {}
func (r eventToTransitionsFindFirst) eventModel()    {}
func (r eventToTransitionsFindFirst) eventRelation() {}

func (r eventToTransitionsFindFirst) With(params ...TransitionRelationWith) eventToTransitionsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventToTransitionsFindFirst) OrderBy(params ...TransitionOrderByParam) eventToTransitionsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r eventToTransitionsFindFirst) Skip(count int) eventToTransitionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r eventToTransitionsFindFirst) Take(count int) eventToTransitionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r eventToTransitionsFindFirst) Cursor(cursor EventCursorParam) eventToTransitionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r eventToTransitionsFindFirst) Exec(ctx context.Context) (
	*EventModel,
	error,
) {
	var v *EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventToTransitionsFindFirst) ExecInner(ctx context.Context) (
	*InnerEvent,
	error,
) {
	var v *InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type eventToTransitionsFindMany struct {
	query builder.Query
}

func (r eventToTransitionsFindMany) getQuery() builder.Query {
	return r.query
}

func (r eventToTransitionsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToTransitionsFindMany) with()          {}
func (r eventToTransitionsFindMany) eventModel()    {}
func (r eventToTransitionsFindMany) eventRelation() {}

func (r eventToTransitionsFindMany) With(params ...TransitionRelationWith) eventToTransitionsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventToTransitionsFindMany) OrderBy(params ...TransitionOrderByParam) eventToTransitionsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r eventToTransitionsFindMany) Skip(count int) eventToTransitionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r eventToTransitionsFindMany) Take(count int) eventToTransitionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r eventToTransitionsFindMany) Cursor(cursor EventCursorParam) eventToTransitionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r eventToTransitionsFindMany) Exec(ctx context.Context) (
	[]EventModel,
	error,
) {
	var v []EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r eventToTransitionsFindMany) ExecInner(ctx context.Context) (
	[]InnerEvent,
	error,
) {
	var v []InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r eventToTransitionsFindMany) Update(params ...EventSetParam) eventToTransitionsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Event"

	r.query.Outputs = countOutput

	var v eventToTransitionsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type eventToTransitionsUpdateMany struct {
	query builder.Query
}

func (r eventToTransitionsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToTransitionsUpdateMany) eventModel() {}

func (r eventToTransitionsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToTransitionsUpdateMany) Tx() eventManyTxResult {
	v := NeweventManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r eventToTransitionsFindMany) Delete() eventToTransitionsDeleteMany {
	var v eventToTransitionsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Event"

	v.query.Outputs = countOutput

	return v
}

type eventToTransitionsDeleteMany struct {
	query builder.Query
}

func (r eventToTransitionsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p eventToTransitionsDeleteMany) eventModel() {}

func (r eventToTransitionsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToTransitionsDeleteMany) Tx() eventManyTxResult {
	v := NeweventManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type eventToFieldsFindUnique struct {
	query builder.Query
}

func (r eventToFieldsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r eventToFieldsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToFieldsFindUnique) with()          {}
func (r eventToFieldsFindUnique) eventModel()    {}
func (r eventToFieldsFindUnique) eventRelation() {}

func (r eventToFieldsFindUnique) With(params ...FieldRelationWith) eventToFieldsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventToFieldsFindUnique) Exec(ctx context.Context) (
	*EventModel,
	error,
) {
	var v *EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventToFieldsFindUnique) ExecInner(ctx context.Context) (
	*InnerEvent,
	error,
) {
	var v *InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventToFieldsFindUnique) Update(params ...EventSetParam) eventToFieldsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Event"

	var v eventToFieldsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type eventToFieldsUpdateUnique struct {
	query builder.Query
}

func (r eventToFieldsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToFieldsUpdateUnique) eventModel() {}

func (r eventToFieldsUpdateUnique) Exec(ctx context.Context) (*EventModel, error) {
	var v EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToFieldsUpdateUnique) Tx() eventUniqueTxResult {
	v := NeweventUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r eventToFieldsFindUnique) Delete() eventToFieldsDeleteUnique {
	var v eventToFieldsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Event"

	return v
}

type eventToFieldsDeleteUnique struct {
	query builder.Query
}

func (r eventToFieldsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p eventToFieldsDeleteUnique) eventModel() {}

func (r eventToFieldsDeleteUnique) Exec(ctx context.Context) (*EventModel, error) {
	var v EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToFieldsDeleteUnique) Tx() eventUniqueTxResult {
	v := NeweventUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type eventToFieldsFindFirst struct {
	query builder.Query
}

func (r eventToFieldsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r eventToFieldsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToFieldsFindFirst) with()          {}
func (r eventToFieldsFindFirst) eventModel()    {}
func (r eventToFieldsFindFirst) eventRelation() {}

func (r eventToFieldsFindFirst) With(params ...FieldRelationWith) eventToFieldsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventToFieldsFindFirst) OrderBy(params ...FieldOrderByParam) eventToFieldsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r eventToFieldsFindFirst) Skip(count int) eventToFieldsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r eventToFieldsFindFirst) Take(count int) eventToFieldsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r eventToFieldsFindFirst) Cursor(cursor EventCursorParam) eventToFieldsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r eventToFieldsFindFirst) Exec(ctx context.Context) (
	*EventModel,
	error,
) {
	var v *EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventToFieldsFindFirst) ExecInner(ctx context.Context) (
	*InnerEvent,
	error,
) {
	var v *InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type eventToFieldsFindMany struct {
	query builder.Query
}

func (r eventToFieldsFindMany) getQuery() builder.Query {
	return r.query
}

func (r eventToFieldsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToFieldsFindMany) with()          {}
func (r eventToFieldsFindMany) eventModel()    {}
func (r eventToFieldsFindMany) eventRelation() {}

func (r eventToFieldsFindMany) With(params ...FieldRelationWith) eventToFieldsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventToFieldsFindMany) OrderBy(params ...FieldOrderByParam) eventToFieldsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r eventToFieldsFindMany) Skip(count int) eventToFieldsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r eventToFieldsFindMany) Take(count int) eventToFieldsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r eventToFieldsFindMany) Cursor(cursor EventCursorParam) eventToFieldsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r eventToFieldsFindMany) Exec(ctx context.Context) (
	[]EventModel,
	error,
) {
	var v []EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r eventToFieldsFindMany) ExecInner(ctx context.Context) (
	[]InnerEvent,
	error,
) {
	var v []InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r eventToFieldsFindMany) Update(params ...EventSetParam) eventToFieldsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Event"

	r.query.Outputs = countOutput

	var v eventToFieldsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type eventToFieldsUpdateMany struct {
	query builder.Query
}

func (r eventToFieldsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToFieldsUpdateMany) eventModel() {}

func (r eventToFieldsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToFieldsUpdateMany) Tx() eventManyTxResult {
	v := NeweventManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r eventToFieldsFindMany) Delete() eventToFieldsDeleteMany {
	var v eventToFieldsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Event"

	v.query.Outputs = countOutput

	return v
}

type eventToFieldsDeleteMany struct {
	query builder.Query
}

func (r eventToFieldsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p eventToFieldsDeleteMany) eventModel() {}

func (r eventToFieldsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToFieldsDeleteMany) Tx() eventManyTxResult {
	v := NeweventManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type eventToCommandsFindUnique struct {
	query builder.Query
}

func (r eventToCommandsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r eventToCommandsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToCommandsFindUnique) with()          {}
func (r eventToCommandsFindUnique) eventModel()    {}
func (r eventToCommandsFindUnique) eventRelation() {}

func (r eventToCommandsFindUnique) With(params ...ActionRelationWith) eventToCommandsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventToCommandsFindUnique) Exec(ctx context.Context) (
	*EventModel,
	error,
) {
	var v *EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventToCommandsFindUnique) ExecInner(ctx context.Context) (
	*InnerEvent,
	error,
) {
	var v *InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventToCommandsFindUnique) Update(params ...EventSetParam) eventToCommandsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Event"

	var v eventToCommandsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type eventToCommandsUpdateUnique struct {
	query builder.Query
}

func (r eventToCommandsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToCommandsUpdateUnique) eventModel() {}

func (r eventToCommandsUpdateUnique) Exec(ctx context.Context) (*EventModel, error) {
	var v EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToCommandsUpdateUnique) Tx() eventUniqueTxResult {
	v := NeweventUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r eventToCommandsFindUnique) Delete() eventToCommandsDeleteUnique {
	var v eventToCommandsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Event"

	return v
}

type eventToCommandsDeleteUnique struct {
	query builder.Query
}

func (r eventToCommandsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p eventToCommandsDeleteUnique) eventModel() {}

func (r eventToCommandsDeleteUnique) Exec(ctx context.Context) (*EventModel, error) {
	var v EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToCommandsDeleteUnique) Tx() eventUniqueTxResult {
	v := NeweventUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type eventToCommandsFindFirst struct {
	query builder.Query
}

func (r eventToCommandsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r eventToCommandsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToCommandsFindFirst) with()          {}
func (r eventToCommandsFindFirst) eventModel()    {}
func (r eventToCommandsFindFirst) eventRelation() {}

func (r eventToCommandsFindFirst) With(params ...ActionRelationWith) eventToCommandsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventToCommandsFindFirst) OrderBy(params ...ActionOrderByParam) eventToCommandsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r eventToCommandsFindFirst) Skip(count int) eventToCommandsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r eventToCommandsFindFirst) Take(count int) eventToCommandsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r eventToCommandsFindFirst) Cursor(cursor EventCursorParam) eventToCommandsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r eventToCommandsFindFirst) Exec(ctx context.Context) (
	*EventModel,
	error,
) {
	var v *EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventToCommandsFindFirst) ExecInner(ctx context.Context) (
	*InnerEvent,
	error,
) {
	var v *InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type eventToCommandsFindMany struct {
	query builder.Query
}

func (r eventToCommandsFindMany) getQuery() builder.Query {
	return r.query
}

func (r eventToCommandsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToCommandsFindMany) with()          {}
func (r eventToCommandsFindMany) eventModel()    {}
func (r eventToCommandsFindMany) eventRelation() {}

func (r eventToCommandsFindMany) With(params ...ActionRelationWith) eventToCommandsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventToCommandsFindMany) OrderBy(params ...ActionOrderByParam) eventToCommandsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r eventToCommandsFindMany) Skip(count int) eventToCommandsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r eventToCommandsFindMany) Take(count int) eventToCommandsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r eventToCommandsFindMany) Cursor(cursor EventCursorParam) eventToCommandsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r eventToCommandsFindMany) Exec(ctx context.Context) (
	[]EventModel,
	error,
) {
	var v []EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r eventToCommandsFindMany) ExecInner(ctx context.Context) (
	[]InnerEvent,
	error,
) {
	var v []InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r eventToCommandsFindMany) Update(params ...EventSetParam) eventToCommandsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Event"

	r.query.Outputs = countOutput

	var v eventToCommandsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type eventToCommandsUpdateMany struct {
	query builder.Query
}

func (r eventToCommandsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToCommandsUpdateMany) eventModel() {}

func (r eventToCommandsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToCommandsUpdateMany) Tx() eventManyTxResult {
	v := NeweventManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r eventToCommandsFindMany) Delete() eventToCommandsDeleteMany {
	var v eventToCommandsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Event"

	v.query.Outputs = countOutput

	return v
}

type eventToCommandsDeleteMany struct {
	query builder.Query
}

func (r eventToCommandsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p eventToCommandsDeleteMany) eventModel() {}

func (r eventToCommandsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToCommandsDeleteMany) Tx() eventManyTxResult {
	v := NeweventManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type eventToDataFindUnique struct {
	query builder.Query
}

func (r eventToDataFindUnique) getQuery() builder.Query {
	return r.query
}

func (r eventToDataFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToDataFindUnique) with()          {}
func (r eventToDataFindUnique) eventModel()    {}
func (r eventToDataFindUnique) eventRelation() {}

func (r eventToDataFindUnique) With(params ...DatumRelationWith) eventToDataFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventToDataFindUnique) Exec(ctx context.Context) (
	*EventModel,
	error,
) {
	var v *EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventToDataFindUnique) ExecInner(ctx context.Context) (
	*InnerEvent,
	error,
) {
	var v *InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventToDataFindUnique) Update(params ...EventSetParam) eventToDataUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Event"

	var v eventToDataUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type eventToDataUpdateUnique struct {
	query builder.Query
}

func (r eventToDataUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToDataUpdateUnique) eventModel() {}

func (r eventToDataUpdateUnique) Exec(ctx context.Context) (*EventModel, error) {
	var v EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToDataUpdateUnique) Tx() eventUniqueTxResult {
	v := NeweventUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r eventToDataFindUnique) Delete() eventToDataDeleteUnique {
	var v eventToDataDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Event"

	return v
}

type eventToDataDeleteUnique struct {
	query builder.Query
}

func (r eventToDataDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p eventToDataDeleteUnique) eventModel() {}

func (r eventToDataDeleteUnique) Exec(ctx context.Context) (*EventModel, error) {
	var v EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToDataDeleteUnique) Tx() eventUniqueTxResult {
	v := NeweventUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type eventToDataFindFirst struct {
	query builder.Query
}

func (r eventToDataFindFirst) getQuery() builder.Query {
	return r.query
}

func (r eventToDataFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToDataFindFirst) with()          {}
func (r eventToDataFindFirst) eventModel()    {}
func (r eventToDataFindFirst) eventRelation() {}

func (r eventToDataFindFirst) With(params ...DatumRelationWith) eventToDataFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventToDataFindFirst) OrderBy(params ...DatumOrderByParam) eventToDataFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r eventToDataFindFirst) Skip(count int) eventToDataFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r eventToDataFindFirst) Take(count int) eventToDataFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r eventToDataFindFirst) Cursor(cursor EventCursorParam) eventToDataFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r eventToDataFindFirst) Exec(ctx context.Context) (
	*EventModel,
	error,
) {
	var v *EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventToDataFindFirst) ExecInner(ctx context.Context) (
	*InnerEvent,
	error,
) {
	var v *InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type eventToDataFindMany struct {
	query builder.Query
}

func (r eventToDataFindMany) getQuery() builder.Query {
	return r.query
}

func (r eventToDataFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToDataFindMany) with()          {}
func (r eventToDataFindMany) eventModel()    {}
func (r eventToDataFindMany) eventRelation() {}

func (r eventToDataFindMany) With(params ...DatumRelationWith) eventToDataFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventToDataFindMany) OrderBy(params ...DatumOrderByParam) eventToDataFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r eventToDataFindMany) Skip(count int) eventToDataFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r eventToDataFindMany) Take(count int) eventToDataFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r eventToDataFindMany) Cursor(cursor EventCursorParam) eventToDataFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r eventToDataFindMany) Exec(ctx context.Context) (
	[]EventModel,
	error,
) {
	var v []EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r eventToDataFindMany) ExecInner(ctx context.Context) (
	[]InnerEvent,
	error,
) {
	var v []InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r eventToDataFindMany) Update(params ...EventSetParam) eventToDataUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Event"

	r.query.Outputs = countOutput

	var v eventToDataUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type eventToDataUpdateMany struct {
	query builder.Query
}

func (r eventToDataUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToDataUpdateMany) eventModel() {}

func (r eventToDataUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToDataUpdateMany) Tx() eventManyTxResult {
	v := NeweventManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r eventToDataFindMany) Delete() eventToDataDeleteMany {
	var v eventToDataDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Event"

	v.query.Outputs = countOutput

	return v
}

type eventToDataDeleteMany struct {
	query builder.Query
}

func (r eventToDataDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p eventToDataDeleteMany) eventModel() {}

func (r eventToDataDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToDataDeleteMany) Tx() eventManyTxResult {
	v := NeweventManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type eventToTransitionInterfaceFindUnique struct {
	query builder.Query
}

func (r eventToTransitionInterfaceFindUnique) getQuery() builder.Query {
	return r.query
}

func (r eventToTransitionInterfaceFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToTransitionInterfaceFindUnique) with()          {}
func (r eventToTransitionInterfaceFindUnique) eventModel()    {}
func (r eventToTransitionInterfaceFindUnique) eventRelation() {}

func (r eventToTransitionInterfaceFindUnique) With(params ...TransitionInterfaceRelationWith) eventToTransitionInterfaceFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventToTransitionInterfaceFindUnique) Exec(ctx context.Context) (
	*EventModel,
	error,
) {
	var v *EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventToTransitionInterfaceFindUnique) ExecInner(ctx context.Context) (
	*InnerEvent,
	error,
) {
	var v *InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventToTransitionInterfaceFindUnique) Update(params ...EventSetParam) eventToTransitionInterfaceUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Event"

	var v eventToTransitionInterfaceUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type eventToTransitionInterfaceUpdateUnique struct {
	query builder.Query
}

func (r eventToTransitionInterfaceUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToTransitionInterfaceUpdateUnique) eventModel() {}

func (r eventToTransitionInterfaceUpdateUnique) Exec(ctx context.Context) (*EventModel, error) {
	var v EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToTransitionInterfaceUpdateUnique) Tx() eventUniqueTxResult {
	v := NeweventUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r eventToTransitionInterfaceFindUnique) Delete() eventToTransitionInterfaceDeleteUnique {
	var v eventToTransitionInterfaceDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Event"

	return v
}

type eventToTransitionInterfaceDeleteUnique struct {
	query builder.Query
}

func (r eventToTransitionInterfaceDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p eventToTransitionInterfaceDeleteUnique) eventModel() {}

func (r eventToTransitionInterfaceDeleteUnique) Exec(ctx context.Context) (*EventModel, error) {
	var v EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToTransitionInterfaceDeleteUnique) Tx() eventUniqueTxResult {
	v := NeweventUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type eventToTransitionInterfaceFindFirst struct {
	query builder.Query
}

func (r eventToTransitionInterfaceFindFirst) getQuery() builder.Query {
	return r.query
}

func (r eventToTransitionInterfaceFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToTransitionInterfaceFindFirst) with()          {}
func (r eventToTransitionInterfaceFindFirst) eventModel()    {}
func (r eventToTransitionInterfaceFindFirst) eventRelation() {}

func (r eventToTransitionInterfaceFindFirst) With(params ...TransitionInterfaceRelationWith) eventToTransitionInterfaceFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventToTransitionInterfaceFindFirst) OrderBy(params ...TransitionInterfaceOrderByParam) eventToTransitionInterfaceFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r eventToTransitionInterfaceFindFirst) Skip(count int) eventToTransitionInterfaceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r eventToTransitionInterfaceFindFirst) Take(count int) eventToTransitionInterfaceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r eventToTransitionInterfaceFindFirst) Cursor(cursor EventCursorParam) eventToTransitionInterfaceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r eventToTransitionInterfaceFindFirst) Exec(ctx context.Context) (
	*EventModel,
	error,
) {
	var v *EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventToTransitionInterfaceFindFirst) ExecInner(ctx context.Context) (
	*InnerEvent,
	error,
) {
	var v *InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type eventToTransitionInterfaceFindMany struct {
	query builder.Query
}

func (r eventToTransitionInterfaceFindMany) getQuery() builder.Query {
	return r.query
}

func (r eventToTransitionInterfaceFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToTransitionInterfaceFindMany) with()          {}
func (r eventToTransitionInterfaceFindMany) eventModel()    {}
func (r eventToTransitionInterfaceFindMany) eventRelation() {}

func (r eventToTransitionInterfaceFindMany) With(params ...TransitionInterfaceRelationWith) eventToTransitionInterfaceFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventToTransitionInterfaceFindMany) OrderBy(params ...TransitionInterfaceOrderByParam) eventToTransitionInterfaceFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r eventToTransitionInterfaceFindMany) Skip(count int) eventToTransitionInterfaceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r eventToTransitionInterfaceFindMany) Take(count int) eventToTransitionInterfaceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r eventToTransitionInterfaceFindMany) Cursor(cursor EventCursorParam) eventToTransitionInterfaceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r eventToTransitionInterfaceFindMany) Exec(ctx context.Context) (
	[]EventModel,
	error,
) {
	var v []EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r eventToTransitionInterfaceFindMany) ExecInner(ctx context.Context) (
	[]InnerEvent,
	error,
) {
	var v []InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r eventToTransitionInterfaceFindMany) Update(params ...EventSetParam) eventToTransitionInterfaceUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Event"

	r.query.Outputs = countOutput

	var v eventToTransitionInterfaceUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type eventToTransitionInterfaceUpdateMany struct {
	query builder.Query
}

func (r eventToTransitionInterfaceUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r eventToTransitionInterfaceUpdateMany) eventModel() {}

func (r eventToTransitionInterfaceUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToTransitionInterfaceUpdateMany) Tx() eventManyTxResult {
	v := NeweventManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r eventToTransitionInterfaceFindMany) Delete() eventToTransitionInterfaceDeleteMany {
	var v eventToTransitionInterfaceDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Event"

	v.query.Outputs = countOutput

	return v
}

type eventToTransitionInterfaceDeleteMany struct {
	query builder.Query
}

func (r eventToTransitionInterfaceDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p eventToTransitionInterfaceDeleteMany) eventModel() {}

func (r eventToTransitionInterfaceDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventToTransitionInterfaceDeleteMany) Tx() eventManyTxResult {
	v := NeweventManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type eventFindUnique struct {
	query builder.Query
}

func (r eventFindUnique) getQuery() builder.Query {
	return r.query
}

func (r eventFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r eventFindUnique) with()          {}
func (r eventFindUnique) eventModel()    {}
func (r eventFindUnique) eventRelation() {}

func (r eventActions) FindUnique(
	params EventEqualsUniqueWhereParam,
) eventFindUnique {
	var v eventFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Event"
	v.query.Outputs = eventOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r eventFindUnique) With(params ...EventRelationWith) eventFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventFindUnique) Exec(ctx context.Context) (
	*EventModel,
	error,
) {
	var v *EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventFindUnique) ExecInner(ctx context.Context) (
	*InnerEvent,
	error,
) {
	var v *InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventFindUnique) Update(params ...EventSetParam) eventUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Event"

	var v eventUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type eventUpdateUnique struct {
	query builder.Query
}

func (r eventUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r eventUpdateUnique) eventModel() {}

func (r eventUpdateUnique) Exec(ctx context.Context) (*EventModel, error) {
	var v EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventUpdateUnique) Tx() eventUniqueTxResult {
	v := NeweventUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r eventFindUnique) Delete() eventDeleteUnique {
	var v eventDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Event"

	return v
}

type eventDeleteUnique struct {
	query builder.Query
}

func (r eventDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p eventDeleteUnique) eventModel() {}

func (r eventDeleteUnique) Exec(ctx context.Context) (*EventModel, error) {
	var v EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventDeleteUnique) Tx() eventUniqueTxResult {
	v := NeweventUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type eventFindFirst struct {
	query builder.Query
}

func (r eventFindFirst) getQuery() builder.Query {
	return r.query
}

func (r eventFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r eventFindFirst) with()          {}
func (r eventFindFirst) eventModel()    {}
func (r eventFindFirst) eventRelation() {}

func (r eventActions) FindFirst(
	params ...EventWhereParam,
) eventFindFirst {
	var v eventFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Event"
	v.query.Outputs = eventOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r eventFindFirst) With(params ...EventRelationWith) eventFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventFindFirst) OrderBy(params ...EventOrderByParam) eventFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r eventFindFirst) Skip(count int) eventFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r eventFindFirst) Take(count int) eventFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r eventFindFirst) Cursor(cursor EventCursorParam) eventFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r eventFindFirst) Exec(ctx context.Context) (
	*EventModel,
	error,
) {
	var v *EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r eventFindFirst) ExecInner(ctx context.Context) (
	*InnerEvent,
	error,
) {
	var v *InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type eventFindMany struct {
	query builder.Query
}

func (r eventFindMany) getQuery() builder.Query {
	return r.query
}

func (r eventFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r eventFindMany) with()          {}
func (r eventFindMany) eventModel()    {}
func (r eventFindMany) eventRelation() {}

func (r eventActions) FindMany(
	params ...EventWhereParam,
) eventFindMany {
	var v eventFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Event"
	v.query.Outputs = eventOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r eventFindMany) With(params ...EventRelationWith) eventFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r eventFindMany) OrderBy(params ...EventOrderByParam) eventFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r eventFindMany) Skip(count int) eventFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r eventFindMany) Take(count int) eventFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r eventFindMany) Cursor(cursor EventCursorParam) eventFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r eventFindMany) Exec(ctx context.Context) (
	[]EventModel,
	error,
) {
	var v []EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r eventFindMany) ExecInner(ctx context.Context) (
	[]InnerEvent,
	error,
) {
	var v []InnerEvent
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r eventFindMany) Update(params ...EventSetParam) eventUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Event"

	r.query.Outputs = countOutput

	var v eventUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type eventUpdateMany struct {
	query builder.Query
}

func (r eventUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r eventUpdateMany) eventModel() {}

func (r eventUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventUpdateMany) Tx() eventManyTxResult {
	v := NeweventManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r eventFindMany) Delete() eventDeleteMany {
	var v eventDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Event"

	v.query.Outputs = countOutput

	return v
}

type eventDeleteMany struct {
	query builder.Query
}

func (r eventDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p eventDeleteMany) eventModel() {}

func (r eventDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventDeleteMany) Tx() eventManyTxResult {
	v := NeweventManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type instanceToAuthorFindUnique struct {
	query builder.Query
}

func (r instanceToAuthorFindUnique) getQuery() builder.Query {
	return r.query
}

func (r instanceToAuthorFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToAuthorFindUnique) with()             {}
func (r instanceToAuthorFindUnique) instanceModel()    {}
func (r instanceToAuthorFindUnique) instanceRelation() {}

func (r instanceToAuthorFindUnique) With(params ...UserRelationWith) instanceToAuthorFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r instanceToAuthorFindUnique) Exec(ctx context.Context) (
	*InstanceModel,
	error,
) {
	var v *InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r instanceToAuthorFindUnique) ExecInner(ctx context.Context) (
	*InnerInstance,
	error,
) {
	var v *InnerInstance
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r instanceToAuthorFindUnique) Update(params ...InstanceSetParam) instanceToAuthorUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Instance"

	var v instanceToAuthorUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type instanceToAuthorUpdateUnique struct {
	query builder.Query
}

func (r instanceToAuthorUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToAuthorUpdateUnique) instanceModel() {}

func (r instanceToAuthorUpdateUnique) Exec(ctx context.Context) (*InstanceModel, error) {
	var v InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceToAuthorUpdateUnique) Tx() instanceUniqueTxResult {
	v := NewinstanceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r instanceToAuthorFindUnique) Delete() instanceToAuthorDeleteUnique {
	var v instanceToAuthorDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Instance"

	return v
}

type instanceToAuthorDeleteUnique struct {
	query builder.Query
}

func (r instanceToAuthorDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p instanceToAuthorDeleteUnique) instanceModel() {}

func (r instanceToAuthorDeleteUnique) Exec(ctx context.Context) (*InstanceModel, error) {
	var v InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceToAuthorDeleteUnique) Tx() instanceUniqueTxResult {
	v := NewinstanceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type instanceToAuthorFindFirst struct {
	query builder.Query
}

func (r instanceToAuthorFindFirst) getQuery() builder.Query {
	return r.query
}

func (r instanceToAuthorFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToAuthorFindFirst) with()             {}
func (r instanceToAuthorFindFirst) instanceModel()    {}
func (r instanceToAuthorFindFirst) instanceRelation() {}

func (r instanceToAuthorFindFirst) With(params ...UserRelationWith) instanceToAuthorFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r instanceToAuthorFindFirst) OrderBy(params ...UserOrderByParam) instanceToAuthorFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r instanceToAuthorFindFirst) Skip(count int) instanceToAuthorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r instanceToAuthorFindFirst) Take(count int) instanceToAuthorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r instanceToAuthorFindFirst) Cursor(cursor InstanceCursorParam) instanceToAuthorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r instanceToAuthorFindFirst) Exec(ctx context.Context) (
	*InstanceModel,
	error,
) {
	var v *InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r instanceToAuthorFindFirst) ExecInner(ctx context.Context) (
	*InnerInstance,
	error,
) {
	var v *InnerInstance
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type instanceToAuthorFindMany struct {
	query builder.Query
}

func (r instanceToAuthorFindMany) getQuery() builder.Query {
	return r.query
}

func (r instanceToAuthorFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToAuthorFindMany) with()             {}
func (r instanceToAuthorFindMany) instanceModel()    {}
func (r instanceToAuthorFindMany) instanceRelation() {}

func (r instanceToAuthorFindMany) With(params ...UserRelationWith) instanceToAuthorFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r instanceToAuthorFindMany) OrderBy(params ...UserOrderByParam) instanceToAuthorFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r instanceToAuthorFindMany) Skip(count int) instanceToAuthorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r instanceToAuthorFindMany) Take(count int) instanceToAuthorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r instanceToAuthorFindMany) Cursor(cursor InstanceCursorParam) instanceToAuthorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r instanceToAuthorFindMany) Exec(ctx context.Context) (
	[]InstanceModel,
	error,
) {
	var v []InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r instanceToAuthorFindMany) ExecInner(ctx context.Context) (
	[]InnerInstance,
	error,
) {
	var v []InnerInstance
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r instanceToAuthorFindMany) Update(params ...InstanceSetParam) instanceToAuthorUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Instance"

	r.query.Outputs = countOutput

	var v instanceToAuthorUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type instanceToAuthorUpdateMany struct {
	query builder.Query
}

func (r instanceToAuthorUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToAuthorUpdateMany) instanceModel() {}

func (r instanceToAuthorUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceToAuthorUpdateMany) Tx() instanceManyTxResult {
	v := NewinstanceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r instanceToAuthorFindMany) Delete() instanceToAuthorDeleteMany {
	var v instanceToAuthorDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Instance"

	v.query.Outputs = countOutput

	return v
}

type instanceToAuthorDeleteMany struct {
	query builder.Query
}

func (r instanceToAuthorDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p instanceToAuthorDeleteMany) instanceModel() {}

func (r instanceToAuthorDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceToAuthorDeleteMany) Tx() instanceManyTxResult {
	v := NewinstanceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type instanceToDeviceFindUnique struct {
	query builder.Query
}

func (r instanceToDeviceFindUnique) getQuery() builder.Query {
	return r.query
}

func (r instanceToDeviceFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToDeviceFindUnique) with()             {}
func (r instanceToDeviceFindUnique) instanceModel()    {}
func (r instanceToDeviceFindUnique) instanceRelation() {}

func (r instanceToDeviceFindUnique) With(params ...DeviceRelationWith) instanceToDeviceFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r instanceToDeviceFindUnique) Exec(ctx context.Context) (
	*InstanceModel,
	error,
) {
	var v *InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r instanceToDeviceFindUnique) ExecInner(ctx context.Context) (
	*InnerInstance,
	error,
) {
	var v *InnerInstance
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r instanceToDeviceFindUnique) Update(params ...InstanceSetParam) instanceToDeviceUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Instance"

	var v instanceToDeviceUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type instanceToDeviceUpdateUnique struct {
	query builder.Query
}

func (r instanceToDeviceUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToDeviceUpdateUnique) instanceModel() {}

func (r instanceToDeviceUpdateUnique) Exec(ctx context.Context) (*InstanceModel, error) {
	var v InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceToDeviceUpdateUnique) Tx() instanceUniqueTxResult {
	v := NewinstanceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r instanceToDeviceFindUnique) Delete() instanceToDeviceDeleteUnique {
	var v instanceToDeviceDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Instance"

	return v
}

type instanceToDeviceDeleteUnique struct {
	query builder.Query
}

func (r instanceToDeviceDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p instanceToDeviceDeleteUnique) instanceModel() {}

func (r instanceToDeviceDeleteUnique) Exec(ctx context.Context) (*InstanceModel, error) {
	var v InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceToDeviceDeleteUnique) Tx() instanceUniqueTxResult {
	v := NewinstanceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type instanceToDeviceFindFirst struct {
	query builder.Query
}

func (r instanceToDeviceFindFirst) getQuery() builder.Query {
	return r.query
}

func (r instanceToDeviceFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToDeviceFindFirst) with()             {}
func (r instanceToDeviceFindFirst) instanceModel()    {}
func (r instanceToDeviceFindFirst) instanceRelation() {}

func (r instanceToDeviceFindFirst) With(params ...DeviceRelationWith) instanceToDeviceFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r instanceToDeviceFindFirst) OrderBy(params ...DeviceOrderByParam) instanceToDeviceFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r instanceToDeviceFindFirst) Skip(count int) instanceToDeviceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r instanceToDeviceFindFirst) Take(count int) instanceToDeviceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r instanceToDeviceFindFirst) Cursor(cursor InstanceCursorParam) instanceToDeviceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r instanceToDeviceFindFirst) Exec(ctx context.Context) (
	*InstanceModel,
	error,
) {
	var v *InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r instanceToDeviceFindFirst) ExecInner(ctx context.Context) (
	*InnerInstance,
	error,
) {
	var v *InnerInstance
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type instanceToDeviceFindMany struct {
	query builder.Query
}

func (r instanceToDeviceFindMany) getQuery() builder.Query {
	return r.query
}

func (r instanceToDeviceFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToDeviceFindMany) with()             {}
func (r instanceToDeviceFindMany) instanceModel()    {}
func (r instanceToDeviceFindMany) instanceRelation() {}

func (r instanceToDeviceFindMany) With(params ...DeviceRelationWith) instanceToDeviceFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r instanceToDeviceFindMany) OrderBy(params ...DeviceOrderByParam) instanceToDeviceFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r instanceToDeviceFindMany) Skip(count int) instanceToDeviceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r instanceToDeviceFindMany) Take(count int) instanceToDeviceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r instanceToDeviceFindMany) Cursor(cursor InstanceCursorParam) instanceToDeviceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r instanceToDeviceFindMany) Exec(ctx context.Context) (
	[]InstanceModel,
	error,
) {
	var v []InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r instanceToDeviceFindMany) ExecInner(ctx context.Context) (
	[]InnerInstance,
	error,
) {
	var v []InnerInstance
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r instanceToDeviceFindMany) Update(params ...InstanceSetParam) instanceToDeviceUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Instance"

	r.query.Outputs = countOutput

	var v instanceToDeviceUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type instanceToDeviceUpdateMany struct {
	query builder.Query
}

func (r instanceToDeviceUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToDeviceUpdateMany) instanceModel() {}

func (r instanceToDeviceUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceToDeviceUpdateMany) Tx() instanceManyTxResult {
	v := NewinstanceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r instanceToDeviceFindMany) Delete() instanceToDeviceDeleteMany {
	var v instanceToDeviceDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Instance"

	v.query.Outputs = countOutput

	return v
}

type instanceToDeviceDeleteMany struct {
	query builder.Query
}

func (r instanceToDeviceDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p instanceToDeviceDeleteMany) instanceModel() {}

func (r instanceToDeviceDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceToDeviceDeleteMany) Tx() instanceManyTxResult {
	v := NewinstanceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type instanceToDataFindUnique struct {
	query builder.Query
}

func (r instanceToDataFindUnique) getQuery() builder.Query {
	return r.query
}

func (r instanceToDataFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToDataFindUnique) with()             {}
func (r instanceToDataFindUnique) instanceModel()    {}
func (r instanceToDataFindUnique) instanceRelation() {}

func (r instanceToDataFindUnique) With(params ...DatumRelationWith) instanceToDataFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r instanceToDataFindUnique) Exec(ctx context.Context) (
	*InstanceModel,
	error,
) {
	var v *InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r instanceToDataFindUnique) ExecInner(ctx context.Context) (
	*InnerInstance,
	error,
) {
	var v *InnerInstance
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r instanceToDataFindUnique) Update(params ...InstanceSetParam) instanceToDataUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Instance"

	var v instanceToDataUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type instanceToDataUpdateUnique struct {
	query builder.Query
}

func (r instanceToDataUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToDataUpdateUnique) instanceModel() {}

func (r instanceToDataUpdateUnique) Exec(ctx context.Context) (*InstanceModel, error) {
	var v InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceToDataUpdateUnique) Tx() instanceUniqueTxResult {
	v := NewinstanceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r instanceToDataFindUnique) Delete() instanceToDataDeleteUnique {
	var v instanceToDataDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Instance"

	return v
}

type instanceToDataDeleteUnique struct {
	query builder.Query
}

func (r instanceToDataDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p instanceToDataDeleteUnique) instanceModel() {}

func (r instanceToDataDeleteUnique) Exec(ctx context.Context) (*InstanceModel, error) {
	var v InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceToDataDeleteUnique) Tx() instanceUniqueTxResult {
	v := NewinstanceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type instanceToDataFindFirst struct {
	query builder.Query
}

func (r instanceToDataFindFirst) getQuery() builder.Query {
	return r.query
}

func (r instanceToDataFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToDataFindFirst) with()             {}
func (r instanceToDataFindFirst) instanceModel()    {}
func (r instanceToDataFindFirst) instanceRelation() {}

func (r instanceToDataFindFirst) With(params ...DatumRelationWith) instanceToDataFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r instanceToDataFindFirst) OrderBy(params ...DatumOrderByParam) instanceToDataFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r instanceToDataFindFirst) Skip(count int) instanceToDataFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r instanceToDataFindFirst) Take(count int) instanceToDataFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r instanceToDataFindFirst) Cursor(cursor InstanceCursorParam) instanceToDataFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r instanceToDataFindFirst) Exec(ctx context.Context) (
	*InstanceModel,
	error,
) {
	var v *InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r instanceToDataFindFirst) ExecInner(ctx context.Context) (
	*InnerInstance,
	error,
) {
	var v *InnerInstance
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type instanceToDataFindMany struct {
	query builder.Query
}

func (r instanceToDataFindMany) getQuery() builder.Query {
	return r.query
}

func (r instanceToDataFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToDataFindMany) with()             {}
func (r instanceToDataFindMany) instanceModel()    {}
func (r instanceToDataFindMany) instanceRelation() {}

func (r instanceToDataFindMany) With(params ...DatumRelationWith) instanceToDataFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r instanceToDataFindMany) OrderBy(params ...DatumOrderByParam) instanceToDataFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r instanceToDataFindMany) Skip(count int) instanceToDataFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r instanceToDataFindMany) Take(count int) instanceToDataFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r instanceToDataFindMany) Cursor(cursor InstanceCursorParam) instanceToDataFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r instanceToDataFindMany) Exec(ctx context.Context) (
	[]InstanceModel,
	error,
) {
	var v []InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r instanceToDataFindMany) ExecInner(ctx context.Context) (
	[]InnerInstance,
	error,
) {
	var v []InnerInstance
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r instanceToDataFindMany) Update(params ...InstanceSetParam) instanceToDataUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Instance"

	r.query.Outputs = countOutput

	var v instanceToDataUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type instanceToDataUpdateMany struct {
	query builder.Query
}

func (r instanceToDataUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToDataUpdateMany) instanceModel() {}

func (r instanceToDataUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceToDataUpdateMany) Tx() instanceManyTxResult {
	v := NewinstanceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r instanceToDataFindMany) Delete() instanceToDataDeleteMany {
	var v instanceToDataDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Instance"

	v.query.Outputs = countOutput

	return v
}

type instanceToDataDeleteMany struct {
	query builder.Query
}

func (r instanceToDataDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p instanceToDataDeleteMany) instanceModel() {}

func (r instanceToDataDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceToDataDeleteMany) Tx() instanceManyTxResult {
	v := NewinstanceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type instanceToSessionsFindUnique struct {
	query builder.Query
}

func (r instanceToSessionsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r instanceToSessionsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToSessionsFindUnique) with()             {}
func (r instanceToSessionsFindUnique) instanceModel()    {}
func (r instanceToSessionsFindUnique) instanceRelation() {}

func (r instanceToSessionsFindUnique) With(params ...SessionRelationWith) instanceToSessionsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r instanceToSessionsFindUnique) Exec(ctx context.Context) (
	*InstanceModel,
	error,
) {
	var v *InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r instanceToSessionsFindUnique) ExecInner(ctx context.Context) (
	*InnerInstance,
	error,
) {
	var v *InnerInstance
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r instanceToSessionsFindUnique) Update(params ...InstanceSetParam) instanceToSessionsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Instance"

	var v instanceToSessionsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type instanceToSessionsUpdateUnique struct {
	query builder.Query
}

func (r instanceToSessionsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToSessionsUpdateUnique) instanceModel() {}

func (r instanceToSessionsUpdateUnique) Exec(ctx context.Context) (*InstanceModel, error) {
	var v InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceToSessionsUpdateUnique) Tx() instanceUniqueTxResult {
	v := NewinstanceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r instanceToSessionsFindUnique) Delete() instanceToSessionsDeleteUnique {
	var v instanceToSessionsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Instance"

	return v
}

type instanceToSessionsDeleteUnique struct {
	query builder.Query
}

func (r instanceToSessionsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p instanceToSessionsDeleteUnique) instanceModel() {}

func (r instanceToSessionsDeleteUnique) Exec(ctx context.Context) (*InstanceModel, error) {
	var v InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceToSessionsDeleteUnique) Tx() instanceUniqueTxResult {
	v := NewinstanceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type instanceToSessionsFindFirst struct {
	query builder.Query
}

func (r instanceToSessionsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r instanceToSessionsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToSessionsFindFirst) with()             {}
func (r instanceToSessionsFindFirst) instanceModel()    {}
func (r instanceToSessionsFindFirst) instanceRelation() {}

func (r instanceToSessionsFindFirst) With(params ...SessionRelationWith) instanceToSessionsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r instanceToSessionsFindFirst) OrderBy(params ...SessionOrderByParam) instanceToSessionsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r instanceToSessionsFindFirst) Skip(count int) instanceToSessionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r instanceToSessionsFindFirst) Take(count int) instanceToSessionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r instanceToSessionsFindFirst) Cursor(cursor InstanceCursorParam) instanceToSessionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r instanceToSessionsFindFirst) Exec(ctx context.Context) (
	*InstanceModel,
	error,
) {
	var v *InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r instanceToSessionsFindFirst) ExecInner(ctx context.Context) (
	*InnerInstance,
	error,
) {
	var v *InnerInstance
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type instanceToSessionsFindMany struct {
	query builder.Query
}

func (r instanceToSessionsFindMany) getQuery() builder.Query {
	return r.query
}

func (r instanceToSessionsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToSessionsFindMany) with()             {}
func (r instanceToSessionsFindMany) instanceModel()    {}
func (r instanceToSessionsFindMany) instanceRelation() {}

func (r instanceToSessionsFindMany) With(params ...SessionRelationWith) instanceToSessionsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r instanceToSessionsFindMany) OrderBy(params ...SessionOrderByParam) instanceToSessionsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r instanceToSessionsFindMany) Skip(count int) instanceToSessionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r instanceToSessionsFindMany) Take(count int) instanceToSessionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r instanceToSessionsFindMany) Cursor(cursor InstanceCursorParam) instanceToSessionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r instanceToSessionsFindMany) Exec(ctx context.Context) (
	[]InstanceModel,
	error,
) {
	var v []InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r instanceToSessionsFindMany) ExecInner(ctx context.Context) (
	[]InnerInstance,
	error,
) {
	var v []InnerInstance
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r instanceToSessionsFindMany) Update(params ...InstanceSetParam) instanceToSessionsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Instance"

	r.query.Outputs = countOutput

	var v instanceToSessionsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type instanceToSessionsUpdateMany struct {
	query builder.Query
}

func (r instanceToSessionsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceToSessionsUpdateMany) instanceModel() {}

func (r instanceToSessionsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceToSessionsUpdateMany) Tx() instanceManyTxResult {
	v := NewinstanceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r instanceToSessionsFindMany) Delete() instanceToSessionsDeleteMany {
	var v instanceToSessionsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Instance"

	v.query.Outputs = countOutput

	return v
}

type instanceToSessionsDeleteMany struct {
	query builder.Query
}

func (r instanceToSessionsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p instanceToSessionsDeleteMany) instanceModel() {}

func (r instanceToSessionsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceToSessionsDeleteMany) Tx() instanceManyTxResult {
	v := NewinstanceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type instanceFindUnique struct {
	query builder.Query
}

func (r instanceFindUnique) getQuery() builder.Query {
	return r.query
}

func (r instanceFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceFindUnique) with()             {}
func (r instanceFindUnique) instanceModel()    {}
func (r instanceFindUnique) instanceRelation() {}

func (r instanceActions) FindUnique(
	params InstanceEqualsUniqueWhereParam,
) instanceFindUnique {
	var v instanceFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Instance"
	v.query.Outputs = instanceOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r instanceFindUnique) With(params ...InstanceRelationWith) instanceFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r instanceFindUnique) Exec(ctx context.Context) (
	*InstanceModel,
	error,
) {
	var v *InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r instanceFindUnique) ExecInner(ctx context.Context) (
	*InnerInstance,
	error,
) {
	var v *InnerInstance
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r instanceFindUnique) Update(params ...InstanceSetParam) instanceUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Instance"

	var v instanceUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type instanceUpdateUnique struct {
	query builder.Query
}

func (r instanceUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceUpdateUnique) instanceModel() {}

func (r instanceUpdateUnique) Exec(ctx context.Context) (*InstanceModel, error) {
	var v InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceUpdateUnique) Tx() instanceUniqueTxResult {
	v := NewinstanceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r instanceFindUnique) Delete() instanceDeleteUnique {
	var v instanceDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Instance"

	return v
}

type instanceDeleteUnique struct {
	query builder.Query
}

func (r instanceDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p instanceDeleteUnique) instanceModel() {}

func (r instanceDeleteUnique) Exec(ctx context.Context) (*InstanceModel, error) {
	var v InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceDeleteUnique) Tx() instanceUniqueTxResult {
	v := NewinstanceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type instanceFindFirst struct {
	query builder.Query
}

func (r instanceFindFirst) getQuery() builder.Query {
	return r.query
}

func (r instanceFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceFindFirst) with()             {}
func (r instanceFindFirst) instanceModel()    {}
func (r instanceFindFirst) instanceRelation() {}

func (r instanceActions) FindFirst(
	params ...InstanceWhereParam,
) instanceFindFirst {
	var v instanceFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Instance"
	v.query.Outputs = instanceOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r instanceFindFirst) With(params ...InstanceRelationWith) instanceFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r instanceFindFirst) OrderBy(params ...InstanceOrderByParam) instanceFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r instanceFindFirst) Skip(count int) instanceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r instanceFindFirst) Take(count int) instanceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r instanceFindFirst) Cursor(cursor InstanceCursorParam) instanceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r instanceFindFirst) Exec(ctx context.Context) (
	*InstanceModel,
	error,
) {
	var v *InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r instanceFindFirst) ExecInner(ctx context.Context) (
	*InnerInstance,
	error,
) {
	var v *InnerInstance
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type instanceFindMany struct {
	query builder.Query
}

func (r instanceFindMany) getQuery() builder.Query {
	return r.query
}

func (r instanceFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceFindMany) with()             {}
func (r instanceFindMany) instanceModel()    {}
func (r instanceFindMany) instanceRelation() {}

func (r instanceActions) FindMany(
	params ...InstanceWhereParam,
) instanceFindMany {
	var v instanceFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Instance"
	v.query.Outputs = instanceOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r instanceFindMany) With(params ...InstanceRelationWith) instanceFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r instanceFindMany) OrderBy(params ...InstanceOrderByParam) instanceFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r instanceFindMany) Skip(count int) instanceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r instanceFindMany) Take(count int) instanceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r instanceFindMany) Cursor(cursor InstanceCursorParam) instanceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r instanceFindMany) Exec(ctx context.Context) (
	[]InstanceModel,
	error,
) {
	var v []InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r instanceFindMany) ExecInner(ctx context.Context) (
	[]InnerInstance,
	error,
) {
	var v []InnerInstance
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r instanceFindMany) Update(params ...InstanceSetParam) instanceUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Instance"

	r.query.Outputs = countOutput

	var v instanceUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type instanceUpdateMany struct {
	query builder.Query
}

func (r instanceUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceUpdateMany) instanceModel() {}

func (r instanceUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceUpdateMany) Tx() instanceManyTxResult {
	v := NewinstanceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r instanceFindMany) Delete() instanceDeleteMany {
	var v instanceDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Instance"

	v.query.Outputs = countOutput

	return v
}

type instanceDeleteMany struct {
	query builder.Query
}

func (r instanceDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p instanceDeleteMany) instanceModel() {}

func (r instanceDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceDeleteMany) Tx() instanceManyTxResult {
	v := NewinstanceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type deviceToAuthorFindUnique struct {
	query builder.Query
}

func (r deviceToAuthorFindUnique) getQuery() builder.Query {
	return r.query
}

func (r deviceToAuthorFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToAuthorFindUnique) with()           {}
func (r deviceToAuthorFindUnique) deviceModel()    {}
func (r deviceToAuthorFindUnique) deviceRelation() {}

func (r deviceToAuthorFindUnique) With(params ...UserRelationWith) deviceToAuthorFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r deviceToAuthorFindUnique) Exec(ctx context.Context) (
	*DeviceModel,
	error,
) {
	var v *DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r deviceToAuthorFindUnique) ExecInner(ctx context.Context) (
	*InnerDevice,
	error,
) {
	var v *InnerDevice
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r deviceToAuthorFindUnique) Update(params ...DeviceSetParam) deviceToAuthorUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Device"

	var v deviceToAuthorUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type deviceToAuthorUpdateUnique struct {
	query builder.Query
}

func (r deviceToAuthorUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToAuthorUpdateUnique) deviceModel() {}

func (r deviceToAuthorUpdateUnique) Exec(ctx context.Context) (*DeviceModel, error) {
	var v DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceToAuthorUpdateUnique) Tx() deviceUniqueTxResult {
	v := NewdeviceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r deviceToAuthorFindUnique) Delete() deviceToAuthorDeleteUnique {
	var v deviceToAuthorDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Device"

	return v
}

type deviceToAuthorDeleteUnique struct {
	query builder.Query
}

func (r deviceToAuthorDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p deviceToAuthorDeleteUnique) deviceModel() {}

func (r deviceToAuthorDeleteUnique) Exec(ctx context.Context) (*DeviceModel, error) {
	var v DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceToAuthorDeleteUnique) Tx() deviceUniqueTxResult {
	v := NewdeviceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type deviceToAuthorFindFirst struct {
	query builder.Query
}

func (r deviceToAuthorFindFirst) getQuery() builder.Query {
	return r.query
}

func (r deviceToAuthorFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToAuthorFindFirst) with()           {}
func (r deviceToAuthorFindFirst) deviceModel()    {}
func (r deviceToAuthorFindFirst) deviceRelation() {}

func (r deviceToAuthorFindFirst) With(params ...UserRelationWith) deviceToAuthorFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r deviceToAuthorFindFirst) OrderBy(params ...UserOrderByParam) deviceToAuthorFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r deviceToAuthorFindFirst) Skip(count int) deviceToAuthorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r deviceToAuthorFindFirst) Take(count int) deviceToAuthorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r deviceToAuthorFindFirst) Cursor(cursor DeviceCursorParam) deviceToAuthorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r deviceToAuthorFindFirst) Exec(ctx context.Context) (
	*DeviceModel,
	error,
) {
	var v *DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r deviceToAuthorFindFirst) ExecInner(ctx context.Context) (
	*InnerDevice,
	error,
) {
	var v *InnerDevice
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type deviceToAuthorFindMany struct {
	query builder.Query
}

func (r deviceToAuthorFindMany) getQuery() builder.Query {
	return r.query
}

func (r deviceToAuthorFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToAuthorFindMany) with()           {}
func (r deviceToAuthorFindMany) deviceModel()    {}
func (r deviceToAuthorFindMany) deviceRelation() {}

func (r deviceToAuthorFindMany) With(params ...UserRelationWith) deviceToAuthorFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r deviceToAuthorFindMany) OrderBy(params ...UserOrderByParam) deviceToAuthorFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r deviceToAuthorFindMany) Skip(count int) deviceToAuthorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r deviceToAuthorFindMany) Take(count int) deviceToAuthorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r deviceToAuthorFindMany) Cursor(cursor DeviceCursorParam) deviceToAuthorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r deviceToAuthorFindMany) Exec(ctx context.Context) (
	[]DeviceModel,
	error,
) {
	var v []DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r deviceToAuthorFindMany) ExecInner(ctx context.Context) (
	[]InnerDevice,
	error,
) {
	var v []InnerDevice
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r deviceToAuthorFindMany) Update(params ...DeviceSetParam) deviceToAuthorUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Device"

	r.query.Outputs = countOutput

	var v deviceToAuthorUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type deviceToAuthorUpdateMany struct {
	query builder.Query
}

func (r deviceToAuthorUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToAuthorUpdateMany) deviceModel() {}

func (r deviceToAuthorUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceToAuthorUpdateMany) Tx() deviceManyTxResult {
	v := NewdeviceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r deviceToAuthorFindMany) Delete() deviceToAuthorDeleteMany {
	var v deviceToAuthorDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Device"

	v.query.Outputs = countOutput

	return v
}

type deviceToAuthorDeleteMany struct {
	query builder.Query
}

func (r deviceToAuthorDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p deviceToAuthorDeleteMany) deviceModel() {}

func (r deviceToAuthorDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceToAuthorDeleteMany) Tx() deviceManyTxResult {
	v := NewdeviceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type deviceToInstancesFindUnique struct {
	query builder.Query
}

func (r deviceToInstancesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r deviceToInstancesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToInstancesFindUnique) with()           {}
func (r deviceToInstancesFindUnique) deviceModel()    {}
func (r deviceToInstancesFindUnique) deviceRelation() {}

func (r deviceToInstancesFindUnique) With(params ...InstanceRelationWith) deviceToInstancesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r deviceToInstancesFindUnique) Exec(ctx context.Context) (
	*DeviceModel,
	error,
) {
	var v *DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r deviceToInstancesFindUnique) ExecInner(ctx context.Context) (
	*InnerDevice,
	error,
) {
	var v *InnerDevice
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r deviceToInstancesFindUnique) Update(params ...DeviceSetParam) deviceToInstancesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Device"

	var v deviceToInstancesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type deviceToInstancesUpdateUnique struct {
	query builder.Query
}

func (r deviceToInstancesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToInstancesUpdateUnique) deviceModel() {}

func (r deviceToInstancesUpdateUnique) Exec(ctx context.Context) (*DeviceModel, error) {
	var v DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceToInstancesUpdateUnique) Tx() deviceUniqueTxResult {
	v := NewdeviceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r deviceToInstancesFindUnique) Delete() deviceToInstancesDeleteUnique {
	var v deviceToInstancesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Device"

	return v
}

type deviceToInstancesDeleteUnique struct {
	query builder.Query
}

func (r deviceToInstancesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p deviceToInstancesDeleteUnique) deviceModel() {}

func (r deviceToInstancesDeleteUnique) Exec(ctx context.Context) (*DeviceModel, error) {
	var v DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceToInstancesDeleteUnique) Tx() deviceUniqueTxResult {
	v := NewdeviceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type deviceToInstancesFindFirst struct {
	query builder.Query
}

func (r deviceToInstancesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r deviceToInstancesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToInstancesFindFirst) with()           {}
func (r deviceToInstancesFindFirst) deviceModel()    {}
func (r deviceToInstancesFindFirst) deviceRelation() {}

func (r deviceToInstancesFindFirst) With(params ...InstanceRelationWith) deviceToInstancesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r deviceToInstancesFindFirst) OrderBy(params ...InstanceOrderByParam) deviceToInstancesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r deviceToInstancesFindFirst) Skip(count int) deviceToInstancesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r deviceToInstancesFindFirst) Take(count int) deviceToInstancesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r deviceToInstancesFindFirst) Cursor(cursor DeviceCursorParam) deviceToInstancesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r deviceToInstancesFindFirst) Exec(ctx context.Context) (
	*DeviceModel,
	error,
) {
	var v *DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r deviceToInstancesFindFirst) ExecInner(ctx context.Context) (
	*InnerDevice,
	error,
) {
	var v *InnerDevice
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type deviceToInstancesFindMany struct {
	query builder.Query
}

func (r deviceToInstancesFindMany) getQuery() builder.Query {
	return r.query
}

func (r deviceToInstancesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToInstancesFindMany) with()           {}
func (r deviceToInstancesFindMany) deviceModel()    {}
func (r deviceToInstancesFindMany) deviceRelation() {}

func (r deviceToInstancesFindMany) With(params ...InstanceRelationWith) deviceToInstancesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r deviceToInstancesFindMany) OrderBy(params ...InstanceOrderByParam) deviceToInstancesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r deviceToInstancesFindMany) Skip(count int) deviceToInstancesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r deviceToInstancesFindMany) Take(count int) deviceToInstancesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r deviceToInstancesFindMany) Cursor(cursor DeviceCursorParam) deviceToInstancesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r deviceToInstancesFindMany) Exec(ctx context.Context) (
	[]DeviceModel,
	error,
) {
	var v []DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r deviceToInstancesFindMany) ExecInner(ctx context.Context) (
	[]InnerDevice,
	error,
) {
	var v []InnerDevice
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r deviceToInstancesFindMany) Update(params ...DeviceSetParam) deviceToInstancesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Device"

	r.query.Outputs = countOutput

	var v deviceToInstancesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type deviceToInstancesUpdateMany struct {
	query builder.Query
}

func (r deviceToInstancesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToInstancesUpdateMany) deviceModel() {}

func (r deviceToInstancesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceToInstancesUpdateMany) Tx() deviceManyTxResult {
	v := NewdeviceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r deviceToInstancesFindMany) Delete() deviceToInstancesDeleteMany {
	var v deviceToInstancesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Device"

	v.query.Outputs = countOutput

	return v
}

type deviceToInstancesDeleteMany struct {
	query builder.Query
}

func (r deviceToInstancesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p deviceToInstancesDeleteMany) deviceModel() {}

func (r deviceToInstancesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceToInstancesDeleteMany) Tx() deviceManyTxResult {
	v := NewdeviceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type deviceToNetsFindUnique struct {
	query builder.Query
}

func (r deviceToNetsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r deviceToNetsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToNetsFindUnique) with()           {}
func (r deviceToNetsFindUnique) deviceModel()    {}
func (r deviceToNetsFindUnique) deviceRelation() {}

func (r deviceToNetsFindUnique) With(params ...DevicesOnNetsRelationWith) deviceToNetsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r deviceToNetsFindUnique) Exec(ctx context.Context) (
	*DeviceModel,
	error,
) {
	var v *DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r deviceToNetsFindUnique) ExecInner(ctx context.Context) (
	*InnerDevice,
	error,
) {
	var v *InnerDevice
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r deviceToNetsFindUnique) Update(params ...DeviceSetParam) deviceToNetsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Device"

	var v deviceToNetsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type deviceToNetsUpdateUnique struct {
	query builder.Query
}

func (r deviceToNetsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToNetsUpdateUnique) deviceModel() {}

func (r deviceToNetsUpdateUnique) Exec(ctx context.Context) (*DeviceModel, error) {
	var v DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceToNetsUpdateUnique) Tx() deviceUniqueTxResult {
	v := NewdeviceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r deviceToNetsFindUnique) Delete() deviceToNetsDeleteUnique {
	var v deviceToNetsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Device"

	return v
}

type deviceToNetsDeleteUnique struct {
	query builder.Query
}

func (r deviceToNetsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p deviceToNetsDeleteUnique) deviceModel() {}

func (r deviceToNetsDeleteUnique) Exec(ctx context.Context) (*DeviceModel, error) {
	var v DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceToNetsDeleteUnique) Tx() deviceUniqueTxResult {
	v := NewdeviceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type deviceToNetsFindFirst struct {
	query builder.Query
}

func (r deviceToNetsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r deviceToNetsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToNetsFindFirst) with()           {}
func (r deviceToNetsFindFirst) deviceModel()    {}
func (r deviceToNetsFindFirst) deviceRelation() {}

func (r deviceToNetsFindFirst) With(params ...DevicesOnNetsRelationWith) deviceToNetsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r deviceToNetsFindFirst) OrderBy(params ...DevicesOnNetsOrderByParam) deviceToNetsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r deviceToNetsFindFirst) Skip(count int) deviceToNetsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r deviceToNetsFindFirst) Take(count int) deviceToNetsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r deviceToNetsFindFirst) Cursor(cursor DeviceCursorParam) deviceToNetsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r deviceToNetsFindFirst) Exec(ctx context.Context) (
	*DeviceModel,
	error,
) {
	var v *DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r deviceToNetsFindFirst) ExecInner(ctx context.Context) (
	*InnerDevice,
	error,
) {
	var v *InnerDevice
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type deviceToNetsFindMany struct {
	query builder.Query
}

func (r deviceToNetsFindMany) getQuery() builder.Query {
	return r.query
}

func (r deviceToNetsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToNetsFindMany) with()           {}
func (r deviceToNetsFindMany) deviceModel()    {}
func (r deviceToNetsFindMany) deviceRelation() {}

func (r deviceToNetsFindMany) With(params ...DevicesOnNetsRelationWith) deviceToNetsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r deviceToNetsFindMany) OrderBy(params ...DevicesOnNetsOrderByParam) deviceToNetsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r deviceToNetsFindMany) Skip(count int) deviceToNetsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r deviceToNetsFindMany) Take(count int) deviceToNetsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r deviceToNetsFindMany) Cursor(cursor DeviceCursorParam) deviceToNetsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r deviceToNetsFindMany) Exec(ctx context.Context) (
	[]DeviceModel,
	error,
) {
	var v []DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r deviceToNetsFindMany) ExecInner(ctx context.Context) (
	[]InnerDevice,
	error,
) {
	var v []InnerDevice
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r deviceToNetsFindMany) Update(params ...DeviceSetParam) deviceToNetsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Device"

	r.query.Outputs = countOutput

	var v deviceToNetsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type deviceToNetsUpdateMany struct {
	query builder.Query
}

func (r deviceToNetsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToNetsUpdateMany) deviceModel() {}

func (r deviceToNetsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceToNetsUpdateMany) Tx() deviceManyTxResult {
	v := NewdeviceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r deviceToNetsFindMany) Delete() deviceToNetsDeleteMany {
	var v deviceToNetsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Device"

	v.query.Outputs = countOutput

	return v
}

type deviceToNetsDeleteMany struct {
	query builder.Query
}

func (r deviceToNetsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p deviceToNetsDeleteMany) deviceModel() {}

func (r deviceToNetsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceToNetsDeleteMany) Tx() deviceManyTxResult {
	v := NewdeviceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type deviceToActionsFindUnique struct {
	query builder.Query
}

func (r deviceToActionsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r deviceToActionsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToActionsFindUnique) with()           {}
func (r deviceToActionsFindUnique) deviceModel()    {}
func (r deviceToActionsFindUnique) deviceRelation() {}

func (r deviceToActionsFindUnique) With(params ...ActionRelationWith) deviceToActionsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r deviceToActionsFindUnique) Exec(ctx context.Context) (
	*DeviceModel,
	error,
) {
	var v *DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r deviceToActionsFindUnique) ExecInner(ctx context.Context) (
	*InnerDevice,
	error,
) {
	var v *InnerDevice
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r deviceToActionsFindUnique) Update(params ...DeviceSetParam) deviceToActionsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Device"

	var v deviceToActionsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type deviceToActionsUpdateUnique struct {
	query builder.Query
}

func (r deviceToActionsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToActionsUpdateUnique) deviceModel() {}

func (r deviceToActionsUpdateUnique) Exec(ctx context.Context) (*DeviceModel, error) {
	var v DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceToActionsUpdateUnique) Tx() deviceUniqueTxResult {
	v := NewdeviceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r deviceToActionsFindUnique) Delete() deviceToActionsDeleteUnique {
	var v deviceToActionsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Device"

	return v
}

type deviceToActionsDeleteUnique struct {
	query builder.Query
}

func (r deviceToActionsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p deviceToActionsDeleteUnique) deviceModel() {}

func (r deviceToActionsDeleteUnique) Exec(ctx context.Context) (*DeviceModel, error) {
	var v DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceToActionsDeleteUnique) Tx() deviceUniqueTxResult {
	v := NewdeviceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type deviceToActionsFindFirst struct {
	query builder.Query
}

func (r deviceToActionsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r deviceToActionsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToActionsFindFirst) with()           {}
func (r deviceToActionsFindFirst) deviceModel()    {}
func (r deviceToActionsFindFirst) deviceRelation() {}

func (r deviceToActionsFindFirst) With(params ...ActionRelationWith) deviceToActionsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r deviceToActionsFindFirst) OrderBy(params ...ActionOrderByParam) deviceToActionsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r deviceToActionsFindFirst) Skip(count int) deviceToActionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r deviceToActionsFindFirst) Take(count int) deviceToActionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r deviceToActionsFindFirst) Cursor(cursor DeviceCursorParam) deviceToActionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r deviceToActionsFindFirst) Exec(ctx context.Context) (
	*DeviceModel,
	error,
) {
	var v *DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r deviceToActionsFindFirst) ExecInner(ctx context.Context) (
	*InnerDevice,
	error,
) {
	var v *InnerDevice
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type deviceToActionsFindMany struct {
	query builder.Query
}

func (r deviceToActionsFindMany) getQuery() builder.Query {
	return r.query
}

func (r deviceToActionsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToActionsFindMany) with()           {}
func (r deviceToActionsFindMany) deviceModel()    {}
func (r deviceToActionsFindMany) deviceRelation() {}

func (r deviceToActionsFindMany) With(params ...ActionRelationWith) deviceToActionsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r deviceToActionsFindMany) OrderBy(params ...ActionOrderByParam) deviceToActionsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r deviceToActionsFindMany) Skip(count int) deviceToActionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r deviceToActionsFindMany) Take(count int) deviceToActionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r deviceToActionsFindMany) Cursor(cursor DeviceCursorParam) deviceToActionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r deviceToActionsFindMany) Exec(ctx context.Context) (
	[]DeviceModel,
	error,
) {
	var v []DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r deviceToActionsFindMany) ExecInner(ctx context.Context) (
	[]InnerDevice,
	error,
) {
	var v []InnerDevice
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r deviceToActionsFindMany) Update(params ...DeviceSetParam) deviceToActionsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Device"

	r.query.Outputs = countOutput

	var v deviceToActionsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type deviceToActionsUpdateMany struct {
	query builder.Query
}

func (r deviceToActionsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceToActionsUpdateMany) deviceModel() {}

func (r deviceToActionsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceToActionsUpdateMany) Tx() deviceManyTxResult {
	v := NewdeviceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r deviceToActionsFindMany) Delete() deviceToActionsDeleteMany {
	var v deviceToActionsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Device"

	v.query.Outputs = countOutput

	return v
}

type deviceToActionsDeleteMany struct {
	query builder.Query
}

func (r deviceToActionsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p deviceToActionsDeleteMany) deviceModel() {}

func (r deviceToActionsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceToActionsDeleteMany) Tx() deviceManyTxResult {
	v := NewdeviceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type deviceFindUnique struct {
	query builder.Query
}

func (r deviceFindUnique) getQuery() builder.Query {
	return r.query
}

func (r deviceFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceFindUnique) with()           {}
func (r deviceFindUnique) deviceModel()    {}
func (r deviceFindUnique) deviceRelation() {}

func (r deviceActions) FindUnique(
	params DeviceEqualsUniqueWhereParam,
) deviceFindUnique {
	var v deviceFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Device"
	v.query.Outputs = deviceOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r deviceFindUnique) With(params ...DeviceRelationWith) deviceFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r deviceFindUnique) Exec(ctx context.Context) (
	*DeviceModel,
	error,
) {
	var v *DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r deviceFindUnique) ExecInner(ctx context.Context) (
	*InnerDevice,
	error,
) {
	var v *InnerDevice
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r deviceFindUnique) Update(params ...DeviceSetParam) deviceUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Device"

	var v deviceUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type deviceUpdateUnique struct {
	query builder.Query
}

func (r deviceUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceUpdateUnique) deviceModel() {}

func (r deviceUpdateUnique) Exec(ctx context.Context) (*DeviceModel, error) {
	var v DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceUpdateUnique) Tx() deviceUniqueTxResult {
	v := NewdeviceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r deviceFindUnique) Delete() deviceDeleteUnique {
	var v deviceDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Device"

	return v
}

type deviceDeleteUnique struct {
	query builder.Query
}

func (r deviceDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p deviceDeleteUnique) deviceModel() {}

func (r deviceDeleteUnique) Exec(ctx context.Context) (*DeviceModel, error) {
	var v DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceDeleteUnique) Tx() deviceUniqueTxResult {
	v := NewdeviceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type deviceFindFirst struct {
	query builder.Query
}

func (r deviceFindFirst) getQuery() builder.Query {
	return r.query
}

func (r deviceFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceFindFirst) with()           {}
func (r deviceFindFirst) deviceModel()    {}
func (r deviceFindFirst) deviceRelation() {}

func (r deviceActions) FindFirst(
	params ...DeviceWhereParam,
) deviceFindFirst {
	var v deviceFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Device"
	v.query.Outputs = deviceOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r deviceFindFirst) With(params ...DeviceRelationWith) deviceFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r deviceFindFirst) OrderBy(params ...DeviceOrderByParam) deviceFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r deviceFindFirst) Skip(count int) deviceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r deviceFindFirst) Take(count int) deviceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r deviceFindFirst) Cursor(cursor DeviceCursorParam) deviceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r deviceFindFirst) Exec(ctx context.Context) (
	*DeviceModel,
	error,
) {
	var v *DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r deviceFindFirst) ExecInner(ctx context.Context) (
	*InnerDevice,
	error,
) {
	var v *InnerDevice
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type deviceFindMany struct {
	query builder.Query
}

func (r deviceFindMany) getQuery() builder.Query {
	return r.query
}

func (r deviceFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceFindMany) with()           {}
func (r deviceFindMany) deviceModel()    {}
func (r deviceFindMany) deviceRelation() {}

func (r deviceActions) FindMany(
	params ...DeviceWhereParam,
) deviceFindMany {
	var v deviceFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Device"
	v.query.Outputs = deviceOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r deviceFindMany) With(params ...DeviceRelationWith) deviceFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r deviceFindMany) OrderBy(params ...DeviceOrderByParam) deviceFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r deviceFindMany) Skip(count int) deviceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r deviceFindMany) Take(count int) deviceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r deviceFindMany) Cursor(cursor DeviceCursorParam) deviceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r deviceFindMany) Exec(ctx context.Context) (
	[]DeviceModel,
	error,
) {
	var v []DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r deviceFindMany) ExecInner(ctx context.Context) (
	[]InnerDevice,
	error,
) {
	var v []InnerDevice
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r deviceFindMany) Update(params ...DeviceSetParam) deviceUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Device"

	r.query.Outputs = countOutput

	var v deviceUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type deviceUpdateMany struct {
	query builder.Query
}

func (r deviceUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceUpdateMany) deviceModel() {}

func (r deviceUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceUpdateMany) Tx() deviceManyTxResult {
	v := NewdeviceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r deviceFindMany) Delete() deviceDeleteMany {
	var v deviceDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Device"

	v.query.Outputs = countOutput

	return v
}

type deviceDeleteMany struct {
	query builder.Query
}

func (r deviceDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p deviceDeleteMany) deviceModel() {}

func (r deviceDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceDeleteMany) Tx() deviceManyTxResult {
	v := NewdeviceManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type constantToActionFindUnique struct {
	query builder.Query
}

func (r constantToActionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r constantToActionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r constantToActionFindUnique) with()             {}
func (r constantToActionFindUnique) constantModel()    {}
func (r constantToActionFindUnique) constantRelation() {}

func (r constantToActionFindUnique) With(params ...ActionRelationWith) constantToActionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r constantToActionFindUnique) Exec(ctx context.Context) (
	*ConstantModel,
	error,
) {
	var v *ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r constantToActionFindUnique) ExecInner(ctx context.Context) (
	*InnerConstant,
	error,
) {
	var v *InnerConstant
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r constantToActionFindUnique) Update(params ...ConstantSetParam) constantToActionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Constant"

	var v constantToActionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type constantToActionUpdateUnique struct {
	query builder.Query
}

func (r constantToActionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r constantToActionUpdateUnique) constantModel() {}

func (r constantToActionUpdateUnique) Exec(ctx context.Context) (*ConstantModel, error) {
	var v ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r constantToActionUpdateUnique) Tx() constantUniqueTxResult {
	v := NewconstantUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r constantToActionFindUnique) Delete() constantToActionDeleteUnique {
	var v constantToActionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Constant"

	return v
}

type constantToActionDeleteUnique struct {
	query builder.Query
}

func (r constantToActionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p constantToActionDeleteUnique) constantModel() {}

func (r constantToActionDeleteUnique) Exec(ctx context.Context) (*ConstantModel, error) {
	var v ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r constantToActionDeleteUnique) Tx() constantUniqueTxResult {
	v := NewconstantUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type constantToActionFindFirst struct {
	query builder.Query
}

func (r constantToActionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r constantToActionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r constantToActionFindFirst) with()             {}
func (r constantToActionFindFirst) constantModel()    {}
func (r constantToActionFindFirst) constantRelation() {}

func (r constantToActionFindFirst) With(params ...ActionRelationWith) constantToActionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r constantToActionFindFirst) OrderBy(params ...ActionOrderByParam) constantToActionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r constantToActionFindFirst) Skip(count int) constantToActionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r constantToActionFindFirst) Take(count int) constantToActionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r constantToActionFindFirst) Cursor(cursor ConstantCursorParam) constantToActionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r constantToActionFindFirst) Exec(ctx context.Context) (
	*ConstantModel,
	error,
) {
	var v *ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r constantToActionFindFirst) ExecInner(ctx context.Context) (
	*InnerConstant,
	error,
) {
	var v *InnerConstant
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type constantToActionFindMany struct {
	query builder.Query
}

func (r constantToActionFindMany) getQuery() builder.Query {
	return r.query
}

func (r constantToActionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r constantToActionFindMany) with()             {}
func (r constantToActionFindMany) constantModel()    {}
func (r constantToActionFindMany) constantRelation() {}

func (r constantToActionFindMany) With(params ...ActionRelationWith) constantToActionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r constantToActionFindMany) OrderBy(params ...ActionOrderByParam) constantToActionFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r constantToActionFindMany) Skip(count int) constantToActionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r constantToActionFindMany) Take(count int) constantToActionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r constantToActionFindMany) Cursor(cursor ConstantCursorParam) constantToActionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r constantToActionFindMany) Exec(ctx context.Context) (
	[]ConstantModel,
	error,
) {
	var v []ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r constantToActionFindMany) ExecInner(ctx context.Context) (
	[]InnerConstant,
	error,
) {
	var v []InnerConstant
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r constantToActionFindMany) Update(params ...ConstantSetParam) constantToActionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Constant"

	r.query.Outputs = countOutput

	var v constantToActionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type constantToActionUpdateMany struct {
	query builder.Query
}

func (r constantToActionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r constantToActionUpdateMany) constantModel() {}

func (r constantToActionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r constantToActionUpdateMany) Tx() constantManyTxResult {
	v := NewconstantManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r constantToActionFindMany) Delete() constantToActionDeleteMany {
	var v constantToActionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Constant"

	v.query.Outputs = countOutput

	return v
}

type constantToActionDeleteMany struct {
	query builder.Query
}

func (r constantToActionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p constantToActionDeleteMany) constantModel() {}

func (r constantToActionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r constantToActionDeleteMany) Tx() constantManyTxResult {
	v := NewconstantManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type constantToFieldFindUnique struct {
	query builder.Query
}

func (r constantToFieldFindUnique) getQuery() builder.Query {
	return r.query
}

func (r constantToFieldFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r constantToFieldFindUnique) with()             {}
func (r constantToFieldFindUnique) constantModel()    {}
func (r constantToFieldFindUnique) constantRelation() {}

func (r constantToFieldFindUnique) With(params ...FieldRelationWith) constantToFieldFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r constantToFieldFindUnique) Exec(ctx context.Context) (
	*ConstantModel,
	error,
) {
	var v *ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r constantToFieldFindUnique) ExecInner(ctx context.Context) (
	*InnerConstant,
	error,
) {
	var v *InnerConstant
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r constantToFieldFindUnique) Update(params ...ConstantSetParam) constantToFieldUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Constant"

	var v constantToFieldUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type constantToFieldUpdateUnique struct {
	query builder.Query
}

func (r constantToFieldUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r constantToFieldUpdateUnique) constantModel() {}

func (r constantToFieldUpdateUnique) Exec(ctx context.Context) (*ConstantModel, error) {
	var v ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r constantToFieldUpdateUnique) Tx() constantUniqueTxResult {
	v := NewconstantUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r constantToFieldFindUnique) Delete() constantToFieldDeleteUnique {
	var v constantToFieldDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Constant"

	return v
}

type constantToFieldDeleteUnique struct {
	query builder.Query
}

func (r constantToFieldDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p constantToFieldDeleteUnique) constantModel() {}

func (r constantToFieldDeleteUnique) Exec(ctx context.Context) (*ConstantModel, error) {
	var v ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r constantToFieldDeleteUnique) Tx() constantUniqueTxResult {
	v := NewconstantUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type constantToFieldFindFirst struct {
	query builder.Query
}

func (r constantToFieldFindFirst) getQuery() builder.Query {
	return r.query
}

func (r constantToFieldFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r constantToFieldFindFirst) with()             {}
func (r constantToFieldFindFirst) constantModel()    {}
func (r constantToFieldFindFirst) constantRelation() {}

func (r constantToFieldFindFirst) With(params ...FieldRelationWith) constantToFieldFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r constantToFieldFindFirst) OrderBy(params ...FieldOrderByParam) constantToFieldFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r constantToFieldFindFirst) Skip(count int) constantToFieldFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r constantToFieldFindFirst) Take(count int) constantToFieldFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r constantToFieldFindFirst) Cursor(cursor ConstantCursorParam) constantToFieldFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r constantToFieldFindFirst) Exec(ctx context.Context) (
	*ConstantModel,
	error,
) {
	var v *ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r constantToFieldFindFirst) ExecInner(ctx context.Context) (
	*InnerConstant,
	error,
) {
	var v *InnerConstant
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type constantToFieldFindMany struct {
	query builder.Query
}

func (r constantToFieldFindMany) getQuery() builder.Query {
	return r.query
}

func (r constantToFieldFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r constantToFieldFindMany) with()             {}
func (r constantToFieldFindMany) constantModel()    {}
func (r constantToFieldFindMany) constantRelation() {}

func (r constantToFieldFindMany) With(params ...FieldRelationWith) constantToFieldFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r constantToFieldFindMany) OrderBy(params ...FieldOrderByParam) constantToFieldFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r constantToFieldFindMany) Skip(count int) constantToFieldFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r constantToFieldFindMany) Take(count int) constantToFieldFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r constantToFieldFindMany) Cursor(cursor ConstantCursorParam) constantToFieldFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r constantToFieldFindMany) Exec(ctx context.Context) (
	[]ConstantModel,
	error,
) {
	var v []ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r constantToFieldFindMany) ExecInner(ctx context.Context) (
	[]InnerConstant,
	error,
) {
	var v []InnerConstant
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r constantToFieldFindMany) Update(params ...ConstantSetParam) constantToFieldUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Constant"

	r.query.Outputs = countOutput

	var v constantToFieldUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type constantToFieldUpdateMany struct {
	query builder.Query
}

func (r constantToFieldUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r constantToFieldUpdateMany) constantModel() {}

func (r constantToFieldUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r constantToFieldUpdateMany) Tx() constantManyTxResult {
	v := NewconstantManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r constantToFieldFindMany) Delete() constantToFieldDeleteMany {
	var v constantToFieldDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Constant"

	v.query.Outputs = countOutput

	return v
}

type constantToFieldDeleteMany struct {
	query builder.Query
}

func (r constantToFieldDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p constantToFieldDeleteMany) constantModel() {}

func (r constantToFieldDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r constantToFieldDeleteMany) Tx() constantManyTxResult {
	v := NewconstantManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type constantFindUnique struct {
	query builder.Query
}

func (r constantFindUnique) getQuery() builder.Query {
	return r.query
}

func (r constantFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r constantFindUnique) with()             {}
func (r constantFindUnique) constantModel()    {}
func (r constantFindUnique) constantRelation() {}

func (r constantActions) FindUnique(
	params ConstantEqualsUniqueWhereParam,
) constantFindUnique {
	var v constantFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Constant"
	v.query.Outputs = constantOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r constantFindUnique) With(params ...ConstantRelationWith) constantFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r constantFindUnique) Exec(ctx context.Context) (
	*ConstantModel,
	error,
) {
	var v *ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r constantFindUnique) ExecInner(ctx context.Context) (
	*InnerConstant,
	error,
) {
	var v *InnerConstant
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r constantFindUnique) Update(params ...ConstantSetParam) constantUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Constant"

	var v constantUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type constantUpdateUnique struct {
	query builder.Query
}

func (r constantUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r constantUpdateUnique) constantModel() {}

func (r constantUpdateUnique) Exec(ctx context.Context) (*ConstantModel, error) {
	var v ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r constantUpdateUnique) Tx() constantUniqueTxResult {
	v := NewconstantUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r constantFindUnique) Delete() constantDeleteUnique {
	var v constantDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Constant"

	return v
}

type constantDeleteUnique struct {
	query builder.Query
}

func (r constantDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p constantDeleteUnique) constantModel() {}

func (r constantDeleteUnique) Exec(ctx context.Context) (*ConstantModel, error) {
	var v ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r constantDeleteUnique) Tx() constantUniqueTxResult {
	v := NewconstantUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type constantFindFirst struct {
	query builder.Query
}

func (r constantFindFirst) getQuery() builder.Query {
	return r.query
}

func (r constantFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r constantFindFirst) with()             {}
func (r constantFindFirst) constantModel()    {}
func (r constantFindFirst) constantRelation() {}

func (r constantActions) FindFirst(
	params ...ConstantWhereParam,
) constantFindFirst {
	var v constantFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Constant"
	v.query.Outputs = constantOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r constantFindFirst) With(params ...ConstantRelationWith) constantFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r constantFindFirst) OrderBy(params ...ConstantOrderByParam) constantFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r constantFindFirst) Skip(count int) constantFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r constantFindFirst) Take(count int) constantFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r constantFindFirst) Cursor(cursor ConstantCursorParam) constantFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r constantFindFirst) Exec(ctx context.Context) (
	*ConstantModel,
	error,
) {
	var v *ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r constantFindFirst) ExecInner(ctx context.Context) (
	*InnerConstant,
	error,
) {
	var v *InnerConstant
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type constantFindMany struct {
	query builder.Query
}

func (r constantFindMany) getQuery() builder.Query {
	return r.query
}

func (r constantFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r constantFindMany) with()             {}
func (r constantFindMany) constantModel()    {}
func (r constantFindMany) constantRelation() {}

func (r constantActions) FindMany(
	params ...ConstantWhereParam,
) constantFindMany {
	var v constantFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Constant"
	v.query.Outputs = constantOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r constantFindMany) With(params ...ConstantRelationWith) constantFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r constantFindMany) OrderBy(params ...ConstantOrderByParam) constantFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r constantFindMany) Skip(count int) constantFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r constantFindMany) Take(count int) constantFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r constantFindMany) Cursor(cursor ConstantCursorParam) constantFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r constantFindMany) Exec(ctx context.Context) (
	[]ConstantModel,
	error,
) {
	var v []ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r constantFindMany) ExecInner(ctx context.Context) (
	[]InnerConstant,
	error,
) {
	var v []InnerConstant
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r constantFindMany) Update(params ...ConstantSetParam) constantUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Constant"

	r.query.Outputs = countOutput

	var v constantUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type constantUpdateMany struct {
	query builder.Query
}

func (r constantUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r constantUpdateMany) constantModel() {}

func (r constantUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r constantUpdateMany) Tx() constantManyTxResult {
	v := NewconstantManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r constantFindMany) Delete() constantDeleteMany {
	var v constantDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Constant"

	v.query.Outputs = countOutput

	return v
}

type constantDeleteMany struct {
	query builder.Query
}

func (r constantDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p constantDeleteMany) constantModel() {}

func (r constantDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r constantDeleteMany) Tx() constantManyTxResult {
	v := NewconstantManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type actionToDeviceFindUnique struct {
	query builder.Query
}

func (r actionToDeviceFindUnique) getQuery() builder.Query {
	return r.query
}

func (r actionToDeviceFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToDeviceFindUnique) with()           {}
func (r actionToDeviceFindUnique) actionModel()    {}
func (r actionToDeviceFindUnique) actionRelation() {}

func (r actionToDeviceFindUnique) With(params ...DeviceRelationWith) actionToDeviceFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r actionToDeviceFindUnique) Exec(ctx context.Context) (
	*ActionModel,
	error,
) {
	var v *ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r actionToDeviceFindUnique) ExecInner(ctx context.Context) (
	*InnerAction,
	error,
) {
	var v *InnerAction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r actionToDeviceFindUnique) Update(params ...ActionSetParam) actionToDeviceUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Action"

	var v actionToDeviceUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type actionToDeviceUpdateUnique struct {
	query builder.Query
}

func (r actionToDeviceUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToDeviceUpdateUnique) actionModel() {}

func (r actionToDeviceUpdateUnique) Exec(ctx context.Context) (*ActionModel, error) {
	var v ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionToDeviceUpdateUnique) Tx() actionUniqueTxResult {
	v := NewactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r actionToDeviceFindUnique) Delete() actionToDeviceDeleteUnique {
	var v actionToDeviceDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Action"

	return v
}

type actionToDeviceDeleteUnique struct {
	query builder.Query
}

func (r actionToDeviceDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p actionToDeviceDeleteUnique) actionModel() {}

func (r actionToDeviceDeleteUnique) Exec(ctx context.Context) (*ActionModel, error) {
	var v ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionToDeviceDeleteUnique) Tx() actionUniqueTxResult {
	v := NewactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type actionToDeviceFindFirst struct {
	query builder.Query
}

func (r actionToDeviceFindFirst) getQuery() builder.Query {
	return r.query
}

func (r actionToDeviceFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToDeviceFindFirst) with()           {}
func (r actionToDeviceFindFirst) actionModel()    {}
func (r actionToDeviceFindFirst) actionRelation() {}

func (r actionToDeviceFindFirst) With(params ...DeviceRelationWith) actionToDeviceFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r actionToDeviceFindFirst) OrderBy(params ...DeviceOrderByParam) actionToDeviceFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r actionToDeviceFindFirst) Skip(count int) actionToDeviceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r actionToDeviceFindFirst) Take(count int) actionToDeviceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r actionToDeviceFindFirst) Cursor(cursor ActionCursorParam) actionToDeviceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r actionToDeviceFindFirst) Exec(ctx context.Context) (
	*ActionModel,
	error,
) {
	var v *ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r actionToDeviceFindFirst) ExecInner(ctx context.Context) (
	*InnerAction,
	error,
) {
	var v *InnerAction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type actionToDeviceFindMany struct {
	query builder.Query
}

func (r actionToDeviceFindMany) getQuery() builder.Query {
	return r.query
}

func (r actionToDeviceFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToDeviceFindMany) with()           {}
func (r actionToDeviceFindMany) actionModel()    {}
func (r actionToDeviceFindMany) actionRelation() {}

func (r actionToDeviceFindMany) With(params ...DeviceRelationWith) actionToDeviceFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r actionToDeviceFindMany) OrderBy(params ...DeviceOrderByParam) actionToDeviceFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r actionToDeviceFindMany) Skip(count int) actionToDeviceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r actionToDeviceFindMany) Take(count int) actionToDeviceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r actionToDeviceFindMany) Cursor(cursor ActionCursorParam) actionToDeviceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r actionToDeviceFindMany) Exec(ctx context.Context) (
	[]ActionModel,
	error,
) {
	var v []ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r actionToDeviceFindMany) ExecInner(ctx context.Context) (
	[]InnerAction,
	error,
) {
	var v []InnerAction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r actionToDeviceFindMany) Update(params ...ActionSetParam) actionToDeviceUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Action"

	r.query.Outputs = countOutput

	var v actionToDeviceUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type actionToDeviceUpdateMany struct {
	query builder.Query
}

func (r actionToDeviceUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToDeviceUpdateMany) actionModel() {}

func (r actionToDeviceUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionToDeviceUpdateMany) Tx() actionManyTxResult {
	v := NewactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r actionToDeviceFindMany) Delete() actionToDeviceDeleteMany {
	var v actionToDeviceDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Action"

	v.query.Outputs = countOutput

	return v
}

type actionToDeviceDeleteMany struct {
	query builder.Query
}

func (r actionToDeviceDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p actionToDeviceDeleteMany) actionModel() {}

func (r actionToDeviceDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionToDeviceDeleteMany) Tx() actionManyTxResult {
	v := NewactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type actionToEventFindUnique struct {
	query builder.Query
}

func (r actionToEventFindUnique) getQuery() builder.Query {
	return r.query
}

func (r actionToEventFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToEventFindUnique) with()           {}
func (r actionToEventFindUnique) actionModel()    {}
func (r actionToEventFindUnique) actionRelation() {}

func (r actionToEventFindUnique) With(params ...EventRelationWith) actionToEventFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r actionToEventFindUnique) Exec(ctx context.Context) (
	*ActionModel,
	error,
) {
	var v *ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r actionToEventFindUnique) ExecInner(ctx context.Context) (
	*InnerAction,
	error,
) {
	var v *InnerAction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r actionToEventFindUnique) Update(params ...ActionSetParam) actionToEventUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Action"

	var v actionToEventUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type actionToEventUpdateUnique struct {
	query builder.Query
}

func (r actionToEventUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToEventUpdateUnique) actionModel() {}

func (r actionToEventUpdateUnique) Exec(ctx context.Context) (*ActionModel, error) {
	var v ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionToEventUpdateUnique) Tx() actionUniqueTxResult {
	v := NewactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r actionToEventFindUnique) Delete() actionToEventDeleteUnique {
	var v actionToEventDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Action"

	return v
}

type actionToEventDeleteUnique struct {
	query builder.Query
}

func (r actionToEventDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p actionToEventDeleteUnique) actionModel() {}

func (r actionToEventDeleteUnique) Exec(ctx context.Context) (*ActionModel, error) {
	var v ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionToEventDeleteUnique) Tx() actionUniqueTxResult {
	v := NewactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type actionToEventFindFirst struct {
	query builder.Query
}

func (r actionToEventFindFirst) getQuery() builder.Query {
	return r.query
}

func (r actionToEventFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToEventFindFirst) with()           {}
func (r actionToEventFindFirst) actionModel()    {}
func (r actionToEventFindFirst) actionRelation() {}

func (r actionToEventFindFirst) With(params ...EventRelationWith) actionToEventFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r actionToEventFindFirst) OrderBy(params ...EventOrderByParam) actionToEventFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r actionToEventFindFirst) Skip(count int) actionToEventFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r actionToEventFindFirst) Take(count int) actionToEventFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r actionToEventFindFirst) Cursor(cursor ActionCursorParam) actionToEventFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r actionToEventFindFirst) Exec(ctx context.Context) (
	*ActionModel,
	error,
) {
	var v *ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r actionToEventFindFirst) ExecInner(ctx context.Context) (
	*InnerAction,
	error,
) {
	var v *InnerAction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type actionToEventFindMany struct {
	query builder.Query
}

func (r actionToEventFindMany) getQuery() builder.Query {
	return r.query
}

func (r actionToEventFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToEventFindMany) with()           {}
func (r actionToEventFindMany) actionModel()    {}
func (r actionToEventFindMany) actionRelation() {}

func (r actionToEventFindMany) With(params ...EventRelationWith) actionToEventFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r actionToEventFindMany) OrderBy(params ...EventOrderByParam) actionToEventFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r actionToEventFindMany) Skip(count int) actionToEventFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r actionToEventFindMany) Take(count int) actionToEventFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r actionToEventFindMany) Cursor(cursor ActionCursorParam) actionToEventFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r actionToEventFindMany) Exec(ctx context.Context) (
	[]ActionModel,
	error,
) {
	var v []ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r actionToEventFindMany) ExecInner(ctx context.Context) (
	[]InnerAction,
	error,
) {
	var v []InnerAction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r actionToEventFindMany) Update(params ...ActionSetParam) actionToEventUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Action"

	r.query.Outputs = countOutput

	var v actionToEventUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type actionToEventUpdateMany struct {
	query builder.Query
}

func (r actionToEventUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToEventUpdateMany) actionModel() {}

func (r actionToEventUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionToEventUpdateMany) Tx() actionManyTxResult {
	v := NewactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r actionToEventFindMany) Delete() actionToEventDeleteMany {
	var v actionToEventDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Action"

	v.query.Outputs = countOutput

	return v
}

type actionToEventDeleteMany struct {
	query builder.Query
}

func (r actionToEventDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p actionToEventDeleteMany) actionModel() {}

func (r actionToEventDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionToEventDeleteMany) Tx() actionManyTxResult {
	v := NewactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type actionToConstantsFindUnique struct {
	query builder.Query
}

func (r actionToConstantsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r actionToConstantsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToConstantsFindUnique) with()           {}
func (r actionToConstantsFindUnique) actionModel()    {}
func (r actionToConstantsFindUnique) actionRelation() {}

func (r actionToConstantsFindUnique) With(params ...ConstantRelationWith) actionToConstantsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r actionToConstantsFindUnique) Exec(ctx context.Context) (
	*ActionModel,
	error,
) {
	var v *ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r actionToConstantsFindUnique) ExecInner(ctx context.Context) (
	*InnerAction,
	error,
) {
	var v *InnerAction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r actionToConstantsFindUnique) Update(params ...ActionSetParam) actionToConstantsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Action"

	var v actionToConstantsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type actionToConstantsUpdateUnique struct {
	query builder.Query
}

func (r actionToConstantsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToConstantsUpdateUnique) actionModel() {}

func (r actionToConstantsUpdateUnique) Exec(ctx context.Context) (*ActionModel, error) {
	var v ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionToConstantsUpdateUnique) Tx() actionUniqueTxResult {
	v := NewactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r actionToConstantsFindUnique) Delete() actionToConstantsDeleteUnique {
	var v actionToConstantsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Action"

	return v
}

type actionToConstantsDeleteUnique struct {
	query builder.Query
}

func (r actionToConstantsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p actionToConstantsDeleteUnique) actionModel() {}

func (r actionToConstantsDeleteUnique) Exec(ctx context.Context) (*ActionModel, error) {
	var v ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionToConstantsDeleteUnique) Tx() actionUniqueTxResult {
	v := NewactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type actionToConstantsFindFirst struct {
	query builder.Query
}

func (r actionToConstantsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r actionToConstantsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToConstantsFindFirst) with()           {}
func (r actionToConstantsFindFirst) actionModel()    {}
func (r actionToConstantsFindFirst) actionRelation() {}

func (r actionToConstantsFindFirst) With(params ...ConstantRelationWith) actionToConstantsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r actionToConstantsFindFirst) OrderBy(params ...ConstantOrderByParam) actionToConstantsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r actionToConstantsFindFirst) Skip(count int) actionToConstantsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r actionToConstantsFindFirst) Take(count int) actionToConstantsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r actionToConstantsFindFirst) Cursor(cursor ActionCursorParam) actionToConstantsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r actionToConstantsFindFirst) Exec(ctx context.Context) (
	*ActionModel,
	error,
) {
	var v *ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r actionToConstantsFindFirst) ExecInner(ctx context.Context) (
	*InnerAction,
	error,
) {
	var v *InnerAction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type actionToConstantsFindMany struct {
	query builder.Query
}

func (r actionToConstantsFindMany) getQuery() builder.Query {
	return r.query
}

func (r actionToConstantsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToConstantsFindMany) with()           {}
func (r actionToConstantsFindMany) actionModel()    {}
func (r actionToConstantsFindMany) actionRelation() {}

func (r actionToConstantsFindMany) With(params ...ConstantRelationWith) actionToConstantsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r actionToConstantsFindMany) OrderBy(params ...ConstantOrderByParam) actionToConstantsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r actionToConstantsFindMany) Skip(count int) actionToConstantsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r actionToConstantsFindMany) Take(count int) actionToConstantsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r actionToConstantsFindMany) Cursor(cursor ActionCursorParam) actionToConstantsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r actionToConstantsFindMany) Exec(ctx context.Context) (
	[]ActionModel,
	error,
) {
	var v []ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r actionToConstantsFindMany) ExecInner(ctx context.Context) (
	[]InnerAction,
	error,
) {
	var v []InnerAction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r actionToConstantsFindMany) Update(params ...ActionSetParam) actionToConstantsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Action"

	r.query.Outputs = countOutput

	var v actionToConstantsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type actionToConstantsUpdateMany struct {
	query builder.Query
}

func (r actionToConstantsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToConstantsUpdateMany) actionModel() {}

func (r actionToConstantsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionToConstantsUpdateMany) Tx() actionManyTxResult {
	v := NewactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r actionToConstantsFindMany) Delete() actionToConstantsDeleteMany {
	var v actionToConstantsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Action"

	v.query.Outputs = countOutput

	return v
}

type actionToConstantsDeleteMany struct {
	query builder.Query
}

func (r actionToConstantsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p actionToConstantsDeleteMany) actionModel() {}

func (r actionToConstantsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionToConstantsDeleteMany) Tx() actionManyTxResult {
	v := NewactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type actionToStepsFindUnique struct {
	query builder.Query
}

func (r actionToStepsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r actionToStepsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToStepsFindUnique) with()           {}
func (r actionToStepsFindUnique) actionModel()    {}
func (r actionToStepsFindUnique) actionRelation() {}

func (r actionToStepsFindUnique) With(params ...StepRelationWith) actionToStepsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r actionToStepsFindUnique) Exec(ctx context.Context) (
	*ActionModel,
	error,
) {
	var v *ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r actionToStepsFindUnique) ExecInner(ctx context.Context) (
	*InnerAction,
	error,
) {
	var v *InnerAction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r actionToStepsFindUnique) Update(params ...ActionSetParam) actionToStepsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Action"

	var v actionToStepsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type actionToStepsUpdateUnique struct {
	query builder.Query
}

func (r actionToStepsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToStepsUpdateUnique) actionModel() {}

func (r actionToStepsUpdateUnique) Exec(ctx context.Context) (*ActionModel, error) {
	var v ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionToStepsUpdateUnique) Tx() actionUniqueTxResult {
	v := NewactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r actionToStepsFindUnique) Delete() actionToStepsDeleteUnique {
	var v actionToStepsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Action"

	return v
}

type actionToStepsDeleteUnique struct {
	query builder.Query
}

func (r actionToStepsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p actionToStepsDeleteUnique) actionModel() {}

func (r actionToStepsDeleteUnique) Exec(ctx context.Context) (*ActionModel, error) {
	var v ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionToStepsDeleteUnique) Tx() actionUniqueTxResult {
	v := NewactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type actionToStepsFindFirst struct {
	query builder.Query
}

func (r actionToStepsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r actionToStepsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToStepsFindFirst) with()           {}
func (r actionToStepsFindFirst) actionModel()    {}
func (r actionToStepsFindFirst) actionRelation() {}

func (r actionToStepsFindFirst) With(params ...StepRelationWith) actionToStepsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r actionToStepsFindFirst) OrderBy(params ...StepOrderByParam) actionToStepsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r actionToStepsFindFirst) Skip(count int) actionToStepsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r actionToStepsFindFirst) Take(count int) actionToStepsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r actionToStepsFindFirst) Cursor(cursor ActionCursorParam) actionToStepsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r actionToStepsFindFirst) Exec(ctx context.Context) (
	*ActionModel,
	error,
) {
	var v *ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r actionToStepsFindFirst) ExecInner(ctx context.Context) (
	*InnerAction,
	error,
) {
	var v *InnerAction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type actionToStepsFindMany struct {
	query builder.Query
}

func (r actionToStepsFindMany) getQuery() builder.Query {
	return r.query
}

func (r actionToStepsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToStepsFindMany) with()           {}
func (r actionToStepsFindMany) actionModel()    {}
func (r actionToStepsFindMany) actionRelation() {}

func (r actionToStepsFindMany) With(params ...StepRelationWith) actionToStepsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r actionToStepsFindMany) OrderBy(params ...StepOrderByParam) actionToStepsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r actionToStepsFindMany) Skip(count int) actionToStepsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r actionToStepsFindMany) Take(count int) actionToStepsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r actionToStepsFindMany) Cursor(cursor ActionCursorParam) actionToStepsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r actionToStepsFindMany) Exec(ctx context.Context) (
	[]ActionModel,
	error,
) {
	var v []ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r actionToStepsFindMany) ExecInner(ctx context.Context) (
	[]InnerAction,
	error,
) {
	var v []InnerAction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r actionToStepsFindMany) Update(params ...ActionSetParam) actionToStepsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Action"

	r.query.Outputs = countOutput

	var v actionToStepsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type actionToStepsUpdateMany struct {
	query builder.Query
}

func (r actionToStepsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r actionToStepsUpdateMany) actionModel() {}

func (r actionToStepsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionToStepsUpdateMany) Tx() actionManyTxResult {
	v := NewactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r actionToStepsFindMany) Delete() actionToStepsDeleteMany {
	var v actionToStepsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Action"

	v.query.Outputs = countOutput

	return v
}

type actionToStepsDeleteMany struct {
	query builder.Query
}

func (r actionToStepsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p actionToStepsDeleteMany) actionModel() {}

func (r actionToStepsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionToStepsDeleteMany) Tx() actionManyTxResult {
	v := NewactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type actionFindUnique struct {
	query builder.Query
}

func (r actionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r actionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r actionFindUnique) with()           {}
func (r actionFindUnique) actionModel()    {}
func (r actionFindUnique) actionRelation() {}

func (r actionActions) FindUnique(
	params ActionEqualsUniqueWhereParam,
) actionFindUnique {
	var v actionFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Action"
	v.query.Outputs = actionOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r actionFindUnique) With(params ...ActionRelationWith) actionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r actionFindUnique) Exec(ctx context.Context) (
	*ActionModel,
	error,
) {
	var v *ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r actionFindUnique) ExecInner(ctx context.Context) (
	*InnerAction,
	error,
) {
	var v *InnerAction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r actionFindUnique) Update(params ...ActionSetParam) actionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Action"

	var v actionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type actionUpdateUnique struct {
	query builder.Query
}

func (r actionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r actionUpdateUnique) actionModel() {}

func (r actionUpdateUnique) Exec(ctx context.Context) (*ActionModel, error) {
	var v ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionUpdateUnique) Tx() actionUniqueTxResult {
	v := NewactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r actionFindUnique) Delete() actionDeleteUnique {
	var v actionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Action"

	return v
}

type actionDeleteUnique struct {
	query builder.Query
}

func (r actionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p actionDeleteUnique) actionModel() {}

func (r actionDeleteUnique) Exec(ctx context.Context) (*ActionModel, error) {
	var v ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionDeleteUnique) Tx() actionUniqueTxResult {
	v := NewactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type actionFindFirst struct {
	query builder.Query
}

func (r actionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r actionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r actionFindFirst) with()           {}
func (r actionFindFirst) actionModel()    {}
func (r actionFindFirst) actionRelation() {}

func (r actionActions) FindFirst(
	params ...ActionWhereParam,
) actionFindFirst {
	var v actionFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Action"
	v.query.Outputs = actionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r actionFindFirst) With(params ...ActionRelationWith) actionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r actionFindFirst) OrderBy(params ...ActionOrderByParam) actionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r actionFindFirst) Skip(count int) actionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r actionFindFirst) Take(count int) actionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r actionFindFirst) Cursor(cursor ActionCursorParam) actionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r actionFindFirst) Exec(ctx context.Context) (
	*ActionModel,
	error,
) {
	var v *ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r actionFindFirst) ExecInner(ctx context.Context) (
	*InnerAction,
	error,
) {
	var v *InnerAction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type actionFindMany struct {
	query builder.Query
}

func (r actionFindMany) getQuery() builder.Query {
	return r.query
}

func (r actionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r actionFindMany) with()           {}
func (r actionFindMany) actionModel()    {}
func (r actionFindMany) actionRelation() {}

func (r actionActions) FindMany(
	params ...ActionWhereParam,
) actionFindMany {
	var v actionFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Action"
	v.query.Outputs = actionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r actionFindMany) With(params ...ActionRelationWith) actionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r actionFindMany) OrderBy(params ...ActionOrderByParam) actionFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r actionFindMany) Skip(count int) actionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r actionFindMany) Take(count int) actionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r actionFindMany) Cursor(cursor ActionCursorParam) actionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r actionFindMany) Exec(ctx context.Context) (
	[]ActionModel,
	error,
) {
	var v []ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r actionFindMany) ExecInner(ctx context.Context) (
	[]InnerAction,
	error,
) {
	var v []InnerAction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r actionFindMany) Update(params ...ActionSetParam) actionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Action"

	r.query.Outputs = countOutput

	var v actionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type actionUpdateMany struct {
	query builder.Query
}

func (r actionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r actionUpdateMany) actionModel() {}

func (r actionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionUpdateMany) Tx() actionManyTxResult {
	v := NewactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r actionFindMany) Delete() actionDeleteMany {
	var v actionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Action"

	v.query.Outputs = countOutput

	return v
}

type actionDeleteMany struct {
	query builder.Query
}

func (r actionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p actionDeleteMany) actionModel() {}

func (r actionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionDeleteMany) Tx() actionManyTxResult {
	v := NewactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type stepToRunFindUnique struct {
	query builder.Query
}

func (r stepToRunFindUnique) getQuery() builder.Query {
	return r.query
}

func (r stepToRunFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r stepToRunFindUnique) with()         {}
func (r stepToRunFindUnique) stepModel()    {}
func (r stepToRunFindUnique) stepRelation() {}

func (r stepToRunFindUnique) With(params ...RunRelationWith) stepToRunFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r stepToRunFindUnique) Exec(ctx context.Context) (
	*StepModel,
	error,
) {
	var v *StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r stepToRunFindUnique) ExecInner(ctx context.Context) (
	*InnerStep,
	error,
) {
	var v *InnerStep
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r stepToRunFindUnique) Update(params ...StepSetParam) stepToRunUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Step"

	var v stepToRunUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type stepToRunUpdateUnique struct {
	query builder.Query
}

func (r stepToRunUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r stepToRunUpdateUnique) stepModel() {}

func (r stepToRunUpdateUnique) Exec(ctx context.Context) (*StepModel, error) {
	var v StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r stepToRunUpdateUnique) Tx() stepUniqueTxResult {
	v := NewstepUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r stepToRunFindUnique) Delete() stepToRunDeleteUnique {
	var v stepToRunDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Step"

	return v
}

type stepToRunDeleteUnique struct {
	query builder.Query
}

func (r stepToRunDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p stepToRunDeleteUnique) stepModel() {}

func (r stepToRunDeleteUnique) Exec(ctx context.Context) (*StepModel, error) {
	var v StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r stepToRunDeleteUnique) Tx() stepUniqueTxResult {
	v := NewstepUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type stepToRunFindFirst struct {
	query builder.Query
}

func (r stepToRunFindFirst) getQuery() builder.Query {
	return r.query
}

func (r stepToRunFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r stepToRunFindFirst) with()         {}
func (r stepToRunFindFirst) stepModel()    {}
func (r stepToRunFindFirst) stepRelation() {}

func (r stepToRunFindFirst) With(params ...RunRelationWith) stepToRunFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r stepToRunFindFirst) OrderBy(params ...RunOrderByParam) stepToRunFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r stepToRunFindFirst) Skip(count int) stepToRunFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r stepToRunFindFirst) Take(count int) stepToRunFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r stepToRunFindFirst) Cursor(cursor StepCursorParam) stepToRunFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r stepToRunFindFirst) Exec(ctx context.Context) (
	*StepModel,
	error,
) {
	var v *StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r stepToRunFindFirst) ExecInner(ctx context.Context) (
	*InnerStep,
	error,
) {
	var v *InnerStep
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type stepToRunFindMany struct {
	query builder.Query
}

func (r stepToRunFindMany) getQuery() builder.Query {
	return r.query
}

func (r stepToRunFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r stepToRunFindMany) with()         {}
func (r stepToRunFindMany) stepModel()    {}
func (r stepToRunFindMany) stepRelation() {}

func (r stepToRunFindMany) With(params ...RunRelationWith) stepToRunFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r stepToRunFindMany) OrderBy(params ...RunOrderByParam) stepToRunFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r stepToRunFindMany) Skip(count int) stepToRunFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r stepToRunFindMany) Take(count int) stepToRunFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r stepToRunFindMany) Cursor(cursor StepCursorParam) stepToRunFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r stepToRunFindMany) Exec(ctx context.Context) (
	[]StepModel,
	error,
) {
	var v []StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r stepToRunFindMany) ExecInner(ctx context.Context) (
	[]InnerStep,
	error,
) {
	var v []InnerStep
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r stepToRunFindMany) Update(params ...StepSetParam) stepToRunUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Step"

	r.query.Outputs = countOutput

	var v stepToRunUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type stepToRunUpdateMany struct {
	query builder.Query
}

func (r stepToRunUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r stepToRunUpdateMany) stepModel() {}

func (r stepToRunUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r stepToRunUpdateMany) Tx() stepManyTxResult {
	v := NewstepManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r stepToRunFindMany) Delete() stepToRunDeleteMany {
	var v stepToRunDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Step"

	v.query.Outputs = countOutput

	return v
}

type stepToRunDeleteMany struct {
	query builder.Query
}

func (r stepToRunDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p stepToRunDeleteMany) stepModel() {}

func (r stepToRunDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r stepToRunDeleteMany) Tx() stepManyTxResult {
	v := NewstepManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type stepToActionFindUnique struct {
	query builder.Query
}

func (r stepToActionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r stepToActionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r stepToActionFindUnique) with()         {}
func (r stepToActionFindUnique) stepModel()    {}
func (r stepToActionFindUnique) stepRelation() {}

func (r stepToActionFindUnique) With(params ...ActionRelationWith) stepToActionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r stepToActionFindUnique) Exec(ctx context.Context) (
	*StepModel,
	error,
) {
	var v *StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r stepToActionFindUnique) ExecInner(ctx context.Context) (
	*InnerStep,
	error,
) {
	var v *InnerStep
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r stepToActionFindUnique) Update(params ...StepSetParam) stepToActionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Step"

	var v stepToActionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type stepToActionUpdateUnique struct {
	query builder.Query
}

func (r stepToActionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r stepToActionUpdateUnique) stepModel() {}

func (r stepToActionUpdateUnique) Exec(ctx context.Context) (*StepModel, error) {
	var v StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r stepToActionUpdateUnique) Tx() stepUniqueTxResult {
	v := NewstepUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r stepToActionFindUnique) Delete() stepToActionDeleteUnique {
	var v stepToActionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Step"

	return v
}

type stepToActionDeleteUnique struct {
	query builder.Query
}

func (r stepToActionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p stepToActionDeleteUnique) stepModel() {}

func (r stepToActionDeleteUnique) Exec(ctx context.Context) (*StepModel, error) {
	var v StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r stepToActionDeleteUnique) Tx() stepUniqueTxResult {
	v := NewstepUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type stepToActionFindFirst struct {
	query builder.Query
}

func (r stepToActionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r stepToActionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r stepToActionFindFirst) with()         {}
func (r stepToActionFindFirst) stepModel()    {}
func (r stepToActionFindFirst) stepRelation() {}

func (r stepToActionFindFirst) With(params ...ActionRelationWith) stepToActionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r stepToActionFindFirst) OrderBy(params ...ActionOrderByParam) stepToActionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r stepToActionFindFirst) Skip(count int) stepToActionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r stepToActionFindFirst) Take(count int) stepToActionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r stepToActionFindFirst) Cursor(cursor StepCursorParam) stepToActionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r stepToActionFindFirst) Exec(ctx context.Context) (
	*StepModel,
	error,
) {
	var v *StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r stepToActionFindFirst) ExecInner(ctx context.Context) (
	*InnerStep,
	error,
) {
	var v *InnerStep
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type stepToActionFindMany struct {
	query builder.Query
}

func (r stepToActionFindMany) getQuery() builder.Query {
	return r.query
}

func (r stepToActionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r stepToActionFindMany) with()         {}
func (r stepToActionFindMany) stepModel()    {}
func (r stepToActionFindMany) stepRelation() {}

func (r stepToActionFindMany) With(params ...ActionRelationWith) stepToActionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r stepToActionFindMany) OrderBy(params ...ActionOrderByParam) stepToActionFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r stepToActionFindMany) Skip(count int) stepToActionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r stepToActionFindMany) Take(count int) stepToActionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r stepToActionFindMany) Cursor(cursor StepCursorParam) stepToActionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r stepToActionFindMany) Exec(ctx context.Context) (
	[]StepModel,
	error,
) {
	var v []StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r stepToActionFindMany) ExecInner(ctx context.Context) (
	[]InnerStep,
	error,
) {
	var v []InnerStep
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r stepToActionFindMany) Update(params ...StepSetParam) stepToActionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Step"

	r.query.Outputs = countOutput

	var v stepToActionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type stepToActionUpdateMany struct {
	query builder.Query
}

func (r stepToActionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r stepToActionUpdateMany) stepModel() {}

func (r stepToActionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r stepToActionUpdateMany) Tx() stepManyTxResult {
	v := NewstepManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r stepToActionFindMany) Delete() stepToActionDeleteMany {
	var v stepToActionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Step"

	v.query.Outputs = countOutput

	return v
}

type stepToActionDeleteMany struct {
	query builder.Query
}

func (r stepToActionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p stepToActionDeleteMany) stepModel() {}

func (r stepToActionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r stepToActionDeleteMany) Tx() stepManyTxResult {
	v := NewstepManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type stepFindUnique struct {
	query builder.Query
}

func (r stepFindUnique) getQuery() builder.Query {
	return r.query
}

func (r stepFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r stepFindUnique) with()         {}
func (r stepFindUnique) stepModel()    {}
func (r stepFindUnique) stepRelation() {}

func (r stepActions) FindUnique(
	params StepEqualsUniqueWhereParam,
) stepFindUnique {
	var v stepFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Step"
	v.query.Outputs = stepOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r stepFindUnique) With(params ...StepRelationWith) stepFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r stepFindUnique) Exec(ctx context.Context) (
	*StepModel,
	error,
) {
	var v *StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r stepFindUnique) ExecInner(ctx context.Context) (
	*InnerStep,
	error,
) {
	var v *InnerStep
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r stepFindUnique) Update(params ...StepSetParam) stepUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Step"

	var v stepUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type stepUpdateUnique struct {
	query builder.Query
}

func (r stepUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r stepUpdateUnique) stepModel() {}

func (r stepUpdateUnique) Exec(ctx context.Context) (*StepModel, error) {
	var v StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r stepUpdateUnique) Tx() stepUniqueTxResult {
	v := NewstepUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r stepFindUnique) Delete() stepDeleteUnique {
	var v stepDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Step"

	return v
}

type stepDeleteUnique struct {
	query builder.Query
}

func (r stepDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p stepDeleteUnique) stepModel() {}

func (r stepDeleteUnique) Exec(ctx context.Context) (*StepModel, error) {
	var v StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r stepDeleteUnique) Tx() stepUniqueTxResult {
	v := NewstepUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type stepFindFirst struct {
	query builder.Query
}

func (r stepFindFirst) getQuery() builder.Query {
	return r.query
}

func (r stepFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r stepFindFirst) with()         {}
func (r stepFindFirst) stepModel()    {}
func (r stepFindFirst) stepRelation() {}

func (r stepActions) FindFirst(
	params ...StepWhereParam,
) stepFindFirst {
	var v stepFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Step"
	v.query.Outputs = stepOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r stepFindFirst) With(params ...StepRelationWith) stepFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r stepFindFirst) OrderBy(params ...StepOrderByParam) stepFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r stepFindFirst) Skip(count int) stepFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r stepFindFirst) Take(count int) stepFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r stepFindFirst) Cursor(cursor StepCursorParam) stepFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r stepFindFirst) Exec(ctx context.Context) (
	*StepModel,
	error,
) {
	var v *StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r stepFindFirst) ExecInner(ctx context.Context) (
	*InnerStep,
	error,
) {
	var v *InnerStep
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type stepFindMany struct {
	query builder.Query
}

func (r stepFindMany) getQuery() builder.Query {
	return r.query
}

func (r stepFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r stepFindMany) with()         {}
func (r stepFindMany) stepModel()    {}
func (r stepFindMany) stepRelation() {}

func (r stepActions) FindMany(
	params ...StepWhereParam,
) stepFindMany {
	var v stepFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Step"
	v.query.Outputs = stepOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r stepFindMany) With(params ...StepRelationWith) stepFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r stepFindMany) OrderBy(params ...StepOrderByParam) stepFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r stepFindMany) Skip(count int) stepFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r stepFindMany) Take(count int) stepFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r stepFindMany) Cursor(cursor StepCursorParam) stepFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r stepFindMany) Exec(ctx context.Context) (
	[]StepModel,
	error,
) {
	var v []StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r stepFindMany) ExecInner(ctx context.Context) (
	[]InnerStep,
	error,
) {
	var v []InnerStep
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r stepFindMany) Update(params ...StepSetParam) stepUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Step"

	r.query.Outputs = countOutput

	var v stepUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type stepUpdateMany struct {
	query builder.Query
}

func (r stepUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r stepUpdateMany) stepModel() {}

func (r stepUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r stepUpdateMany) Tx() stepManyTxResult {
	v := NewstepManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r stepFindMany) Delete() stepDeleteMany {
	var v stepDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Step"

	v.query.Outputs = countOutput

	return v
}

type stepDeleteMany struct {
	query builder.Query
}

func (r stepDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p stepDeleteMany) stepModel() {}

func (r stepDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r stepDeleteMany) Tx() stepManyTxResult {
	v := NewstepManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type runToNetFindUnique struct {
	query builder.Query
}

func (r runToNetFindUnique) getQuery() builder.Query {
	return r.query
}

func (r runToNetFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r runToNetFindUnique) with()        {}
func (r runToNetFindUnique) runModel()    {}
func (r runToNetFindUnique) runRelation() {}

func (r runToNetFindUnique) With(params ...NetRelationWith) runToNetFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r runToNetFindUnique) Exec(ctx context.Context) (
	*RunModel,
	error,
) {
	var v *RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r runToNetFindUnique) ExecInner(ctx context.Context) (
	*InnerRun,
	error,
) {
	var v *InnerRun
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r runToNetFindUnique) Update(params ...RunSetParam) runToNetUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Run"

	var v runToNetUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type runToNetUpdateUnique struct {
	query builder.Query
}

func (r runToNetUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r runToNetUpdateUnique) runModel() {}

func (r runToNetUpdateUnique) Exec(ctx context.Context) (*RunModel, error) {
	var v RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runToNetUpdateUnique) Tx() runUniqueTxResult {
	v := NewrunUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r runToNetFindUnique) Delete() runToNetDeleteUnique {
	var v runToNetDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Run"

	return v
}

type runToNetDeleteUnique struct {
	query builder.Query
}

func (r runToNetDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p runToNetDeleteUnique) runModel() {}

func (r runToNetDeleteUnique) Exec(ctx context.Context) (*RunModel, error) {
	var v RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runToNetDeleteUnique) Tx() runUniqueTxResult {
	v := NewrunUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type runToNetFindFirst struct {
	query builder.Query
}

func (r runToNetFindFirst) getQuery() builder.Query {
	return r.query
}

func (r runToNetFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r runToNetFindFirst) with()        {}
func (r runToNetFindFirst) runModel()    {}
func (r runToNetFindFirst) runRelation() {}

func (r runToNetFindFirst) With(params ...NetRelationWith) runToNetFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r runToNetFindFirst) OrderBy(params ...NetOrderByParam) runToNetFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r runToNetFindFirst) Skip(count int) runToNetFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r runToNetFindFirst) Take(count int) runToNetFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r runToNetFindFirst) Cursor(cursor RunCursorParam) runToNetFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r runToNetFindFirst) Exec(ctx context.Context) (
	*RunModel,
	error,
) {
	var v *RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r runToNetFindFirst) ExecInner(ctx context.Context) (
	*InnerRun,
	error,
) {
	var v *InnerRun
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type runToNetFindMany struct {
	query builder.Query
}

func (r runToNetFindMany) getQuery() builder.Query {
	return r.query
}

func (r runToNetFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r runToNetFindMany) with()        {}
func (r runToNetFindMany) runModel()    {}
func (r runToNetFindMany) runRelation() {}

func (r runToNetFindMany) With(params ...NetRelationWith) runToNetFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r runToNetFindMany) OrderBy(params ...NetOrderByParam) runToNetFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r runToNetFindMany) Skip(count int) runToNetFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r runToNetFindMany) Take(count int) runToNetFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r runToNetFindMany) Cursor(cursor RunCursorParam) runToNetFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r runToNetFindMany) Exec(ctx context.Context) (
	[]RunModel,
	error,
) {
	var v []RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r runToNetFindMany) ExecInner(ctx context.Context) (
	[]InnerRun,
	error,
) {
	var v []InnerRun
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r runToNetFindMany) Update(params ...RunSetParam) runToNetUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Run"

	r.query.Outputs = countOutput

	var v runToNetUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type runToNetUpdateMany struct {
	query builder.Query
}

func (r runToNetUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r runToNetUpdateMany) runModel() {}

func (r runToNetUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runToNetUpdateMany) Tx() runManyTxResult {
	v := NewrunManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r runToNetFindMany) Delete() runToNetDeleteMany {
	var v runToNetDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Run"

	v.query.Outputs = countOutput

	return v
}

type runToNetDeleteMany struct {
	query builder.Query
}

func (r runToNetDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p runToNetDeleteMany) runModel() {}

func (r runToNetDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runToNetDeleteMany) Tx() runManyTxResult {
	v := NewrunManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type runToSessionsFindUnique struct {
	query builder.Query
}

func (r runToSessionsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r runToSessionsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r runToSessionsFindUnique) with()        {}
func (r runToSessionsFindUnique) runModel()    {}
func (r runToSessionsFindUnique) runRelation() {}

func (r runToSessionsFindUnique) With(params ...SessionRelationWith) runToSessionsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r runToSessionsFindUnique) Exec(ctx context.Context) (
	*RunModel,
	error,
) {
	var v *RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r runToSessionsFindUnique) ExecInner(ctx context.Context) (
	*InnerRun,
	error,
) {
	var v *InnerRun
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r runToSessionsFindUnique) Update(params ...RunSetParam) runToSessionsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Run"

	var v runToSessionsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type runToSessionsUpdateUnique struct {
	query builder.Query
}

func (r runToSessionsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r runToSessionsUpdateUnique) runModel() {}

func (r runToSessionsUpdateUnique) Exec(ctx context.Context) (*RunModel, error) {
	var v RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runToSessionsUpdateUnique) Tx() runUniqueTxResult {
	v := NewrunUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r runToSessionsFindUnique) Delete() runToSessionsDeleteUnique {
	var v runToSessionsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Run"

	return v
}

type runToSessionsDeleteUnique struct {
	query builder.Query
}

func (r runToSessionsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p runToSessionsDeleteUnique) runModel() {}

func (r runToSessionsDeleteUnique) Exec(ctx context.Context) (*RunModel, error) {
	var v RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runToSessionsDeleteUnique) Tx() runUniqueTxResult {
	v := NewrunUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type runToSessionsFindFirst struct {
	query builder.Query
}

func (r runToSessionsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r runToSessionsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r runToSessionsFindFirst) with()        {}
func (r runToSessionsFindFirst) runModel()    {}
func (r runToSessionsFindFirst) runRelation() {}

func (r runToSessionsFindFirst) With(params ...SessionRelationWith) runToSessionsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r runToSessionsFindFirst) OrderBy(params ...SessionOrderByParam) runToSessionsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r runToSessionsFindFirst) Skip(count int) runToSessionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r runToSessionsFindFirst) Take(count int) runToSessionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r runToSessionsFindFirst) Cursor(cursor RunCursorParam) runToSessionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r runToSessionsFindFirst) Exec(ctx context.Context) (
	*RunModel,
	error,
) {
	var v *RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r runToSessionsFindFirst) ExecInner(ctx context.Context) (
	*InnerRun,
	error,
) {
	var v *InnerRun
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type runToSessionsFindMany struct {
	query builder.Query
}

func (r runToSessionsFindMany) getQuery() builder.Query {
	return r.query
}

func (r runToSessionsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r runToSessionsFindMany) with()        {}
func (r runToSessionsFindMany) runModel()    {}
func (r runToSessionsFindMany) runRelation() {}

func (r runToSessionsFindMany) With(params ...SessionRelationWith) runToSessionsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r runToSessionsFindMany) OrderBy(params ...SessionOrderByParam) runToSessionsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r runToSessionsFindMany) Skip(count int) runToSessionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r runToSessionsFindMany) Take(count int) runToSessionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r runToSessionsFindMany) Cursor(cursor RunCursorParam) runToSessionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r runToSessionsFindMany) Exec(ctx context.Context) (
	[]RunModel,
	error,
) {
	var v []RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r runToSessionsFindMany) ExecInner(ctx context.Context) (
	[]InnerRun,
	error,
) {
	var v []InnerRun
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r runToSessionsFindMany) Update(params ...RunSetParam) runToSessionsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Run"

	r.query.Outputs = countOutput

	var v runToSessionsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type runToSessionsUpdateMany struct {
	query builder.Query
}

func (r runToSessionsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r runToSessionsUpdateMany) runModel() {}

func (r runToSessionsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runToSessionsUpdateMany) Tx() runManyTxResult {
	v := NewrunManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r runToSessionsFindMany) Delete() runToSessionsDeleteMany {
	var v runToSessionsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Run"

	v.query.Outputs = countOutput

	return v
}

type runToSessionsDeleteMany struct {
	query builder.Query
}

func (r runToSessionsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p runToSessionsDeleteMany) runModel() {}

func (r runToSessionsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runToSessionsDeleteMany) Tx() runManyTxResult {
	v := NewrunManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type runToStepsFindUnique struct {
	query builder.Query
}

func (r runToStepsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r runToStepsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r runToStepsFindUnique) with()        {}
func (r runToStepsFindUnique) runModel()    {}
func (r runToStepsFindUnique) runRelation() {}

func (r runToStepsFindUnique) With(params ...StepRelationWith) runToStepsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r runToStepsFindUnique) Exec(ctx context.Context) (
	*RunModel,
	error,
) {
	var v *RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r runToStepsFindUnique) ExecInner(ctx context.Context) (
	*InnerRun,
	error,
) {
	var v *InnerRun
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r runToStepsFindUnique) Update(params ...RunSetParam) runToStepsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Run"

	var v runToStepsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type runToStepsUpdateUnique struct {
	query builder.Query
}

func (r runToStepsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r runToStepsUpdateUnique) runModel() {}

func (r runToStepsUpdateUnique) Exec(ctx context.Context) (*RunModel, error) {
	var v RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runToStepsUpdateUnique) Tx() runUniqueTxResult {
	v := NewrunUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r runToStepsFindUnique) Delete() runToStepsDeleteUnique {
	var v runToStepsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Run"

	return v
}

type runToStepsDeleteUnique struct {
	query builder.Query
}

func (r runToStepsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p runToStepsDeleteUnique) runModel() {}

func (r runToStepsDeleteUnique) Exec(ctx context.Context) (*RunModel, error) {
	var v RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runToStepsDeleteUnique) Tx() runUniqueTxResult {
	v := NewrunUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type runToStepsFindFirst struct {
	query builder.Query
}

func (r runToStepsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r runToStepsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r runToStepsFindFirst) with()        {}
func (r runToStepsFindFirst) runModel()    {}
func (r runToStepsFindFirst) runRelation() {}

func (r runToStepsFindFirst) With(params ...StepRelationWith) runToStepsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r runToStepsFindFirst) OrderBy(params ...StepOrderByParam) runToStepsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r runToStepsFindFirst) Skip(count int) runToStepsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r runToStepsFindFirst) Take(count int) runToStepsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r runToStepsFindFirst) Cursor(cursor RunCursorParam) runToStepsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r runToStepsFindFirst) Exec(ctx context.Context) (
	*RunModel,
	error,
) {
	var v *RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r runToStepsFindFirst) ExecInner(ctx context.Context) (
	*InnerRun,
	error,
) {
	var v *InnerRun
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type runToStepsFindMany struct {
	query builder.Query
}

func (r runToStepsFindMany) getQuery() builder.Query {
	return r.query
}

func (r runToStepsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r runToStepsFindMany) with()        {}
func (r runToStepsFindMany) runModel()    {}
func (r runToStepsFindMany) runRelation() {}

func (r runToStepsFindMany) With(params ...StepRelationWith) runToStepsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r runToStepsFindMany) OrderBy(params ...StepOrderByParam) runToStepsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r runToStepsFindMany) Skip(count int) runToStepsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r runToStepsFindMany) Take(count int) runToStepsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r runToStepsFindMany) Cursor(cursor RunCursorParam) runToStepsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r runToStepsFindMany) Exec(ctx context.Context) (
	[]RunModel,
	error,
) {
	var v []RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r runToStepsFindMany) ExecInner(ctx context.Context) (
	[]InnerRun,
	error,
) {
	var v []InnerRun
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r runToStepsFindMany) Update(params ...RunSetParam) runToStepsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Run"

	r.query.Outputs = countOutput

	var v runToStepsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type runToStepsUpdateMany struct {
	query builder.Query
}

func (r runToStepsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r runToStepsUpdateMany) runModel() {}

func (r runToStepsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runToStepsUpdateMany) Tx() runManyTxResult {
	v := NewrunManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r runToStepsFindMany) Delete() runToStepsDeleteMany {
	var v runToStepsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Run"

	v.query.Outputs = countOutput

	return v
}

type runToStepsDeleteMany struct {
	query builder.Query
}

func (r runToStepsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p runToStepsDeleteMany) runModel() {}

func (r runToStepsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runToStepsDeleteMany) Tx() runManyTxResult {
	v := NewrunManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type runFindUnique struct {
	query builder.Query
}

func (r runFindUnique) getQuery() builder.Query {
	return r.query
}

func (r runFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r runFindUnique) with()        {}
func (r runFindUnique) runModel()    {}
func (r runFindUnique) runRelation() {}

func (r runActions) FindUnique(
	params RunEqualsUniqueWhereParam,
) runFindUnique {
	var v runFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Run"
	v.query.Outputs = runOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r runFindUnique) With(params ...RunRelationWith) runFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r runFindUnique) Exec(ctx context.Context) (
	*RunModel,
	error,
) {
	var v *RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r runFindUnique) ExecInner(ctx context.Context) (
	*InnerRun,
	error,
) {
	var v *InnerRun
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r runFindUnique) Update(params ...RunSetParam) runUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Run"

	var v runUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type runUpdateUnique struct {
	query builder.Query
}

func (r runUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r runUpdateUnique) runModel() {}

func (r runUpdateUnique) Exec(ctx context.Context) (*RunModel, error) {
	var v RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runUpdateUnique) Tx() runUniqueTxResult {
	v := NewrunUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r runFindUnique) Delete() runDeleteUnique {
	var v runDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Run"

	return v
}

type runDeleteUnique struct {
	query builder.Query
}

func (r runDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p runDeleteUnique) runModel() {}

func (r runDeleteUnique) Exec(ctx context.Context) (*RunModel, error) {
	var v RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runDeleteUnique) Tx() runUniqueTxResult {
	v := NewrunUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type runFindFirst struct {
	query builder.Query
}

func (r runFindFirst) getQuery() builder.Query {
	return r.query
}

func (r runFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r runFindFirst) with()        {}
func (r runFindFirst) runModel()    {}
func (r runFindFirst) runRelation() {}

func (r runActions) FindFirst(
	params ...RunWhereParam,
) runFindFirst {
	var v runFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Run"
	v.query.Outputs = runOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r runFindFirst) With(params ...RunRelationWith) runFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r runFindFirst) OrderBy(params ...RunOrderByParam) runFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r runFindFirst) Skip(count int) runFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r runFindFirst) Take(count int) runFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r runFindFirst) Cursor(cursor RunCursorParam) runFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r runFindFirst) Exec(ctx context.Context) (
	*RunModel,
	error,
) {
	var v *RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r runFindFirst) ExecInner(ctx context.Context) (
	*InnerRun,
	error,
) {
	var v *InnerRun
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type runFindMany struct {
	query builder.Query
}

func (r runFindMany) getQuery() builder.Query {
	return r.query
}

func (r runFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r runFindMany) with()        {}
func (r runFindMany) runModel()    {}
func (r runFindMany) runRelation() {}

func (r runActions) FindMany(
	params ...RunWhereParam,
) runFindMany {
	var v runFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Run"
	v.query.Outputs = runOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r runFindMany) With(params ...RunRelationWith) runFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r runFindMany) OrderBy(params ...RunOrderByParam) runFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r runFindMany) Skip(count int) runFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r runFindMany) Take(count int) runFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r runFindMany) Cursor(cursor RunCursorParam) runFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r runFindMany) Exec(ctx context.Context) (
	[]RunModel,
	error,
) {
	var v []RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r runFindMany) ExecInner(ctx context.Context) (
	[]InnerRun,
	error,
) {
	var v []InnerRun
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r runFindMany) Update(params ...RunSetParam) runUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Run"

	r.query.Outputs = countOutput

	var v runUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type runUpdateMany struct {
	query builder.Query
}

func (r runUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r runUpdateMany) runModel() {}

func (r runUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runUpdateMany) Tx() runManyTxResult {
	v := NewrunManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r runFindMany) Delete() runDeleteMany {
	var v runDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Run"

	v.query.Outputs = countOutput

	return v
}

type runDeleteMany struct {
	query builder.Query
}

func (r runDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p runDeleteMany) runModel() {}

func (r runDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runDeleteMany) Tx() runManyTxResult {
	v := NewrunManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type datumToInstanceFindUnique struct {
	query builder.Query
}

func (r datumToInstanceFindUnique) getQuery() builder.Query {
	return r.query
}

func (r datumToInstanceFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r datumToInstanceFindUnique) with()          {}
func (r datumToInstanceFindUnique) datumModel()    {}
func (r datumToInstanceFindUnique) datumRelation() {}

func (r datumToInstanceFindUnique) With(params ...InstanceRelationWith) datumToInstanceFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r datumToInstanceFindUnique) Exec(ctx context.Context) (
	*DatumModel,
	error,
) {
	var v *DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r datumToInstanceFindUnique) ExecInner(ctx context.Context) (
	*InnerDatum,
	error,
) {
	var v *InnerDatum
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r datumToInstanceFindUnique) Update(params ...DatumSetParam) datumToInstanceUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Datum"

	var v datumToInstanceUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type datumToInstanceUpdateUnique struct {
	query builder.Query
}

func (r datumToInstanceUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r datumToInstanceUpdateUnique) datumModel() {}

func (r datumToInstanceUpdateUnique) Exec(ctx context.Context) (*DatumModel, error) {
	var v DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumToInstanceUpdateUnique) Tx() datumUniqueTxResult {
	v := NewdatumUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r datumToInstanceFindUnique) Delete() datumToInstanceDeleteUnique {
	var v datumToInstanceDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Datum"

	return v
}

type datumToInstanceDeleteUnique struct {
	query builder.Query
}

func (r datumToInstanceDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p datumToInstanceDeleteUnique) datumModel() {}

func (r datumToInstanceDeleteUnique) Exec(ctx context.Context) (*DatumModel, error) {
	var v DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumToInstanceDeleteUnique) Tx() datumUniqueTxResult {
	v := NewdatumUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type datumToInstanceFindFirst struct {
	query builder.Query
}

func (r datumToInstanceFindFirst) getQuery() builder.Query {
	return r.query
}

func (r datumToInstanceFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r datumToInstanceFindFirst) with()          {}
func (r datumToInstanceFindFirst) datumModel()    {}
func (r datumToInstanceFindFirst) datumRelation() {}

func (r datumToInstanceFindFirst) With(params ...InstanceRelationWith) datumToInstanceFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r datumToInstanceFindFirst) OrderBy(params ...InstanceOrderByParam) datumToInstanceFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r datumToInstanceFindFirst) Skip(count int) datumToInstanceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r datumToInstanceFindFirst) Take(count int) datumToInstanceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r datumToInstanceFindFirst) Cursor(cursor DatumCursorParam) datumToInstanceFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r datumToInstanceFindFirst) Exec(ctx context.Context) (
	*DatumModel,
	error,
) {
	var v *DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r datumToInstanceFindFirst) ExecInner(ctx context.Context) (
	*InnerDatum,
	error,
) {
	var v *InnerDatum
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type datumToInstanceFindMany struct {
	query builder.Query
}

func (r datumToInstanceFindMany) getQuery() builder.Query {
	return r.query
}

func (r datumToInstanceFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r datumToInstanceFindMany) with()          {}
func (r datumToInstanceFindMany) datumModel()    {}
func (r datumToInstanceFindMany) datumRelation() {}

func (r datumToInstanceFindMany) With(params ...InstanceRelationWith) datumToInstanceFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r datumToInstanceFindMany) OrderBy(params ...InstanceOrderByParam) datumToInstanceFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r datumToInstanceFindMany) Skip(count int) datumToInstanceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r datumToInstanceFindMany) Take(count int) datumToInstanceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r datumToInstanceFindMany) Cursor(cursor DatumCursorParam) datumToInstanceFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r datumToInstanceFindMany) Exec(ctx context.Context) (
	[]DatumModel,
	error,
) {
	var v []DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r datumToInstanceFindMany) ExecInner(ctx context.Context) (
	[]InnerDatum,
	error,
) {
	var v []InnerDatum
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r datumToInstanceFindMany) Update(params ...DatumSetParam) datumToInstanceUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Datum"

	r.query.Outputs = countOutput

	var v datumToInstanceUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type datumToInstanceUpdateMany struct {
	query builder.Query
}

func (r datumToInstanceUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r datumToInstanceUpdateMany) datumModel() {}

func (r datumToInstanceUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumToInstanceUpdateMany) Tx() datumManyTxResult {
	v := NewdatumManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r datumToInstanceFindMany) Delete() datumToInstanceDeleteMany {
	var v datumToInstanceDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Datum"

	v.query.Outputs = countOutput

	return v
}

type datumToInstanceDeleteMany struct {
	query builder.Query
}

func (r datumToInstanceDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p datumToInstanceDeleteMany) datumModel() {}

func (r datumToInstanceDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumToInstanceDeleteMany) Tx() datumManyTxResult {
	v := NewdatumManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type datumToSessionFindUnique struct {
	query builder.Query
}

func (r datumToSessionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r datumToSessionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r datumToSessionFindUnique) with()          {}
func (r datumToSessionFindUnique) datumModel()    {}
func (r datumToSessionFindUnique) datumRelation() {}

func (r datumToSessionFindUnique) With(params ...SessionRelationWith) datumToSessionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r datumToSessionFindUnique) Exec(ctx context.Context) (
	*DatumModel,
	error,
) {
	var v *DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r datumToSessionFindUnique) ExecInner(ctx context.Context) (
	*InnerDatum,
	error,
) {
	var v *InnerDatum
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r datumToSessionFindUnique) Update(params ...DatumSetParam) datumToSessionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Datum"

	var v datumToSessionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type datumToSessionUpdateUnique struct {
	query builder.Query
}

func (r datumToSessionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r datumToSessionUpdateUnique) datumModel() {}

func (r datumToSessionUpdateUnique) Exec(ctx context.Context) (*DatumModel, error) {
	var v DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumToSessionUpdateUnique) Tx() datumUniqueTxResult {
	v := NewdatumUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r datumToSessionFindUnique) Delete() datumToSessionDeleteUnique {
	var v datumToSessionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Datum"

	return v
}

type datumToSessionDeleteUnique struct {
	query builder.Query
}

func (r datumToSessionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p datumToSessionDeleteUnique) datumModel() {}

func (r datumToSessionDeleteUnique) Exec(ctx context.Context) (*DatumModel, error) {
	var v DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumToSessionDeleteUnique) Tx() datumUniqueTxResult {
	v := NewdatumUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type datumToSessionFindFirst struct {
	query builder.Query
}

func (r datumToSessionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r datumToSessionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r datumToSessionFindFirst) with()          {}
func (r datumToSessionFindFirst) datumModel()    {}
func (r datumToSessionFindFirst) datumRelation() {}

func (r datumToSessionFindFirst) With(params ...SessionRelationWith) datumToSessionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r datumToSessionFindFirst) OrderBy(params ...SessionOrderByParam) datumToSessionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r datumToSessionFindFirst) Skip(count int) datumToSessionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r datumToSessionFindFirst) Take(count int) datumToSessionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r datumToSessionFindFirst) Cursor(cursor DatumCursorParam) datumToSessionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r datumToSessionFindFirst) Exec(ctx context.Context) (
	*DatumModel,
	error,
) {
	var v *DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r datumToSessionFindFirst) ExecInner(ctx context.Context) (
	*InnerDatum,
	error,
) {
	var v *InnerDatum
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type datumToSessionFindMany struct {
	query builder.Query
}

func (r datumToSessionFindMany) getQuery() builder.Query {
	return r.query
}

func (r datumToSessionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r datumToSessionFindMany) with()          {}
func (r datumToSessionFindMany) datumModel()    {}
func (r datumToSessionFindMany) datumRelation() {}

func (r datumToSessionFindMany) With(params ...SessionRelationWith) datumToSessionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r datumToSessionFindMany) OrderBy(params ...SessionOrderByParam) datumToSessionFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r datumToSessionFindMany) Skip(count int) datumToSessionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r datumToSessionFindMany) Take(count int) datumToSessionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r datumToSessionFindMany) Cursor(cursor DatumCursorParam) datumToSessionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r datumToSessionFindMany) Exec(ctx context.Context) (
	[]DatumModel,
	error,
) {
	var v []DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r datumToSessionFindMany) ExecInner(ctx context.Context) (
	[]InnerDatum,
	error,
) {
	var v []InnerDatum
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r datumToSessionFindMany) Update(params ...DatumSetParam) datumToSessionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Datum"

	r.query.Outputs = countOutput

	var v datumToSessionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type datumToSessionUpdateMany struct {
	query builder.Query
}

func (r datumToSessionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r datumToSessionUpdateMany) datumModel() {}

func (r datumToSessionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumToSessionUpdateMany) Tx() datumManyTxResult {
	v := NewdatumManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r datumToSessionFindMany) Delete() datumToSessionDeleteMany {
	var v datumToSessionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Datum"

	v.query.Outputs = countOutput

	return v
}

type datumToSessionDeleteMany struct {
	query builder.Query
}

func (r datumToSessionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p datumToSessionDeleteMany) datumModel() {}

func (r datumToSessionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumToSessionDeleteMany) Tx() datumManyTxResult {
	v := NewdatumManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type datumToEventFindUnique struct {
	query builder.Query
}

func (r datumToEventFindUnique) getQuery() builder.Query {
	return r.query
}

func (r datumToEventFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r datumToEventFindUnique) with()          {}
func (r datumToEventFindUnique) datumModel()    {}
func (r datumToEventFindUnique) datumRelation() {}

func (r datumToEventFindUnique) With(params ...EventRelationWith) datumToEventFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r datumToEventFindUnique) Exec(ctx context.Context) (
	*DatumModel,
	error,
) {
	var v *DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r datumToEventFindUnique) ExecInner(ctx context.Context) (
	*InnerDatum,
	error,
) {
	var v *InnerDatum
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r datumToEventFindUnique) Update(params ...DatumSetParam) datumToEventUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Datum"

	var v datumToEventUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type datumToEventUpdateUnique struct {
	query builder.Query
}

func (r datumToEventUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r datumToEventUpdateUnique) datumModel() {}

func (r datumToEventUpdateUnique) Exec(ctx context.Context) (*DatumModel, error) {
	var v DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumToEventUpdateUnique) Tx() datumUniqueTxResult {
	v := NewdatumUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r datumToEventFindUnique) Delete() datumToEventDeleteUnique {
	var v datumToEventDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Datum"

	return v
}

type datumToEventDeleteUnique struct {
	query builder.Query
}

func (r datumToEventDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p datumToEventDeleteUnique) datumModel() {}

func (r datumToEventDeleteUnique) Exec(ctx context.Context) (*DatumModel, error) {
	var v DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumToEventDeleteUnique) Tx() datumUniqueTxResult {
	v := NewdatumUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type datumToEventFindFirst struct {
	query builder.Query
}

func (r datumToEventFindFirst) getQuery() builder.Query {
	return r.query
}

func (r datumToEventFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r datumToEventFindFirst) with()          {}
func (r datumToEventFindFirst) datumModel()    {}
func (r datumToEventFindFirst) datumRelation() {}

func (r datumToEventFindFirst) With(params ...EventRelationWith) datumToEventFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r datumToEventFindFirst) OrderBy(params ...EventOrderByParam) datumToEventFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r datumToEventFindFirst) Skip(count int) datumToEventFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r datumToEventFindFirst) Take(count int) datumToEventFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r datumToEventFindFirst) Cursor(cursor DatumCursorParam) datumToEventFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r datumToEventFindFirst) Exec(ctx context.Context) (
	*DatumModel,
	error,
) {
	var v *DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r datumToEventFindFirst) ExecInner(ctx context.Context) (
	*InnerDatum,
	error,
) {
	var v *InnerDatum
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type datumToEventFindMany struct {
	query builder.Query
}

func (r datumToEventFindMany) getQuery() builder.Query {
	return r.query
}

func (r datumToEventFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r datumToEventFindMany) with()          {}
func (r datumToEventFindMany) datumModel()    {}
func (r datumToEventFindMany) datumRelation() {}

func (r datumToEventFindMany) With(params ...EventRelationWith) datumToEventFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r datumToEventFindMany) OrderBy(params ...EventOrderByParam) datumToEventFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r datumToEventFindMany) Skip(count int) datumToEventFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r datumToEventFindMany) Take(count int) datumToEventFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r datumToEventFindMany) Cursor(cursor DatumCursorParam) datumToEventFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r datumToEventFindMany) Exec(ctx context.Context) (
	[]DatumModel,
	error,
) {
	var v []DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r datumToEventFindMany) ExecInner(ctx context.Context) (
	[]InnerDatum,
	error,
) {
	var v []InnerDatum
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r datumToEventFindMany) Update(params ...DatumSetParam) datumToEventUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Datum"

	r.query.Outputs = countOutput

	var v datumToEventUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type datumToEventUpdateMany struct {
	query builder.Query
}

func (r datumToEventUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r datumToEventUpdateMany) datumModel() {}

func (r datumToEventUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumToEventUpdateMany) Tx() datumManyTxResult {
	v := NewdatumManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r datumToEventFindMany) Delete() datumToEventDeleteMany {
	var v datumToEventDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Datum"

	v.query.Outputs = countOutput

	return v
}

type datumToEventDeleteMany struct {
	query builder.Query
}

func (r datumToEventDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p datumToEventDeleteMany) datumModel() {}

func (r datumToEventDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumToEventDeleteMany) Tx() datumManyTxResult {
	v := NewdatumManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type datumFindUnique struct {
	query builder.Query
}

func (r datumFindUnique) getQuery() builder.Query {
	return r.query
}

func (r datumFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r datumFindUnique) with()          {}
func (r datumFindUnique) datumModel()    {}
func (r datumFindUnique) datumRelation() {}

func (r datumActions) FindUnique(
	params DatumEqualsUniqueWhereParam,
) datumFindUnique {
	var v datumFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Datum"
	v.query.Outputs = datumOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r datumFindUnique) With(params ...DatumRelationWith) datumFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r datumFindUnique) Exec(ctx context.Context) (
	*DatumModel,
	error,
) {
	var v *DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r datumFindUnique) ExecInner(ctx context.Context) (
	*InnerDatum,
	error,
) {
	var v *InnerDatum
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r datumFindUnique) Update(params ...DatumSetParam) datumUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Datum"

	var v datumUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type datumUpdateUnique struct {
	query builder.Query
}

func (r datumUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r datumUpdateUnique) datumModel() {}

func (r datumUpdateUnique) Exec(ctx context.Context) (*DatumModel, error) {
	var v DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumUpdateUnique) Tx() datumUniqueTxResult {
	v := NewdatumUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r datumFindUnique) Delete() datumDeleteUnique {
	var v datumDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Datum"

	return v
}

type datumDeleteUnique struct {
	query builder.Query
}

func (r datumDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p datumDeleteUnique) datumModel() {}

func (r datumDeleteUnique) Exec(ctx context.Context) (*DatumModel, error) {
	var v DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumDeleteUnique) Tx() datumUniqueTxResult {
	v := NewdatumUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type datumFindFirst struct {
	query builder.Query
}

func (r datumFindFirst) getQuery() builder.Query {
	return r.query
}

func (r datumFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r datumFindFirst) with()          {}
func (r datumFindFirst) datumModel()    {}
func (r datumFindFirst) datumRelation() {}

func (r datumActions) FindFirst(
	params ...DatumWhereParam,
) datumFindFirst {
	var v datumFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Datum"
	v.query.Outputs = datumOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r datumFindFirst) With(params ...DatumRelationWith) datumFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r datumFindFirst) OrderBy(params ...DatumOrderByParam) datumFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r datumFindFirst) Skip(count int) datumFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r datumFindFirst) Take(count int) datumFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r datumFindFirst) Cursor(cursor DatumCursorParam) datumFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r datumFindFirst) Exec(ctx context.Context) (
	*DatumModel,
	error,
) {
	var v *DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r datumFindFirst) ExecInner(ctx context.Context) (
	*InnerDatum,
	error,
) {
	var v *InnerDatum
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type datumFindMany struct {
	query builder.Query
}

func (r datumFindMany) getQuery() builder.Query {
	return r.query
}

func (r datumFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r datumFindMany) with()          {}
func (r datumFindMany) datumModel()    {}
func (r datumFindMany) datumRelation() {}

func (r datumActions) FindMany(
	params ...DatumWhereParam,
) datumFindMany {
	var v datumFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Datum"
	v.query.Outputs = datumOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r datumFindMany) With(params ...DatumRelationWith) datumFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r datumFindMany) OrderBy(params ...DatumOrderByParam) datumFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r datumFindMany) Skip(count int) datumFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r datumFindMany) Take(count int) datumFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r datumFindMany) Cursor(cursor DatumCursorParam) datumFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r datumFindMany) Exec(ctx context.Context) (
	[]DatumModel,
	error,
) {
	var v []DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r datumFindMany) ExecInner(ctx context.Context) (
	[]InnerDatum,
	error,
) {
	var v []InnerDatum
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r datumFindMany) Update(params ...DatumSetParam) datumUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Datum"

	r.query.Outputs = countOutput

	var v datumUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type datumUpdateMany struct {
	query builder.Query
}

func (r datumUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r datumUpdateMany) datumModel() {}

func (r datumUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumUpdateMany) Tx() datumManyTxResult {
	v := NewdatumManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r datumFindMany) Delete() datumDeleteMany {
	var v datumDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Datum"

	v.query.Outputs = countOutput

	return v
}

type datumDeleteMany struct {
	query builder.Query
}

func (r datumDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p datumDeleteMany) datumModel() {}

func (r datumDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumDeleteMany) Tx() datumManyTxResult {
	v := NewdatumManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type sessionToUserFindUnique struct {
	query builder.Query
}

func (r sessionToUserFindUnique) getQuery() builder.Query {
	return r.query
}

func (r sessionToUserFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToUserFindUnique) with()            {}
func (r sessionToUserFindUnique) sessionModel()    {}
func (r sessionToUserFindUnique) sessionRelation() {}

func (r sessionToUserFindUnique) With(params ...UserRelationWith) sessionToUserFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r sessionToUserFindUnique) Exec(ctx context.Context) (
	*SessionModel,
	error,
) {
	var v *SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r sessionToUserFindUnique) ExecInner(ctx context.Context) (
	*InnerSession,
	error,
) {
	var v *InnerSession
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r sessionToUserFindUnique) Update(params ...SessionSetParam) sessionToUserUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Session"

	var v sessionToUserUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type sessionToUserUpdateUnique struct {
	query builder.Query
}

func (r sessionToUserUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToUserUpdateUnique) sessionModel() {}

func (r sessionToUserUpdateUnique) Exec(ctx context.Context) (*SessionModel, error) {
	var v SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionToUserUpdateUnique) Tx() sessionUniqueTxResult {
	v := NewsessionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r sessionToUserFindUnique) Delete() sessionToUserDeleteUnique {
	var v sessionToUserDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Session"

	return v
}

type sessionToUserDeleteUnique struct {
	query builder.Query
}

func (r sessionToUserDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p sessionToUserDeleteUnique) sessionModel() {}

func (r sessionToUserDeleteUnique) Exec(ctx context.Context) (*SessionModel, error) {
	var v SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionToUserDeleteUnique) Tx() sessionUniqueTxResult {
	v := NewsessionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type sessionToUserFindFirst struct {
	query builder.Query
}

func (r sessionToUserFindFirst) getQuery() builder.Query {
	return r.query
}

func (r sessionToUserFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToUserFindFirst) with()            {}
func (r sessionToUserFindFirst) sessionModel()    {}
func (r sessionToUserFindFirst) sessionRelation() {}

func (r sessionToUserFindFirst) With(params ...UserRelationWith) sessionToUserFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r sessionToUserFindFirst) OrderBy(params ...UserOrderByParam) sessionToUserFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r sessionToUserFindFirst) Skip(count int) sessionToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r sessionToUserFindFirst) Take(count int) sessionToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r sessionToUserFindFirst) Cursor(cursor SessionCursorParam) sessionToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r sessionToUserFindFirst) Exec(ctx context.Context) (
	*SessionModel,
	error,
) {
	var v *SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r sessionToUserFindFirst) ExecInner(ctx context.Context) (
	*InnerSession,
	error,
) {
	var v *InnerSession
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type sessionToUserFindMany struct {
	query builder.Query
}

func (r sessionToUserFindMany) getQuery() builder.Query {
	return r.query
}

func (r sessionToUserFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToUserFindMany) with()            {}
func (r sessionToUserFindMany) sessionModel()    {}
func (r sessionToUserFindMany) sessionRelation() {}

func (r sessionToUserFindMany) With(params ...UserRelationWith) sessionToUserFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r sessionToUserFindMany) OrderBy(params ...UserOrderByParam) sessionToUserFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r sessionToUserFindMany) Skip(count int) sessionToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r sessionToUserFindMany) Take(count int) sessionToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r sessionToUserFindMany) Cursor(cursor SessionCursorParam) sessionToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r sessionToUserFindMany) Exec(ctx context.Context) (
	[]SessionModel,
	error,
) {
	var v []SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r sessionToUserFindMany) ExecInner(ctx context.Context) (
	[]InnerSession,
	error,
) {
	var v []InnerSession
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r sessionToUserFindMany) Update(params ...SessionSetParam) sessionToUserUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Session"

	r.query.Outputs = countOutput

	var v sessionToUserUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type sessionToUserUpdateMany struct {
	query builder.Query
}

func (r sessionToUserUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToUserUpdateMany) sessionModel() {}

func (r sessionToUserUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionToUserUpdateMany) Tx() sessionManyTxResult {
	v := NewsessionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r sessionToUserFindMany) Delete() sessionToUserDeleteMany {
	var v sessionToUserDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Session"

	v.query.Outputs = countOutput

	return v
}

type sessionToUserDeleteMany struct {
	query builder.Query
}

func (r sessionToUserDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p sessionToUserDeleteMany) sessionModel() {}

func (r sessionToUserDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionToUserDeleteMany) Tx() sessionManyTxResult {
	v := NewsessionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type sessionToRunFindUnique struct {
	query builder.Query
}

func (r sessionToRunFindUnique) getQuery() builder.Query {
	return r.query
}

func (r sessionToRunFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToRunFindUnique) with()            {}
func (r sessionToRunFindUnique) sessionModel()    {}
func (r sessionToRunFindUnique) sessionRelation() {}

func (r sessionToRunFindUnique) With(params ...RunRelationWith) sessionToRunFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r sessionToRunFindUnique) Exec(ctx context.Context) (
	*SessionModel,
	error,
) {
	var v *SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r sessionToRunFindUnique) ExecInner(ctx context.Context) (
	*InnerSession,
	error,
) {
	var v *InnerSession
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r sessionToRunFindUnique) Update(params ...SessionSetParam) sessionToRunUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Session"

	var v sessionToRunUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type sessionToRunUpdateUnique struct {
	query builder.Query
}

func (r sessionToRunUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToRunUpdateUnique) sessionModel() {}

func (r sessionToRunUpdateUnique) Exec(ctx context.Context) (*SessionModel, error) {
	var v SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionToRunUpdateUnique) Tx() sessionUniqueTxResult {
	v := NewsessionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r sessionToRunFindUnique) Delete() sessionToRunDeleteUnique {
	var v sessionToRunDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Session"

	return v
}

type sessionToRunDeleteUnique struct {
	query builder.Query
}

func (r sessionToRunDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p sessionToRunDeleteUnique) sessionModel() {}

func (r sessionToRunDeleteUnique) Exec(ctx context.Context) (*SessionModel, error) {
	var v SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionToRunDeleteUnique) Tx() sessionUniqueTxResult {
	v := NewsessionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type sessionToRunFindFirst struct {
	query builder.Query
}

func (r sessionToRunFindFirst) getQuery() builder.Query {
	return r.query
}

func (r sessionToRunFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToRunFindFirst) with()            {}
func (r sessionToRunFindFirst) sessionModel()    {}
func (r sessionToRunFindFirst) sessionRelation() {}

func (r sessionToRunFindFirst) With(params ...RunRelationWith) sessionToRunFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r sessionToRunFindFirst) OrderBy(params ...RunOrderByParam) sessionToRunFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r sessionToRunFindFirst) Skip(count int) sessionToRunFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r sessionToRunFindFirst) Take(count int) sessionToRunFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r sessionToRunFindFirst) Cursor(cursor SessionCursorParam) sessionToRunFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r sessionToRunFindFirst) Exec(ctx context.Context) (
	*SessionModel,
	error,
) {
	var v *SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r sessionToRunFindFirst) ExecInner(ctx context.Context) (
	*InnerSession,
	error,
) {
	var v *InnerSession
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type sessionToRunFindMany struct {
	query builder.Query
}

func (r sessionToRunFindMany) getQuery() builder.Query {
	return r.query
}

func (r sessionToRunFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToRunFindMany) with()            {}
func (r sessionToRunFindMany) sessionModel()    {}
func (r sessionToRunFindMany) sessionRelation() {}

func (r sessionToRunFindMany) With(params ...RunRelationWith) sessionToRunFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r sessionToRunFindMany) OrderBy(params ...RunOrderByParam) sessionToRunFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r sessionToRunFindMany) Skip(count int) sessionToRunFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r sessionToRunFindMany) Take(count int) sessionToRunFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r sessionToRunFindMany) Cursor(cursor SessionCursorParam) sessionToRunFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r sessionToRunFindMany) Exec(ctx context.Context) (
	[]SessionModel,
	error,
) {
	var v []SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r sessionToRunFindMany) ExecInner(ctx context.Context) (
	[]InnerSession,
	error,
) {
	var v []InnerSession
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r sessionToRunFindMany) Update(params ...SessionSetParam) sessionToRunUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Session"

	r.query.Outputs = countOutput

	var v sessionToRunUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type sessionToRunUpdateMany struct {
	query builder.Query
}

func (r sessionToRunUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToRunUpdateMany) sessionModel() {}

func (r sessionToRunUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionToRunUpdateMany) Tx() sessionManyTxResult {
	v := NewsessionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r sessionToRunFindMany) Delete() sessionToRunDeleteMany {
	var v sessionToRunDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Session"

	v.query.Outputs = countOutput

	return v
}

type sessionToRunDeleteMany struct {
	query builder.Query
}

func (r sessionToRunDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p sessionToRunDeleteMany) sessionModel() {}

func (r sessionToRunDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionToRunDeleteMany) Tx() sessionManyTxResult {
	v := NewsessionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type sessionToInstancesFindUnique struct {
	query builder.Query
}

func (r sessionToInstancesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r sessionToInstancesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToInstancesFindUnique) with()            {}
func (r sessionToInstancesFindUnique) sessionModel()    {}
func (r sessionToInstancesFindUnique) sessionRelation() {}

func (r sessionToInstancesFindUnique) With(params ...InstanceRelationWith) sessionToInstancesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r sessionToInstancesFindUnique) Exec(ctx context.Context) (
	*SessionModel,
	error,
) {
	var v *SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r sessionToInstancesFindUnique) ExecInner(ctx context.Context) (
	*InnerSession,
	error,
) {
	var v *InnerSession
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r sessionToInstancesFindUnique) Update(params ...SessionSetParam) sessionToInstancesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Session"

	var v sessionToInstancesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type sessionToInstancesUpdateUnique struct {
	query builder.Query
}

func (r sessionToInstancesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToInstancesUpdateUnique) sessionModel() {}

func (r sessionToInstancesUpdateUnique) Exec(ctx context.Context) (*SessionModel, error) {
	var v SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionToInstancesUpdateUnique) Tx() sessionUniqueTxResult {
	v := NewsessionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r sessionToInstancesFindUnique) Delete() sessionToInstancesDeleteUnique {
	var v sessionToInstancesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Session"

	return v
}

type sessionToInstancesDeleteUnique struct {
	query builder.Query
}

func (r sessionToInstancesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p sessionToInstancesDeleteUnique) sessionModel() {}

func (r sessionToInstancesDeleteUnique) Exec(ctx context.Context) (*SessionModel, error) {
	var v SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionToInstancesDeleteUnique) Tx() sessionUniqueTxResult {
	v := NewsessionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type sessionToInstancesFindFirst struct {
	query builder.Query
}

func (r sessionToInstancesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r sessionToInstancesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToInstancesFindFirst) with()            {}
func (r sessionToInstancesFindFirst) sessionModel()    {}
func (r sessionToInstancesFindFirst) sessionRelation() {}

func (r sessionToInstancesFindFirst) With(params ...InstanceRelationWith) sessionToInstancesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r sessionToInstancesFindFirst) OrderBy(params ...InstanceOrderByParam) sessionToInstancesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r sessionToInstancesFindFirst) Skip(count int) sessionToInstancesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r sessionToInstancesFindFirst) Take(count int) sessionToInstancesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r sessionToInstancesFindFirst) Cursor(cursor SessionCursorParam) sessionToInstancesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r sessionToInstancesFindFirst) Exec(ctx context.Context) (
	*SessionModel,
	error,
) {
	var v *SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r sessionToInstancesFindFirst) ExecInner(ctx context.Context) (
	*InnerSession,
	error,
) {
	var v *InnerSession
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type sessionToInstancesFindMany struct {
	query builder.Query
}

func (r sessionToInstancesFindMany) getQuery() builder.Query {
	return r.query
}

func (r sessionToInstancesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToInstancesFindMany) with()            {}
func (r sessionToInstancesFindMany) sessionModel()    {}
func (r sessionToInstancesFindMany) sessionRelation() {}

func (r sessionToInstancesFindMany) With(params ...InstanceRelationWith) sessionToInstancesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r sessionToInstancesFindMany) OrderBy(params ...InstanceOrderByParam) sessionToInstancesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r sessionToInstancesFindMany) Skip(count int) sessionToInstancesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r sessionToInstancesFindMany) Take(count int) sessionToInstancesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r sessionToInstancesFindMany) Cursor(cursor SessionCursorParam) sessionToInstancesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r sessionToInstancesFindMany) Exec(ctx context.Context) (
	[]SessionModel,
	error,
) {
	var v []SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r sessionToInstancesFindMany) ExecInner(ctx context.Context) (
	[]InnerSession,
	error,
) {
	var v []InnerSession
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r sessionToInstancesFindMany) Update(params ...SessionSetParam) sessionToInstancesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Session"

	r.query.Outputs = countOutput

	var v sessionToInstancesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type sessionToInstancesUpdateMany struct {
	query builder.Query
}

func (r sessionToInstancesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToInstancesUpdateMany) sessionModel() {}

func (r sessionToInstancesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionToInstancesUpdateMany) Tx() sessionManyTxResult {
	v := NewsessionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r sessionToInstancesFindMany) Delete() sessionToInstancesDeleteMany {
	var v sessionToInstancesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Session"

	v.query.Outputs = countOutput

	return v
}

type sessionToInstancesDeleteMany struct {
	query builder.Query
}

func (r sessionToInstancesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p sessionToInstancesDeleteMany) sessionModel() {}

func (r sessionToInstancesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionToInstancesDeleteMany) Tx() sessionManyTxResult {
	v := NewsessionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type sessionToDataFindUnique struct {
	query builder.Query
}

func (r sessionToDataFindUnique) getQuery() builder.Query {
	return r.query
}

func (r sessionToDataFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToDataFindUnique) with()            {}
func (r sessionToDataFindUnique) sessionModel()    {}
func (r sessionToDataFindUnique) sessionRelation() {}

func (r sessionToDataFindUnique) With(params ...DatumRelationWith) sessionToDataFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r sessionToDataFindUnique) Exec(ctx context.Context) (
	*SessionModel,
	error,
) {
	var v *SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r sessionToDataFindUnique) ExecInner(ctx context.Context) (
	*InnerSession,
	error,
) {
	var v *InnerSession
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r sessionToDataFindUnique) Update(params ...SessionSetParam) sessionToDataUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Session"

	var v sessionToDataUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type sessionToDataUpdateUnique struct {
	query builder.Query
}

func (r sessionToDataUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToDataUpdateUnique) sessionModel() {}

func (r sessionToDataUpdateUnique) Exec(ctx context.Context) (*SessionModel, error) {
	var v SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionToDataUpdateUnique) Tx() sessionUniqueTxResult {
	v := NewsessionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r sessionToDataFindUnique) Delete() sessionToDataDeleteUnique {
	var v sessionToDataDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Session"

	return v
}

type sessionToDataDeleteUnique struct {
	query builder.Query
}

func (r sessionToDataDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p sessionToDataDeleteUnique) sessionModel() {}

func (r sessionToDataDeleteUnique) Exec(ctx context.Context) (*SessionModel, error) {
	var v SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionToDataDeleteUnique) Tx() sessionUniqueTxResult {
	v := NewsessionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type sessionToDataFindFirst struct {
	query builder.Query
}

func (r sessionToDataFindFirst) getQuery() builder.Query {
	return r.query
}

func (r sessionToDataFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToDataFindFirst) with()            {}
func (r sessionToDataFindFirst) sessionModel()    {}
func (r sessionToDataFindFirst) sessionRelation() {}

func (r sessionToDataFindFirst) With(params ...DatumRelationWith) sessionToDataFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r sessionToDataFindFirst) OrderBy(params ...DatumOrderByParam) sessionToDataFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r sessionToDataFindFirst) Skip(count int) sessionToDataFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r sessionToDataFindFirst) Take(count int) sessionToDataFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r sessionToDataFindFirst) Cursor(cursor SessionCursorParam) sessionToDataFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r sessionToDataFindFirst) Exec(ctx context.Context) (
	*SessionModel,
	error,
) {
	var v *SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r sessionToDataFindFirst) ExecInner(ctx context.Context) (
	*InnerSession,
	error,
) {
	var v *InnerSession
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type sessionToDataFindMany struct {
	query builder.Query
}

func (r sessionToDataFindMany) getQuery() builder.Query {
	return r.query
}

func (r sessionToDataFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToDataFindMany) with()            {}
func (r sessionToDataFindMany) sessionModel()    {}
func (r sessionToDataFindMany) sessionRelation() {}

func (r sessionToDataFindMany) With(params ...DatumRelationWith) sessionToDataFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r sessionToDataFindMany) OrderBy(params ...DatumOrderByParam) sessionToDataFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r sessionToDataFindMany) Skip(count int) sessionToDataFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r sessionToDataFindMany) Take(count int) sessionToDataFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r sessionToDataFindMany) Cursor(cursor SessionCursorParam) sessionToDataFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r sessionToDataFindMany) Exec(ctx context.Context) (
	[]SessionModel,
	error,
) {
	var v []SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r sessionToDataFindMany) ExecInner(ctx context.Context) (
	[]InnerSession,
	error,
) {
	var v []InnerSession
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r sessionToDataFindMany) Update(params ...SessionSetParam) sessionToDataUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Session"

	r.query.Outputs = countOutput

	var v sessionToDataUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type sessionToDataUpdateMany struct {
	query builder.Query
}

func (r sessionToDataUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionToDataUpdateMany) sessionModel() {}

func (r sessionToDataUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionToDataUpdateMany) Tx() sessionManyTxResult {
	v := NewsessionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r sessionToDataFindMany) Delete() sessionToDataDeleteMany {
	var v sessionToDataDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Session"

	v.query.Outputs = countOutput

	return v
}

type sessionToDataDeleteMany struct {
	query builder.Query
}

func (r sessionToDataDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p sessionToDataDeleteMany) sessionModel() {}

func (r sessionToDataDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionToDataDeleteMany) Tx() sessionManyTxResult {
	v := NewsessionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type sessionFindUnique struct {
	query builder.Query
}

func (r sessionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r sessionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionFindUnique) with()            {}
func (r sessionFindUnique) sessionModel()    {}
func (r sessionFindUnique) sessionRelation() {}

func (r sessionActions) FindUnique(
	params SessionEqualsUniqueWhereParam,
) sessionFindUnique {
	var v sessionFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Session"
	v.query.Outputs = sessionOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r sessionFindUnique) With(params ...SessionRelationWith) sessionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r sessionFindUnique) Exec(ctx context.Context) (
	*SessionModel,
	error,
) {
	var v *SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r sessionFindUnique) ExecInner(ctx context.Context) (
	*InnerSession,
	error,
) {
	var v *InnerSession
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r sessionFindUnique) Update(params ...SessionSetParam) sessionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Session"

	var v sessionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type sessionUpdateUnique struct {
	query builder.Query
}

func (r sessionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionUpdateUnique) sessionModel() {}

func (r sessionUpdateUnique) Exec(ctx context.Context) (*SessionModel, error) {
	var v SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionUpdateUnique) Tx() sessionUniqueTxResult {
	v := NewsessionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r sessionFindUnique) Delete() sessionDeleteUnique {
	var v sessionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Session"

	return v
}

type sessionDeleteUnique struct {
	query builder.Query
}

func (r sessionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p sessionDeleteUnique) sessionModel() {}

func (r sessionDeleteUnique) Exec(ctx context.Context) (*SessionModel, error) {
	var v SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionDeleteUnique) Tx() sessionUniqueTxResult {
	v := NewsessionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type sessionFindFirst struct {
	query builder.Query
}

func (r sessionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r sessionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionFindFirst) with()            {}
func (r sessionFindFirst) sessionModel()    {}
func (r sessionFindFirst) sessionRelation() {}

func (r sessionActions) FindFirst(
	params ...SessionWhereParam,
) sessionFindFirst {
	var v sessionFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Session"
	v.query.Outputs = sessionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r sessionFindFirst) With(params ...SessionRelationWith) sessionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r sessionFindFirst) OrderBy(params ...SessionOrderByParam) sessionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r sessionFindFirst) Skip(count int) sessionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r sessionFindFirst) Take(count int) sessionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r sessionFindFirst) Cursor(cursor SessionCursorParam) sessionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r sessionFindFirst) Exec(ctx context.Context) (
	*SessionModel,
	error,
) {
	var v *SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r sessionFindFirst) ExecInner(ctx context.Context) (
	*InnerSession,
	error,
) {
	var v *InnerSession
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type sessionFindMany struct {
	query builder.Query
}

func (r sessionFindMany) getQuery() builder.Query {
	return r.query
}

func (r sessionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionFindMany) with()            {}
func (r sessionFindMany) sessionModel()    {}
func (r sessionFindMany) sessionRelation() {}

func (r sessionActions) FindMany(
	params ...SessionWhereParam,
) sessionFindMany {
	var v sessionFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Session"
	v.query.Outputs = sessionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r sessionFindMany) With(params ...SessionRelationWith) sessionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r sessionFindMany) OrderBy(params ...SessionOrderByParam) sessionFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r sessionFindMany) Skip(count int) sessionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r sessionFindMany) Take(count int) sessionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r sessionFindMany) Cursor(cursor SessionCursorParam) sessionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r sessionFindMany) Exec(ctx context.Context) (
	[]SessionModel,
	error,
) {
	var v []SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r sessionFindMany) ExecInner(ctx context.Context) (
	[]InnerSession,
	error,
) {
	var v []InnerSession
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r sessionFindMany) Update(params ...SessionSetParam) sessionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Session"

	r.query.Outputs = countOutput

	var v sessionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type sessionUpdateMany struct {
	query builder.Query
}

func (r sessionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionUpdateMany) sessionModel() {}

func (r sessionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionUpdateMany) Tx() sessionManyTxResult {
	v := NewsessionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r sessionFindMany) Delete() sessionDeleteMany {
	var v sessionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Session"

	v.query.Outputs = countOutput

	return v
}

type sessionDeleteMany struct {
	query builder.Query
}

func (r sessionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p sessionDeleteMany) sessionModel() {}

func (r sessionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionDeleteMany) Tx() sessionManyTxResult {
	v := NewsessionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template transaction.gotpl ---

func NewuserUniqueTxResult() userUniqueTxResult {
	return userUniqueTxResult{
		result: &transaction.Result{},
	}
}

type userUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p userUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p userUniqueTxResult) IsTx() {}

func (r userUniqueTxResult) Result() (v *UserModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewuserManyTxResult() userManyTxResult {
	return userManyTxResult{
		result: &transaction.Result{},
	}
}

type userManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p userManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p userManyTxResult) IsTx() {}

func (r userManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewpasswordUniqueTxResult() passwordUniqueTxResult {
	return passwordUniqueTxResult{
		result: &transaction.Result{},
	}
}

type passwordUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p passwordUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p passwordUniqueTxResult) IsTx() {}

func (r passwordUniqueTxResult) Result() (v *PasswordModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewpasswordManyTxResult() passwordManyTxResult {
	return passwordManyTxResult{
		result: &transaction.Result{},
	}
}

type passwordManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p passwordManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p passwordManyTxResult) IsTx() {}

func (r passwordManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewnetUniqueTxResult() netUniqueTxResult {
	return netUniqueTxResult{
		result: &transaction.Result{},
	}
}

type netUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p netUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p netUniqueTxResult) IsTx() {}

func (r netUniqueTxResult) Result() (v *NetModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewnetManyTxResult() netManyTxResult {
	return netManyTxResult{
		result: &transaction.Result{},
	}
}

type netManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p netManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p netManyTxResult) IsTx() {}

func (r netManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewplaceInterfaceUniqueTxResult() placeInterfaceUniqueTxResult {
	return placeInterfaceUniqueTxResult{
		result: &transaction.Result{},
	}
}

type placeInterfaceUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p placeInterfaceUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p placeInterfaceUniqueTxResult) IsTx() {}

func (r placeInterfaceUniqueTxResult) Result() (v *PlaceInterfaceModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewplaceInterfaceManyTxResult() placeInterfaceManyTxResult {
	return placeInterfaceManyTxResult{
		result: &transaction.Result{},
	}
}

type placeInterfaceManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p placeInterfaceManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p placeInterfaceManyTxResult) IsTx() {}

func (r placeInterfaceManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewtransitionInterfaceUniqueTxResult() transitionInterfaceUniqueTxResult {
	return transitionInterfaceUniqueTxResult{
		result: &transaction.Result{},
	}
}

type transitionInterfaceUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p transitionInterfaceUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceUniqueTxResult) IsTx() {}

func (r transitionInterfaceUniqueTxResult) Result() (v *TransitionInterfaceModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewtransitionInterfaceManyTxResult() transitionInterfaceManyTxResult {
	return transitionInterfaceManyTxResult{
		result: &transaction.Result{},
	}
}

type transitionInterfaceManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p transitionInterfaceManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceManyTxResult) IsTx() {}

func (r transitionInterfaceManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewplaceUniqueTxResult() placeUniqueTxResult {
	return placeUniqueTxResult{
		result: &transaction.Result{},
	}
}

type placeUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p placeUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p placeUniqueTxResult) IsTx() {}

func (r placeUniqueTxResult) Result() (v *PlaceModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewplaceManyTxResult() placeManyTxResult {
	return placeManyTxResult{
		result: &transaction.Result{},
	}
}

type placeManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p placeManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p placeManyTxResult) IsTx() {}

func (r placeManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewtransitionUniqueTxResult() transitionUniqueTxResult {
	return transitionUniqueTxResult{
		result: &transaction.Result{},
	}
}

type transitionUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p transitionUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p transitionUniqueTxResult) IsTx() {}

func (r transitionUniqueTxResult) Result() (v *TransitionModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewtransitionManyTxResult() transitionManyTxResult {
	return transitionManyTxResult{
		result: &transaction.Result{},
	}
}

type transitionManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p transitionManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p transitionManyTxResult) IsTx() {}

func (r transitionManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewarcUniqueTxResult() arcUniqueTxResult {
	return arcUniqueTxResult{
		result: &transaction.Result{},
	}
}

type arcUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p arcUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p arcUniqueTxResult) IsTx() {}

func (r arcUniqueTxResult) Result() (v *ArcModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewarcManyTxResult() arcManyTxResult {
	return arcManyTxResult{
		result: &transaction.Result{},
	}
}

type arcManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p arcManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p arcManyTxResult) IsTx() {}

func (r arcManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewdevicesOnNetsUniqueTxResult() devicesOnNetsUniqueTxResult {
	return devicesOnNetsUniqueTxResult{
		result: &transaction.Result{},
	}
}

type devicesOnNetsUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p devicesOnNetsUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsUniqueTxResult) IsTx() {}

func (r devicesOnNetsUniqueTxResult) Result() (v *DevicesOnNetsModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewdevicesOnNetsManyTxResult() devicesOnNetsManyTxResult {
	return devicesOnNetsManyTxResult{
		result: &transaction.Result{},
	}
}

type devicesOnNetsManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p devicesOnNetsManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsManyTxResult) IsTx() {}

func (r devicesOnNetsManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewfieldUniqueTxResult() fieldUniqueTxResult {
	return fieldUniqueTxResult{
		result: &transaction.Result{},
	}
}

type fieldUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p fieldUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p fieldUniqueTxResult) IsTx() {}

func (r fieldUniqueTxResult) Result() (v *FieldModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewfieldManyTxResult() fieldManyTxResult {
	return fieldManyTxResult{
		result: &transaction.Result{},
	}
}

type fieldManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p fieldManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p fieldManyTxResult) IsTx() {}

func (r fieldManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NeweventUniqueTxResult() eventUniqueTxResult {
	return eventUniqueTxResult{
		result: &transaction.Result{},
	}
}

type eventUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p eventUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p eventUniqueTxResult) IsTx() {}

func (r eventUniqueTxResult) Result() (v *EventModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NeweventManyTxResult() eventManyTxResult {
	return eventManyTxResult{
		result: &transaction.Result{},
	}
}

type eventManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p eventManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p eventManyTxResult) IsTx() {}

func (r eventManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewinstanceUniqueTxResult() instanceUniqueTxResult {
	return instanceUniqueTxResult{
		result: &transaction.Result{},
	}
}

type instanceUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p instanceUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p instanceUniqueTxResult) IsTx() {}

func (r instanceUniqueTxResult) Result() (v *InstanceModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewinstanceManyTxResult() instanceManyTxResult {
	return instanceManyTxResult{
		result: &transaction.Result{},
	}
}

type instanceManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p instanceManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p instanceManyTxResult) IsTx() {}

func (r instanceManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewdeviceUniqueTxResult() deviceUniqueTxResult {
	return deviceUniqueTxResult{
		result: &transaction.Result{},
	}
}

type deviceUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p deviceUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p deviceUniqueTxResult) IsTx() {}

func (r deviceUniqueTxResult) Result() (v *DeviceModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewdeviceManyTxResult() deviceManyTxResult {
	return deviceManyTxResult{
		result: &transaction.Result{},
	}
}

type deviceManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p deviceManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p deviceManyTxResult) IsTx() {}

func (r deviceManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewconstantUniqueTxResult() constantUniqueTxResult {
	return constantUniqueTxResult{
		result: &transaction.Result{},
	}
}

type constantUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p constantUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p constantUniqueTxResult) IsTx() {}

func (r constantUniqueTxResult) Result() (v *ConstantModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewconstantManyTxResult() constantManyTxResult {
	return constantManyTxResult{
		result: &transaction.Result{},
	}
}

type constantManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p constantManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p constantManyTxResult) IsTx() {}

func (r constantManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewactionUniqueTxResult() actionUniqueTxResult {
	return actionUniqueTxResult{
		result: &transaction.Result{},
	}
}

type actionUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p actionUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p actionUniqueTxResult) IsTx() {}

func (r actionUniqueTxResult) Result() (v *ActionModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewactionManyTxResult() actionManyTxResult {
	return actionManyTxResult{
		result: &transaction.Result{},
	}
}

type actionManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p actionManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p actionManyTxResult) IsTx() {}

func (r actionManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewstepUniqueTxResult() stepUniqueTxResult {
	return stepUniqueTxResult{
		result: &transaction.Result{},
	}
}

type stepUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p stepUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p stepUniqueTxResult) IsTx() {}

func (r stepUniqueTxResult) Result() (v *StepModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewstepManyTxResult() stepManyTxResult {
	return stepManyTxResult{
		result: &transaction.Result{},
	}
}

type stepManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p stepManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p stepManyTxResult) IsTx() {}

func (r stepManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewrunUniqueTxResult() runUniqueTxResult {
	return runUniqueTxResult{
		result: &transaction.Result{},
	}
}

type runUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p runUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p runUniqueTxResult) IsTx() {}

func (r runUniqueTxResult) Result() (v *RunModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewrunManyTxResult() runManyTxResult {
	return runManyTxResult{
		result: &transaction.Result{},
	}
}

type runManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p runManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p runManyTxResult) IsTx() {}

func (r runManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewdatumUniqueTxResult() datumUniqueTxResult {
	return datumUniqueTxResult{
		result: &transaction.Result{},
	}
}

type datumUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p datumUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p datumUniqueTxResult) IsTx() {}

func (r datumUniqueTxResult) Result() (v *DatumModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewdatumManyTxResult() datumManyTxResult {
	return datumManyTxResult{
		result: &transaction.Result{},
	}
}

type datumManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p datumManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p datumManyTxResult) IsTx() {}

func (r datumManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewsessionUniqueTxResult() sessionUniqueTxResult {
	return sessionUniqueTxResult{
		result: &transaction.Result{},
	}
}

type sessionUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p sessionUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p sessionUniqueTxResult) IsTx() {}

func (r sessionUniqueTxResult) Result() (v *SessionModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewsessionManyTxResult() sessionManyTxResult {
	return sessionManyTxResult{
		result: &transaction.Result{},
	}
}

type sessionManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p sessionManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p sessionManyTxResult) IsTx() {}

func (r sessionManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

// --- template client.gotpl ---
const schema = `datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

generator db {
  provider = "go run github.com/steebchen/prisma-client-go"
}

enum UserRole {
  NONE
  ADMIN
  DEVELOPER
  REVIERWER
  USER
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  role      UserRole
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  password  Password?
  nets      Net[]
  devices   Device[]
  instances Instance[]
  sessions  Session[]
}

model Password {
  hash   String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @unique
}

// A Net is a Petri Net. It is a directed graph consisting of places, transitions, and arcs.
model Net {
  id                   String                @id @default(cuid())
  name                 String
  description          String
  initialMarking       Int[]
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  author               User                  @relation(fields: [authorID], references: [id])
  authorID             String
  arcs                 Arc[]
  places               Place[]
  transitions          Transition[]
  parent               Net?                  @relation("NetChildren", fields: [parentID], references: [id])
  parentID             String?
  children             Net[]                 @relation("NetChildren")
  devices              DevicesOnNets[]
  placeInterfaces      PlaceInterface[]
  transitionInterfaces TransitionInterface[]
  runs                 Run[]
}

// PlaceInterface is a place that connect
model PlaceInterface {
  id        String   @id @default(cuid())
  name      String
  net       Net      @relation(fields: [netID], references: [id])
  bound     Int
  netID     String
  places    Place[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model TransitionInterface {
  id          String       @id @default(cuid())
  name        String
  net         Net          @relation(fields: [netID], references: [id])
  events      Event[]
  netID       String
  transitions Transition[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
}

model Place {
  id          String           @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  arcs        Arc[]
  bound       Int
  nets        Net[]
  interfaces  PlaceInterface[]
}

model Transition {
  id          String                @id @default(cuid())
  condition   String?
  description String?
  name        String
  arcs        Arc[]
  events      Event[]
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  nets        Net[]
  interfaces  TransitionInterface[]
}

model Arc {
  id           String     @id @default(cuid())
  net          Net        @relation(fields: [netID], references: [id])
  netID        String
  fromPlace    Boolean
  place        Place      @relation(fields: [placeID], references: [id])
  placeID      String
  transition   Transition @relation(fields: [transitionID], references: [id])
  transitionID String
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
}

model DevicesOnNets {
  device   Device @relation(fields: [deviceID], references: [id])
  deviceID String
  net      Net    @relation(fields: [netID], references: [id])
  netID    String

  @@id([deviceID, netID])
}

model Field {
  id        String     @id @default(cuid())
  name      String
  type      String
  condition String?
  event     Event      @relation(fields: [eventID], references: [id])
  eventID   String
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  constants Constant[]
}

model Event {
  id                    String               @id @default(cuid())
  name                  String
  description           String?
  transitions           Transition[]
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
  fields                Field[]
  commands              Action[]
  data                  Datum[]
  placeInterfaceId      String?
  transitionInterface   TransitionInterface? @relation(fields: [transitionInterfaceId], references: [id])
  transitionInterfaceId String?
}

enum Language {
  NONE
  CPP
  GO
  JS
  PYTHON
}

model Instance {
  id        String    @id @default(cuid())
  author    User      @relation(fields: [authorID], references: [id])
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  authorID  String
  language  Language
  name      String
  device    Device    @relation(fields: [deviceId], references: [id])
  deviceId  String
  addr      String
  data      Datum[]
  sessions  Session[]
}

model Device {
  id          String          @id @default(cuid())
  author      User            @relation(fields: [authorID], references: [id])
  authorID    String
  name        String
  description String
  instances   Instance[]
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  netIDs      String[]
  nets        DevicesOnNets[]
  actions     Action[]
}

model Constant {
  id       String @id @default(cuid())
  action   Action @relation(fields: [actionID], references: [id])
  actionID String
  field    Field  @relation(fields: [fieldID], references: [id])
  fieldID  String
  value    String
}

model Action {
  id        String     @id @default(cuid())
  input     Json
  output    Json
  device    Device     @relation(fields: [deviceId], references: [id])
  deviceId  String
  event     Event      @relation(fields: [eventID], references: [id])
  eventID   String
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  constants Constant[]
  steps     Step[]
}

model Step {
  id       String @id @default(cuid())
  order    Int
  run      Run    @relation(fields: [runID], references: [id])
  runID    String
  action   Action @relation(fields: [actionID], references: [id])
  actionID String
}

model Run {
  id          String    @id @default(cuid())
  name        String
  description String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  net         Net       @relation(fields: [netID], references: [id])
  netID       String
  sessions    Session[]
  steps       Step[]
}

model Datum {
  id         String   @id @default(cuid())
  instance   Instance @relation(fields: [instanceID], references: [id])
  instanceID String
  session    Session  @relation(fields: [sessionID], references: [id])
  sessionID  String
  value      Json?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  event      Event    @relation(fields: [eventId], references: [id])
  eventId    String
}

enum SessionState {
  NONE
  RUNNING
  PAUSED
  STOPPED
}

model Session {
  id        String       @id @default(cuid())
  user      User         @relation(fields: [userID], references: [id])
  userID    String
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  startedAt DateTime?
  stoppedAt DateTime?
  pausedAt  DateTime[]
  resumedAt DateTime[]
  run       Run          @relation(fields: [runID], references: [id])
  instances Instance[]
  state     SessionState @default(NONE)
  deleted   Boolean      @default(false)
  runID     String
  data      Datum[]
}
`
const schemaConnectionURL = ""
const schemaEnvVarName = "DATABASE_URL"

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = true

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//	client := db.NewClient()
//	if err := client.Prisma.Connect(); err != nil {
//	  handle(err)
//	}
//
//	defer func() {
//	  if err := client.Prisma.Disconnect(); err != nil {
//	    panic(fmt.Errorf("could not disconnect: %w", err))
//	  }
//	}()
func NewClient() *PrismaClient {
	c := newClient()

	c.Engine = engine.NewQueryEngine(schema, hasBinaryTargets)

	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newMockClient(expectations *[]mock.Expectation) *PrismaClient {
	c := newClient()
	c.Engine = mock.New(expectations)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newClient() *PrismaClient {
	c := &PrismaClient{}
	c.User = userActions{client: c}
	c.Password = passwordActions{client: c}
	c.Net = netActions{client: c}
	c.PlaceInterface = placeInterfaceActions{client: c}
	c.TransitionInterface = transitionInterfaceActions{client: c}
	c.Place = placeActions{client: c}
	c.Transition = transitionActions{client: c}
	c.Arc = arcActions{client: c}
	c.DevicesOnNets = devicesOnNetsActions{client: c}
	c.Field = fieldActions{client: c}
	c.Event = eventActions{client: c}
	c.Instance = instanceActions{client: c}
	c.Device = deviceActions{client: c}
	c.Constant = constantActions{client: c}
	c.Action = actionActions{client: c}
	c.Step = stepActions{client: c}
	c.Run = runActions{client: c}
	c.Datum = datumActions{client: c}
	c.Session = sessionActions{client: c}

	c.Prisma = &PrismaActions{
		Raw: &raw.Raw{Engine: c},
		TX:  &transaction.TX{Engine: c},
	}
	return c
}

type PrismaActions struct {
	*lifecycle.Lifecycle
	*raw.Raw
	*transaction.TX
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine is an abstractions of what happens under the hood
	// the query engine can spawn and manage the binary and send requests to it,
	// while a mock engine would collect mocks to verify them later
	engine.Engine

	// prisma provides prisma-related methods as opposed to model methods, such as Connect, Disconnect or raw queries
	Prisma *PrismaActions

	// User provides access to CRUD methods.
	User userActions
	// Password provides access to CRUD methods.
	Password passwordActions
	// Net provides access to CRUD methods.
	Net netActions
	// PlaceInterface provides access to CRUD methods.
	PlaceInterface placeInterfaceActions
	// TransitionInterface provides access to CRUD methods.
	TransitionInterface transitionInterfaceActions
	// Place provides access to CRUD methods.
	Place placeActions
	// Transition provides access to CRUD methods.
	Transition transitionActions
	// Arc provides access to CRUD methods.
	Arc arcActions
	// DevicesOnNets provides access to CRUD methods.
	DevicesOnNets devicesOnNetsActions
	// Field provides access to CRUD methods.
	Field fieldActions
	// Event provides access to CRUD methods.
	Event eventActions
	// Instance provides access to CRUD methods.
	Instance instanceActions
	// Device provides access to CRUD methods.
	Device deviceActions
	// Constant provides access to CRUD methods.
	Constant constantActions
	// Action provides access to CRUD methods.
	Action actionActions
	// Step provides access to CRUD methods.
	Step stepActions
	// Run provides access to CRUD methods.
	Run runActions
	// Datum provides access to CRUD methods.
	Datum datumActions
	// Session provides access to CRUD methods.
	Session sessionActions
}

// --- template errors.gotpl ---
var ErrNotFound = types.ErrNotFound

// --- template models.gotpl ---

// UserModel represents the User model and is a wrapper for accessing fields and methods
type UserModel struct {
	InnerUser
	RelationsUser
}

// InnerUser holds the actual data
type InnerUser struct {
	ID        string   `json:"id"`
	Email     string   `json:"email"`
	Role      UserRole `json:"role"`
	CreatedAt DateTime `json:"createdAt"`
	UpdatedAt DateTime `json:"updatedAt"`
}

// RawUserModel is a struct for User when used in raw queries
type RawUserModel struct {
	ID        RawString   `json:"id"`
	Email     RawString   `json:"email"`
	Role      RawUserRole `json:"role"`
	CreatedAt RawDateTime `json:"createdAt"`
	UpdatedAt RawDateTime `json:"updatedAt"`
}

// RelationsUser holds the relation data separately
type RelationsUser struct {
	Password  *PasswordModel  `json:"password,omitempty"`
	Nets      []NetModel      `json:"nets,omitempty"`
	Devices   []DeviceModel   `json:"devices,omitempty"`
	Instances []InstanceModel `json:"instances,omitempty"`
	Sessions  []SessionModel  `json:"sessions,omitempty"`
}

func (r UserModel) Password() (value *PasswordModel, ok bool) {
	if r.RelationsUser.Password == nil {
		return value, false
	}
	return r.RelationsUser.Password, true
}

func (r UserModel) Nets() (value []NetModel) {
	if r.RelationsUser.Nets == nil {
		panic("attempted to access nets but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Nets
}

func (r UserModel) Devices() (value []DeviceModel) {
	if r.RelationsUser.Devices == nil {
		panic("attempted to access devices but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Devices
}

func (r UserModel) Instances() (value []InstanceModel) {
	if r.RelationsUser.Instances == nil {
		panic("attempted to access instances but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Instances
}

func (r UserModel) Sessions() (value []SessionModel) {
	if r.RelationsUser.Sessions == nil {
		panic("attempted to access sessions but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Sessions
}

// PasswordModel represents the Password model and is a wrapper for accessing fields and methods
type PasswordModel struct {
	InnerPassword
	RelationsPassword
}

// InnerPassword holds the actual data
type InnerPassword struct {
	Hash   string `json:"hash"`
	UserID string `json:"userId"`
}

// RawPasswordModel is a struct for Password when used in raw queries
type RawPasswordModel struct {
	Hash   RawString `json:"hash"`
	UserID RawString `json:"userId"`
}

// RelationsPassword holds the relation data separately
type RelationsPassword struct {
	User *UserModel `json:"user,omitempty"`
}

func (r PasswordModel) User() (value *UserModel) {
	if r.RelationsPassword.User == nil {
		panic("attempted to access user but did not fetch it using the .With() syntax")
	}
	return r.RelationsPassword.User
}

// NetModel represents the Net model and is a wrapper for accessing fields and methods
type NetModel struct {
	InnerNet
	RelationsNet
}

// InnerNet holds the actual data
type InnerNet struct {
	ID             string   `json:"id"`
	Name           string   `json:"name"`
	Description    string   `json:"description"`
	InitialMarking []int    `json:"initialMarking"`
	CreatedAt      DateTime `json:"createdAt"`
	UpdatedAt      DateTime `json:"updatedAt"`
	AuthorID       string   `json:"authorID"`
	ParentID       *string  `json:"parentID,omitempty"`
}

// RawNetModel is a struct for Net when used in raw queries
type RawNetModel struct {
	ID             RawString   `json:"id"`
	Name           RawString   `json:"name"`
	Description    RawString   `json:"description"`
	InitialMarking []RawInt    `json:"initialMarking"`
	CreatedAt      RawDateTime `json:"createdAt"`
	UpdatedAt      RawDateTime `json:"updatedAt"`
	AuthorID       RawString   `json:"authorID"`
	ParentID       *RawString  `json:"parentID,omitempty"`
}

// RelationsNet holds the relation data separately
type RelationsNet struct {
	Author               *UserModel                 `json:"author,omitempty"`
	Arcs                 []ArcModel                 `json:"arcs,omitempty"`
	Places               []PlaceModel               `json:"places,omitempty"`
	Transitions          []TransitionModel          `json:"transitions,omitempty"`
	Parent               *NetModel                  `json:"parent,omitempty"`
	Children             []NetModel                 `json:"children,omitempty"`
	Devices              []DevicesOnNetsModel       `json:"devices,omitempty"`
	PlaceInterfaces      []PlaceInterfaceModel      `json:"placeInterfaces,omitempty"`
	TransitionInterfaces []TransitionInterfaceModel `json:"transitionInterfaces,omitempty"`
	Runs                 []RunModel                 `json:"runs,omitempty"`
}

func (r NetModel) Author() (value *UserModel) {
	if r.RelationsNet.Author == nil {
		panic("attempted to access author but did not fetch it using the .With() syntax")
	}
	return r.RelationsNet.Author
}

func (r NetModel) Arcs() (value []ArcModel) {
	if r.RelationsNet.Arcs == nil {
		panic("attempted to access arcs but did not fetch it using the .With() syntax")
	}
	return r.RelationsNet.Arcs
}

func (r NetModel) Places() (value []PlaceModel) {
	if r.RelationsNet.Places == nil {
		panic("attempted to access places but did not fetch it using the .With() syntax")
	}
	return r.RelationsNet.Places
}

func (r NetModel) Transitions() (value []TransitionModel) {
	if r.RelationsNet.Transitions == nil {
		panic("attempted to access transitions but did not fetch it using the .With() syntax")
	}
	return r.RelationsNet.Transitions
}

func (r NetModel) Parent() (value *NetModel, ok bool) {
	if r.RelationsNet.Parent == nil {
		return value, false
	}
	return r.RelationsNet.Parent, true
}

func (r NetModel) ParentID() (value string, ok bool) {
	if r.InnerNet.ParentID == nil {
		return value, false
	}
	return *r.InnerNet.ParentID, true
}

func (r NetModel) Children() (value []NetModel) {
	if r.RelationsNet.Children == nil {
		panic("attempted to access children but did not fetch it using the .With() syntax")
	}
	return r.RelationsNet.Children
}

func (r NetModel) Devices() (value []DevicesOnNetsModel) {
	if r.RelationsNet.Devices == nil {
		panic("attempted to access devices but did not fetch it using the .With() syntax")
	}
	return r.RelationsNet.Devices
}

func (r NetModel) PlaceInterfaces() (value []PlaceInterfaceModel) {
	if r.RelationsNet.PlaceInterfaces == nil {
		panic("attempted to access placeInterfaces but did not fetch it using the .With() syntax")
	}
	return r.RelationsNet.PlaceInterfaces
}

func (r NetModel) TransitionInterfaces() (value []TransitionInterfaceModel) {
	if r.RelationsNet.TransitionInterfaces == nil {
		panic("attempted to access transitionInterfaces but did not fetch it using the .With() syntax")
	}
	return r.RelationsNet.TransitionInterfaces
}

func (r NetModel) Runs() (value []RunModel) {
	if r.RelationsNet.Runs == nil {
		panic("attempted to access runs but did not fetch it using the .With() syntax")
	}
	return r.RelationsNet.Runs
}

// PlaceInterfaceModel represents the PlaceInterface model and is a wrapper for accessing fields and methods
type PlaceInterfaceModel struct {
	InnerPlaceInterface
	RelationsPlaceInterface
}

// InnerPlaceInterface holds the actual data
type InnerPlaceInterface struct {
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Bound     int      `json:"bound"`
	NetID     string   `json:"netID"`
	CreatedAt DateTime `json:"createdAt"`
	UpdatedAt DateTime `json:"updatedAt"`
}

// RawPlaceInterfaceModel is a struct for PlaceInterface when used in raw queries
type RawPlaceInterfaceModel struct {
	ID        RawString   `json:"id"`
	Name      RawString   `json:"name"`
	Bound     RawInt      `json:"bound"`
	NetID     RawString   `json:"netID"`
	CreatedAt RawDateTime `json:"createdAt"`
	UpdatedAt RawDateTime `json:"updatedAt"`
}

// RelationsPlaceInterface holds the relation data separately
type RelationsPlaceInterface struct {
	Net    *NetModel    `json:"net,omitempty"`
	Places []PlaceModel `json:"places,omitempty"`
}

func (r PlaceInterfaceModel) Net() (value *NetModel) {
	if r.RelationsPlaceInterface.Net == nil {
		panic("attempted to access net but did not fetch it using the .With() syntax")
	}
	return r.RelationsPlaceInterface.Net
}

func (r PlaceInterfaceModel) Places() (value []PlaceModel) {
	if r.RelationsPlaceInterface.Places == nil {
		panic("attempted to access places but did not fetch it using the .With() syntax")
	}
	return r.RelationsPlaceInterface.Places
}

// TransitionInterfaceModel represents the TransitionInterface model and is a wrapper for accessing fields and methods
type TransitionInterfaceModel struct {
	InnerTransitionInterface
	RelationsTransitionInterface
}

// InnerTransitionInterface holds the actual data
type InnerTransitionInterface struct {
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	NetID     string   `json:"netID"`
	CreatedAt DateTime `json:"createdAt"`
	UpdatedAt DateTime `json:"updatedAt"`
}

// RawTransitionInterfaceModel is a struct for TransitionInterface when used in raw queries
type RawTransitionInterfaceModel struct {
	ID        RawString   `json:"id"`
	Name      RawString   `json:"name"`
	NetID     RawString   `json:"netID"`
	CreatedAt RawDateTime `json:"createdAt"`
	UpdatedAt RawDateTime `json:"updatedAt"`
}

// RelationsTransitionInterface holds the relation data separately
type RelationsTransitionInterface struct {
	Net         *NetModel         `json:"net,omitempty"`
	Events      []EventModel      `json:"events,omitempty"`
	Transitions []TransitionModel `json:"transitions,omitempty"`
}

func (r TransitionInterfaceModel) Net() (value *NetModel) {
	if r.RelationsTransitionInterface.Net == nil {
		panic("attempted to access net but did not fetch it using the .With() syntax")
	}
	return r.RelationsTransitionInterface.Net
}

func (r TransitionInterfaceModel) Events() (value []EventModel) {
	if r.RelationsTransitionInterface.Events == nil {
		panic("attempted to access events but did not fetch it using the .With() syntax")
	}
	return r.RelationsTransitionInterface.Events
}

func (r TransitionInterfaceModel) Transitions() (value []TransitionModel) {
	if r.RelationsTransitionInterface.Transitions == nil {
		panic("attempted to access transitions but did not fetch it using the .With() syntax")
	}
	return r.RelationsTransitionInterface.Transitions
}

// PlaceModel represents the Place model and is a wrapper for accessing fields and methods
type PlaceModel struct {
	InnerPlace
	RelationsPlace
}

// InnerPlace holds the actual data
type InnerPlace struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	Description *string  `json:"description,omitempty"`
	CreatedAt   DateTime `json:"createdAt"`
	UpdatedAt   DateTime `json:"updatedAt"`
	Bound       int      `json:"bound"`
}

// RawPlaceModel is a struct for Place when used in raw queries
type RawPlaceModel struct {
	ID          RawString   `json:"id"`
	Name        RawString   `json:"name"`
	Description *RawString  `json:"description,omitempty"`
	CreatedAt   RawDateTime `json:"createdAt"`
	UpdatedAt   RawDateTime `json:"updatedAt"`
	Bound       RawInt      `json:"bound"`
}

// RelationsPlace holds the relation data separately
type RelationsPlace struct {
	Arcs       []ArcModel            `json:"arcs,omitempty"`
	Nets       []NetModel            `json:"nets,omitempty"`
	Interfaces []PlaceInterfaceModel `json:"interfaces,omitempty"`
}

func (r PlaceModel) Description() (value string, ok bool) {
	if r.InnerPlace.Description == nil {
		return value, false
	}
	return *r.InnerPlace.Description, true
}

func (r PlaceModel) Arcs() (value []ArcModel) {
	if r.RelationsPlace.Arcs == nil {
		panic("attempted to access arcs but did not fetch it using the .With() syntax")
	}
	return r.RelationsPlace.Arcs
}

func (r PlaceModel) Nets() (value []NetModel) {
	if r.RelationsPlace.Nets == nil {
		panic("attempted to access nets but did not fetch it using the .With() syntax")
	}
	return r.RelationsPlace.Nets
}

func (r PlaceModel) Interfaces() (value []PlaceInterfaceModel) {
	if r.RelationsPlace.Interfaces == nil {
		panic("attempted to access interfaces but did not fetch it using the .With() syntax")
	}
	return r.RelationsPlace.Interfaces
}

// TransitionModel represents the Transition model and is a wrapper for accessing fields and methods
type TransitionModel struct {
	InnerTransition
	RelationsTransition
}

// InnerTransition holds the actual data
type InnerTransition struct {
	ID          string   `json:"id"`
	Condition   *string  `json:"condition,omitempty"`
	Description *string  `json:"description,omitempty"`
	Name        string   `json:"name"`
	CreatedAt   DateTime `json:"createdAt"`
	UpdatedAt   DateTime `json:"updatedAt"`
}

// RawTransitionModel is a struct for Transition when used in raw queries
type RawTransitionModel struct {
	ID          RawString   `json:"id"`
	Condition   *RawString  `json:"condition,omitempty"`
	Description *RawString  `json:"description,omitempty"`
	Name        RawString   `json:"name"`
	CreatedAt   RawDateTime `json:"createdAt"`
	UpdatedAt   RawDateTime `json:"updatedAt"`
}

// RelationsTransition holds the relation data separately
type RelationsTransition struct {
	Arcs       []ArcModel                 `json:"arcs,omitempty"`
	Events     []EventModel               `json:"events,omitempty"`
	Nets       []NetModel                 `json:"nets,omitempty"`
	Interfaces []TransitionInterfaceModel `json:"interfaces,omitempty"`
}

func (r TransitionModel) Condition() (value string, ok bool) {
	if r.InnerTransition.Condition == nil {
		return value, false
	}
	return *r.InnerTransition.Condition, true
}

func (r TransitionModel) Description() (value string, ok bool) {
	if r.InnerTransition.Description == nil {
		return value, false
	}
	return *r.InnerTransition.Description, true
}

func (r TransitionModel) Arcs() (value []ArcModel) {
	if r.RelationsTransition.Arcs == nil {
		panic("attempted to access arcs but did not fetch it using the .With() syntax")
	}
	return r.RelationsTransition.Arcs
}

func (r TransitionModel) Events() (value []EventModel) {
	if r.RelationsTransition.Events == nil {
		panic("attempted to access events but did not fetch it using the .With() syntax")
	}
	return r.RelationsTransition.Events
}

func (r TransitionModel) Nets() (value []NetModel) {
	if r.RelationsTransition.Nets == nil {
		panic("attempted to access nets but did not fetch it using the .With() syntax")
	}
	return r.RelationsTransition.Nets
}

func (r TransitionModel) Interfaces() (value []TransitionInterfaceModel) {
	if r.RelationsTransition.Interfaces == nil {
		panic("attempted to access interfaces but did not fetch it using the .With() syntax")
	}
	return r.RelationsTransition.Interfaces
}

// ArcModel represents the Arc model and is a wrapper for accessing fields and methods
type ArcModel struct {
	InnerArc
	RelationsArc
}

// InnerArc holds the actual data
type InnerArc struct {
	ID           string   `json:"id"`
	NetID        string   `json:"netID"`
	FromPlace    bool     `json:"fromPlace"`
	PlaceID      string   `json:"placeID"`
	TransitionID string   `json:"transitionID"`
	CreatedAt    DateTime `json:"createdAt"`
	UpdatedAt    DateTime `json:"updatedAt"`
}

// RawArcModel is a struct for Arc when used in raw queries
type RawArcModel struct {
	ID           RawString   `json:"id"`
	NetID        RawString   `json:"netID"`
	FromPlace    RawBoolean  `json:"fromPlace"`
	PlaceID      RawString   `json:"placeID"`
	TransitionID RawString   `json:"transitionID"`
	CreatedAt    RawDateTime `json:"createdAt"`
	UpdatedAt    RawDateTime `json:"updatedAt"`
}

// RelationsArc holds the relation data separately
type RelationsArc struct {
	Net        *NetModel        `json:"net,omitempty"`
	Place      *PlaceModel      `json:"place,omitempty"`
	Transition *TransitionModel `json:"transition,omitempty"`
}

func (r ArcModel) Net() (value *NetModel) {
	if r.RelationsArc.Net == nil {
		panic("attempted to access net but did not fetch it using the .With() syntax")
	}
	return r.RelationsArc.Net
}

func (r ArcModel) Place() (value *PlaceModel) {
	if r.RelationsArc.Place == nil {
		panic("attempted to access place but did not fetch it using the .With() syntax")
	}
	return r.RelationsArc.Place
}

func (r ArcModel) Transition() (value *TransitionModel) {
	if r.RelationsArc.Transition == nil {
		panic("attempted to access transition but did not fetch it using the .With() syntax")
	}
	return r.RelationsArc.Transition
}

// DevicesOnNetsModel represents the DevicesOnNets model and is a wrapper for accessing fields and methods
type DevicesOnNetsModel struct {
	InnerDevicesOnNets
	RelationsDevicesOnNets
}

// InnerDevicesOnNets holds the actual data
type InnerDevicesOnNets struct {
	DeviceID string `json:"deviceID"`
	NetID    string `json:"netID"`
}

// RawDevicesOnNetsModel is a struct for DevicesOnNets when used in raw queries
type RawDevicesOnNetsModel struct {
	DeviceID RawString `json:"deviceID"`
	NetID    RawString `json:"netID"`
}

// RelationsDevicesOnNets holds the relation data separately
type RelationsDevicesOnNets struct {
	Device *DeviceModel `json:"device,omitempty"`
	Net    *NetModel    `json:"net,omitempty"`
}

func (r DevicesOnNetsModel) Device() (value *DeviceModel) {
	if r.RelationsDevicesOnNets.Device == nil {
		panic("attempted to access device but did not fetch it using the .With() syntax")
	}
	return r.RelationsDevicesOnNets.Device
}

func (r DevicesOnNetsModel) Net() (value *NetModel) {
	if r.RelationsDevicesOnNets.Net == nil {
		panic("attempted to access net but did not fetch it using the .With() syntax")
	}
	return r.RelationsDevicesOnNets.Net
}

// FieldModel represents the Field model and is a wrapper for accessing fields and methods
type FieldModel struct {
	InnerField
	RelationsField
}

// InnerField holds the actual data
type InnerField struct {
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Type      string   `json:"type"`
	Condition *string  `json:"condition,omitempty"`
	EventID   string   `json:"eventID"`
	CreatedAt DateTime `json:"createdAt"`
	UpdatedAt DateTime `json:"updatedAt"`
}

// RawFieldModel is a struct for Field when used in raw queries
type RawFieldModel struct {
	ID        RawString   `json:"id"`
	Name      RawString   `json:"name"`
	Type      RawString   `json:"type"`
	Condition *RawString  `json:"condition,omitempty"`
	EventID   RawString   `json:"eventID"`
	CreatedAt RawDateTime `json:"createdAt"`
	UpdatedAt RawDateTime `json:"updatedAt"`
}

// RelationsField holds the relation data separately
type RelationsField struct {
	Event     *EventModel     `json:"event,omitempty"`
	Constants []ConstantModel `json:"constants,omitempty"`
}

func (r FieldModel) Condition() (value string, ok bool) {
	if r.InnerField.Condition == nil {
		return value, false
	}
	return *r.InnerField.Condition, true
}

func (r FieldModel) Event() (value *EventModel) {
	if r.RelationsField.Event == nil {
		panic("attempted to access event but did not fetch it using the .With() syntax")
	}
	return r.RelationsField.Event
}

func (r FieldModel) Constants() (value []ConstantModel) {
	if r.RelationsField.Constants == nil {
		panic("attempted to access constants but did not fetch it using the .With() syntax")
	}
	return r.RelationsField.Constants
}

// EventModel represents the Event model and is a wrapper for accessing fields and methods
type EventModel struct {
	InnerEvent
	RelationsEvent
}

// InnerEvent holds the actual data
type InnerEvent struct {
	ID                    string   `json:"id"`
	Name                  string   `json:"name"`
	Description           *string  `json:"description,omitempty"`
	CreatedAt             DateTime `json:"createdAt"`
	UpdatedAt             DateTime `json:"updatedAt"`
	PlaceInterfaceID      *string  `json:"placeInterfaceId,omitempty"`
	TransitionInterfaceID *string  `json:"transitionInterfaceId,omitempty"`
}

// RawEventModel is a struct for Event when used in raw queries
type RawEventModel struct {
	ID                    RawString   `json:"id"`
	Name                  RawString   `json:"name"`
	Description           *RawString  `json:"description,omitempty"`
	CreatedAt             RawDateTime `json:"createdAt"`
	UpdatedAt             RawDateTime `json:"updatedAt"`
	PlaceInterfaceID      *RawString  `json:"placeInterfaceId,omitempty"`
	TransitionInterfaceID *RawString  `json:"transitionInterfaceId,omitempty"`
}

// RelationsEvent holds the relation data separately
type RelationsEvent struct {
	Transitions         []TransitionModel         `json:"transitions,omitempty"`
	Fields              []FieldModel              `json:"fields,omitempty"`
	Commands            []ActionModel             `json:"commands,omitempty"`
	Data                []DatumModel              `json:"data,omitempty"`
	TransitionInterface *TransitionInterfaceModel `json:"transitionInterface,omitempty"`
}

func (r EventModel) Description() (value string, ok bool) {
	if r.InnerEvent.Description == nil {
		return value, false
	}
	return *r.InnerEvent.Description, true
}

func (r EventModel) Transitions() (value []TransitionModel) {
	if r.RelationsEvent.Transitions == nil {
		panic("attempted to access transitions but did not fetch it using the .With() syntax")
	}
	return r.RelationsEvent.Transitions
}

func (r EventModel) Fields() (value []FieldModel) {
	if r.RelationsEvent.Fields == nil {
		panic("attempted to access fields but did not fetch it using the .With() syntax")
	}
	return r.RelationsEvent.Fields
}

func (r EventModel) Commands() (value []ActionModel) {
	if r.RelationsEvent.Commands == nil {
		panic("attempted to access commands but did not fetch it using the .With() syntax")
	}
	return r.RelationsEvent.Commands
}

func (r EventModel) Data() (value []DatumModel) {
	if r.RelationsEvent.Data == nil {
		panic("attempted to access data but did not fetch it using the .With() syntax")
	}
	return r.RelationsEvent.Data
}

func (r EventModel) PlaceInterfaceID() (value string, ok bool) {
	if r.InnerEvent.PlaceInterfaceID == nil {
		return value, false
	}
	return *r.InnerEvent.PlaceInterfaceID, true
}

func (r EventModel) TransitionInterface() (value *TransitionInterfaceModel, ok bool) {
	if r.RelationsEvent.TransitionInterface == nil {
		return value, false
	}
	return r.RelationsEvent.TransitionInterface, true
}

func (r EventModel) TransitionInterfaceID() (value string, ok bool) {
	if r.InnerEvent.TransitionInterfaceID == nil {
		return value, false
	}
	return *r.InnerEvent.TransitionInterfaceID, true
}

// InstanceModel represents the Instance model and is a wrapper for accessing fields and methods
type InstanceModel struct {
	InnerInstance
	RelationsInstance
}

// InnerInstance holds the actual data
type InnerInstance struct {
	ID        string   `json:"id"`
	CreatedAt DateTime `json:"createdAt"`
	UpdatedAt DateTime `json:"updatedAt"`
	AuthorID  string   `json:"authorID"`
	Language  Language `json:"language"`
	Name      string   `json:"name"`
	DeviceID  string   `json:"deviceId"`
	Addr      string   `json:"addr"`
}

// RawInstanceModel is a struct for Instance when used in raw queries
type RawInstanceModel struct {
	ID        RawString   `json:"id"`
	CreatedAt RawDateTime `json:"createdAt"`
	UpdatedAt RawDateTime `json:"updatedAt"`
	AuthorID  RawString   `json:"authorID"`
	Language  RawLanguage `json:"language"`
	Name      RawString   `json:"name"`
	DeviceID  RawString   `json:"deviceId"`
	Addr      RawString   `json:"addr"`
}

// RelationsInstance holds the relation data separately
type RelationsInstance struct {
	Author   *UserModel     `json:"author,omitempty"`
	Device   *DeviceModel   `json:"device,omitempty"`
	Data     []DatumModel   `json:"data,omitempty"`
	Sessions []SessionModel `json:"sessions,omitempty"`
}

func (r InstanceModel) Author() (value *UserModel) {
	if r.RelationsInstance.Author == nil {
		panic("attempted to access author but did not fetch it using the .With() syntax")
	}
	return r.RelationsInstance.Author
}

func (r InstanceModel) Device() (value *DeviceModel) {
	if r.RelationsInstance.Device == nil {
		panic("attempted to access device but did not fetch it using the .With() syntax")
	}
	return r.RelationsInstance.Device
}

func (r InstanceModel) Data() (value []DatumModel) {
	if r.RelationsInstance.Data == nil {
		panic("attempted to access data but did not fetch it using the .With() syntax")
	}
	return r.RelationsInstance.Data
}

func (r InstanceModel) Sessions() (value []SessionModel) {
	if r.RelationsInstance.Sessions == nil {
		panic("attempted to access sessions but did not fetch it using the .With() syntax")
	}
	return r.RelationsInstance.Sessions
}

// DeviceModel represents the Device model and is a wrapper for accessing fields and methods
type DeviceModel struct {
	InnerDevice
	RelationsDevice
}

// InnerDevice holds the actual data
type InnerDevice struct {
	ID          string   `json:"id"`
	AuthorID    string   `json:"authorID"`
	Name        string   `json:"name"`
	Description string   `json:"description"`
	CreatedAt   DateTime `json:"createdAt"`
	UpdatedAt   DateTime `json:"updatedAt"`
	NetIDs      []string `json:"netIDs"`
}

// RawDeviceModel is a struct for Device when used in raw queries
type RawDeviceModel struct {
	ID          RawString   `json:"id"`
	AuthorID    RawString   `json:"authorID"`
	Name        RawString   `json:"name"`
	Description RawString   `json:"description"`
	CreatedAt   RawDateTime `json:"createdAt"`
	UpdatedAt   RawDateTime `json:"updatedAt"`
	NetIDs      []RawString `json:"netIDs"`
}

// RelationsDevice holds the relation data separately
type RelationsDevice struct {
	Author    *UserModel           `json:"author,omitempty"`
	Instances []InstanceModel      `json:"instances,omitempty"`
	Nets      []DevicesOnNetsModel `json:"nets,omitempty"`
	Actions   []ActionModel        `json:"actions,omitempty"`
}

func (r DeviceModel) Author() (value *UserModel) {
	if r.RelationsDevice.Author == nil {
		panic("attempted to access author but did not fetch it using the .With() syntax")
	}
	return r.RelationsDevice.Author
}

func (r DeviceModel) Instances() (value []InstanceModel) {
	if r.RelationsDevice.Instances == nil {
		panic("attempted to access instances but did not fetch it using the .With() syntax")
	}
	return r.RelationsDevice.Instances
}

func (r DeviceModel) Nets() (value []DevicesOnNetsModel) {
	if r.RelationsDevice.Nets == nil {
		panic("attempted to access nets but did not fetch it using the .With() syntax")
	}
	return r.RelationsDevice.Nets
}

func (r DeviceModel) Actions() (value []ActionModel) {
	if r.RelationsDevice.Actions == nil {
		panic("attempted to access actions but did not fetch it using the .With() syntax")
	}
	return r.RelationsDevice.Actions
}

// ConstantModel represents the Constant model and is a wrapper for accessing fields and methods
type ConstantModel struct {
	InnerConstant
	RelationsConstant
}

// InnerConstant holds the actual data
type InnerConstant struct {
	ID       string `json:"id"`
	ActionID string `json:"actionID"`
	FieldID  string `json:"fieldID"`
	Value    string `json:"value"`
}

// RawConstantModel is a struct for Constant when used in raw queries
type RawConstantModel struct {
	ID       RawString `json:"id"`
	ActionID RawString `json:"actionID"`
	FieldID  RawString `json:"fieldID"`
	Value    RawString `json:"value"`
}

// RelationsConstant holds the relation data separately
type RelationsConstant struct {
	Action *ActionModel `json:"action,omitempty"`
	Field  *FieldModel  `json:"field,omitempty"`
}

func (r ConstantModel) Action() (value *ActionModel) {
	if r.RelationsConstant.Action == nil {
		panic("attempted to access action but did not fetch it using the .With() syntax")
	}
	return r.RelationsConstant.Action
}

func (r ConstantModel) Field() (value *FieldModel) {
	if r.RelationsConstant.Field == nil {
		panic("attempted to access field but did not fetch it using the .With() syntax")
	}
	return r.RelationsConstant.Field
}

// ActionModel represents the Action model and is a wrapper for accessing fields and methods
type ActionModel struct {
	InnerAction
	RelationsAction
}

// InnerAction holds the actual data
type InnerAction struct {
	ID        string   `json:"id"`
	Input     JSON     `json:"input"`
	Output    JSON     `json:"output"`
	DeviceID  string   `json:"deviceId"`
	EventID   string   `json:"eventID"`
	CreatedAt DateTime `json:"createdAt"`
	UpdatedAt DateTime `json:"updatedAt"`
}

// RawActionModel is a struct for Action when used in raw queries
type RawActionModel struct {
	ID        RawString   `json:"id"`
	Input     RawJSON     `json:"input"`
	Output    RawJSON     `json:"output"`
	DeviceID  RawString   `json:"deviceId"`
	EventID   RawString   `json:"eventID"`
	CreatedAt RawDateTime `json:"createdAt"`
	UpdatedAt RawDateTime `json:"updatedAt"`
}

// RelationsAction holds the relation data separately
type RelationsAction struct {
	Device    *DeviceModel    `json:"device,omitempty"`
	Event     *EventModel     `json:"event,omitempty"`
	Constants []ConstantModel `json:"constants,omitempty"`
	Steps     []StepModel     `json:"steps,omitempty"`
}

func (r ActionModel) Device() (value *DeviceModel) {
	if r.RelationsAction.Device == nil {
		panic("attempted to access device but did not fetch it using the .With() syntax")
	}
	return r.RelationsAction.Device
}

func (r ActionModel) Event() (value *EventModel) {
	if r.RelationsAction.Event == nil {
		panic("attempted to access event but did not fetch it using the .With() syntax")
	}
	return r.RelationsAction.Event
}

func (r ActionModel) Constants() (value []ConstantModel) {
	if r.RelationsAction.Constants == nil {
		panic("attempted to access constants but did not fetch it using the .With() syntax")
	}
	return r.RelationsAction.Constants
}

func (r ActionModel) Steps() (value []StepModel) {
	if r.RelationsAction.Steps == nil {
		panic("attempted to access steps but did not fetch it using the .With() syntax")
	}
	return r.RelationsAction.Steps
}

// StepModel represents the Step model and is a wrapper for accessing fields and methods
type StepModel struct {
	InnerStep
	RelationsStep
}

// InnerStep holds the actual data
type InnerStep struct {
	ID       string `json:"id"`
	Order    int    `json:"order"`
	RunID    string `json:"runID"`
	ActionID string `json:"actionID"`
}

// RawStepModel is a struct for Step when used in raw queries
type RawStepModel struct {
	ID       RawString `json:"id"`
	Order    RawInt    `json:"order"`
	RunID    RawString `json:"runID"`
	ActionID RawString `json:"actionID"`
}

// RelationsStep holds the relation data separately
type RelationsStep struct {
	Run    *RunModel    `json:"run,omitempty"`
	Action *ActionModel `json:"action,omitempty"`
}

func (r StepModel) Run() (value *RunModel) {
	if r.RelationsStep.Run == nil {
		panic("attempted to access run but did not fetch it using the .With() syntax")
	}
	return r.RelationsStep.Run
}

func (r StepModel) Action() (value *ActionModel) {
	if r.RelationsStep.Action == nil {
		panic("attempted to access action but did not fetch it using the .With() syntax")
	}
	return r.RelationsStep.Action
}

// RunModel represents the Run model and is a wrapper for accessing fields and methods
type RunModel struct {
	InnerRun
	RelationsRun
}

// InnerRun holds the actual data
type InnerRun struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	Description string   `json:"description"`
	CreatedAt   DateTime `json:"createdAt"`
	UpdatedAt   DateTime `json:"updatedAt"`
	NetID       string   `json:"netID"`
}

// RawRunModel is a struct for Run when used in raw queries
type RawRunModel struct {
	ID          RawString   `json:"id"`
	Name        RawString   `json:"name"`
	Description RawString   `json:"description"`
	CreatedAt   RawDateTime `json:"createdAt"`
	UpdatedAt   RawDateTime `json:"updatedAt"`
	NetID       RawString   `json:"netID"`
}

// RelationsRun holds the relation data separately
type RelationsRun struct {
	Net      *NetModel      `json:"net,omitempty"`
	Sessions []SessionModel `json:"sessions,omitempty"`
	Steps    []StepModel    `json:"steps,omitempty"`
}

func (r RunModel) Net() (value *NetModel) {
	if r.RelationsRun.Net == nil {
		panic("attempted to access net but did not fetch it using the .With() syntax")
	}
	return r.RelationsRun.Net
}

func (r RunModel) Sessions() (value []SessionModel) {
	if r.RelationsRun.Sessions == nil {
		panic("attempted to access sessions but did not fetch it using the .With() syntax")
	}
	return r.RelationsRun.Sessions
}

func (r RunModel) Steps() (value []StepModel) {
	if r.RelationsRun.Steps == nil {
		panic("attempted to access steps but did not fetch it using the .With() syntax")
	}
	return r.RelationsRun.Steps
}

// DatumModel represents the Datum model and is a wrapper for accessing fields and methods
type DatumModel struct {
	InnerDatum
	RelationsDatum
}

// InnerDatum holds the actual data
type InnerDatum struct {
	ID         string   `json:"id"`
	InstanceID string   `json:"instanceID"`
	SessionID  string   `json:"sessionID"`
	Value      *JSON    `json:"value,omitempty"`
	CreatedAt  DateTime `json:"createdAt"`
	UpdatedAt  DateTime `json:"updatedAt"`
	EventID    string   `json:"eventId"`
}

// RawDatumModel is a struct for Datum when used in raw queries
type RawDatumModel struct {
	ID         RawString   `json:"id"`
	InstanceID RawString   `json:"instanceID"`
	SessionID  RawString   `json:"sessionID"`
	Value      *RawJSON    `json:"value,omitempty"`
	CreatedAt  RawDateTime `json:"createdAt"`
	UpdatedAt  RawDateTime `json:"updatedAt"`
	EventID    RawString   `json:"eventId"`
}

// RelationsDatum holds the relation data separately
type RelationsDatum struct {
	Instance *InstanceModel `json:"instance,omitempty"`
	Session  *SessionModel  `json:"session,omitempty"`
	Event    *EventModel    `json:"event,omitempty"`
}

func (r DatumModel) Instance() (value *InstanceModel) {
	if r.RelationsDatum.Instance == nil {
		panic("attempted to access instance but did not fetch it using the .With() syntax")
	}
	return r.RelationsDatum.Instance
}

func (r DatumModel) Session() (value *SessionModel) {
	if r.RelationsDatum.Session == nil {
		panic("attempted to access session but did not fetch it using the .With() syntax")
	}
	return r.RelationsDatum.Session
}

func (r DatumModel) Value() (value JSON, ok bool) {
	if r.InnerDatum.Value == nil {
		return value, false
	}
	return *r.InnerDatum.Value, true
}

func (r DatumModel) Event() (value *EventModel) {
	if r.RelationsDatum.Event == nil {
		panic("attempted to access event but did not fetch it using the .With() syntax")
	}
	return r.RelationsDatum.Event
}

// SessionModel represents the Session model and is a wrapper for accessing fields and methods
type SessionModel struct {
	InnerSession
	RelationsSession
}

// InnerSession holds the actual data
type InnerSession struct {
	ID        string       `json:"id"`
	UserID    string       `json:"userID"`
	CreatedAt DateTime     `json:"createdAt"`
	UpdatedAt DateTime     `json:"updatedAt"`
	StartedAt *DateTime    `json:"startedAt,omitempty"`
	StoppedAt *DateTime    `json:"stoppedAt,omitempty"`
	PausedAt  []DateTime   `json:"pausedAt"`
	ResumedAt []DateTime   `json:"resumedAt"`
	State     SessionState `json:"state"`
	Deleted   bool         `json:"deleted"`
	RunID     string       `json:"runID"`
}

// RawSessionModel is a struct for Session when used in raw queries
type RawSessionModel struct {
	ID        RawString       `json:"id"`
	UserID    RawString       `json:"userID"`
	CreatedAt RawDateTime     `json:"createdAt"`
	UpdatedAt RawDateTime     `json:"updatedAt"`
	StartedAt *RawDateTime    `json:"startedAt,omitempty"`
	StoppedAt *RawDateTime    `json:"stoppedAt,omitempty"`
	PausedAt  []RawDateTime   `json:"pausedAt"`
	ResumedAt []RawDateTime   `json:"resumedAt"`
	State     RawSessionState `json:"state"`
	Deleted   RawBoolean      `json:"deleted"`
	RunID     RawString       `json:"runID"`
}

// RelationsSession holds the relation data separately
type RelationsSession struct {
	User      *UserModel      `json:"user,omitempty"`
	Run       *RunModel       `json:"run,omitempty"`
	Instances []InstanceModel `json:"instances,omitempty"`
	Data      []DatumModel    `json:"data,omitempty"`
}

func (r SessionModel) User() (value *UserModel) {
	if r.RelationsSession.User == nil {
		panic("attempted to access user but did not fetch it using the .With() syntax")
	}
	return r.RelationsSession.User
}

func (r SessionModel) StartedAt() (value DateTime, ok bool) {
	if r.InnerSession.StartedAt == nil {
		return value, false
	}
	return *r.InnerSession.StartedAt, true
}

func (r SessionModel) StoppedAt() (value DateTime, ok bool) {
	if r.InnerSession.StoppedAt == nil {
		return value, false
	}
	return *r.InnerSession.StoppedAt, true
}

func (r SessionModel) Run() (value *RunModel) {
	if r.RelationsSession.Run == nil {
		panic("attempted to access run but did not fetch it using the .With() syntax")
	}
	return r.RelationsSession.Run
}

func (r SessionModel) Instances() (value []InstanceModel) {
	if r.RelationsSession.Instances == nil {
		panic("attempted to access instances but did not fetch it using the .With() syntax")
	}
	return r.RelationsSession.Instances
}

func (r SessionModel) Data() (value []DatumModel) {
	if r.RelationsSession.Data == nil {
		panic("attempted to access data but did not fetch it using the .With() syntax")
	}
	return r.RelationsSession.Data
}

// --- template query.gotpl ---

// User acts as a namespaces to access query methods for the User model
var User = userQuery{}

// userQuery exposes query functions for the user model
type userQuery struct {

	// ID
	//
	// @required
	ID userQueryIDString

	// Email
	//
	// @required
	// @unique
	Email userQueryEmailString

	// Role
	//
	// @required
	Role userQueryRoleUserRole

	// CreatedAt
	//
	// @required
	CreatedAt userQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt userQueryUpdatedAtDateTime

	Password userQueryPasswordRelations

	Nets userQueryNetsRelations

	Devices userQueryDevicesRelations

	Instances userQueryInstancesRelations

	Sessions userQuerySessionsRelations
}

func (userQuery) Not(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) Or(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) And(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type userQueryIDString struct{}

// Set the required value of ID
func (r userQueryIDString) Set(value string) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r userQueryIDString) SetIfPresent(value *string) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryIDString) Equals(value string) userWithPrismaIDEqualsUniqueParam {

	return userWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) EqualsIfPresent(value *string) userWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return userWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryIDString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r userQueryIDString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r userQueryIDString) In(value []string) userParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryIDString) InIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryIDString) NotIn(value []string) userParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryIDString) NotInIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryIDString) Lt(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) LtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryIDString) Lte(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) LteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryIDString) Gt(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) GtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryIDString) Gte(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) GteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryIDString) Contains(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) ContainsIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Contains(*value)
}

func (r userQueryIDString) StartsWith(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) StartsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r userQueryIDString) EndsWith(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) EndsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r userQueryIDString) Mode(value QueryMode) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) ModeIfPresent(value *QueryMode) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Mode(*value)
}

func (r userQueryIDString) Not(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) NotIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryIDString) HasPrefix(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryIDString) HasPrefixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryIDString) HasSuffix(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryIDString) HasSuffixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type userQueryEmailString struct{}

// Set the required value of Email
func (r userQueryEmailString) Set(value string) userWithPrismaEmailSetParam {

	return userWithPrismaEmailSetParam{
		data: builder.Field{
			Name:  "email",
			Value: value,
		},
	}

}

// Set the optional value of Email dynamically
func (r userQueryEmailString) SetIfPresent(value *string) userWithPrismaEmailSetParam {
	if value == nil {
		return userWithPrismaEmailSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryEmailString) Equals(value string) userWithPrismaEmailEqualsUniqueParam {

	return userWithPrismaEmailEqualsUniqueParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) EqualsIfPresent(value *string) userWithPrismaEmailEqualsUniqueParam {
	if value == nil {
		return userWithPrismaEmailEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryEmailString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "email",
			Value: direction,
		},
	}
}

func (r userQueryEmailString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "email",
			Value: cursor,
		},
	}
}

func (r userQueryEmailString) In(value []string) userParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryEmailString) InIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryEmailString) NotIn(value []string) userParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryEmailString) NotInIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryEmailString) Lt(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) LtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryEmailString) Lte(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) LteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryEmailString) Gt(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) GtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryEmailString) Gte(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) GteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryEmailString) Contains(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) ContainsIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Contains(*value)
}

func (r userQueryEmailString) StartsWith(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) StartsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r userQueryEmailString) EndsWith(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) EndsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r userQueryEmailString) Mode(value QueryMode) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) ModeIfPresent(value *QueryMode) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Mode(*value)
}

func (r userQueryEmailString) Not(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) NotIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryEmailString) HasPrefix(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryEmailString) HasPrefixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryEmailString) HasSuffix(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryEmailString) HasSuffixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type userQueryRoleUserRole struct{}

// Set the required value of Role
func (r userQueryRoleUserRole) Set(value UserRole) userWithPrismaRoleSetParam {

	return userWithPrismaRoleSetParam{
		data: builder.Field{
			Name:  "role",
			Value: value,
		},
	}

}

// Set the optional value of Role dynamically
func (r userQueryRoleUserRole) SetIfPresent(value *UserRole) userWithPrismaRoleSetParam {
	if value == nil {
		return userWithPrismaRoleSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryRoleUserRole) Equals(value UserRole) userWithPrismaRoleEqualsParam {

	return userWithPrismaRoleEqualsParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleUserRole) EqualsIfPresent(value *UserRole) userWithPrismaRoleEqualsParam {
	if value == nil {
		return userWithPrismaRoleEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryRoleUserRole) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "role",
			Value: direction,
		},
	}
}

func (r userQueryRoleUserRole) Cursor(cursor UserRole) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "role",
			Value: cursor,
		},
	}
}

func (r userQueryRoleUserRole) In(value []UserRole) userDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryRoleUserRole) InIfPresent(value []UserRole) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryRoleUserRole) NotIn(value []UserRole) userDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryRoleUserRole) NotInIfPresent(value []UserRole) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryRoleUserRole) Not(value UserRole) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleUserRole) NotIfPresent(value *UserRole) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// base struct
type userQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r userQueryCreatedAtDateTime) Set(value DateTime) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r userQueryCreatedAtDateTime) SetIfPresent(value *DateTime) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryCreatedAtDateTime) Equals(value DateTime) userWithPrismaCreatedAtEqualsParam {

	return userWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) userWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return userWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryCreatedAtDateTime) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r userQueryCreatedAtDateTime) Cursor(cursor DateTime) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r userQueryCreatedAtDateTime) In(value []DateTime) userDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) InIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryCreatedAtDateTime) NotIn(value []DateTime) userDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryCreatedAtDateTime) Lt(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) LtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryCreatedAtDateTime) Lte(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) LteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryCreatedAtDateTime) Gt(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) GtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryCreatedAtDateTime) Gte(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) GteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryCreatedAtDateTime) Not(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) NotIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQueryCreatedAtDateTime) Before(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userQueryCreatedAtDateTime) After(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userQueryCreatedAtDateTime) BeforeEquals(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userQueryCreatedAtDateTime) AfterEquals(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type userQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r userQueryUpdatedAtDateTime) Set(value DateTime) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r userQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryUpdatedAtDateTime) Equals(value DateTime) userWithPrismaUpdatedAtEqualsParam {

	return userWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) userWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return userWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryUpdatedAtDateTime) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r userQueryUpdatedAtDateTime) Cursor(cursor DateTime) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r userQueryUpdatedAtDateTime) In(value []DateTime) userDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) InIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryUpdatedAtDateTime) NotIn(value []DateTime) userDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryUpdatedAtDateTime) Lt(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryUpdatedAtDateTime) Lte(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryUpdatedAtDateTime) Gt(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryUpdatedAtDateTime) Gte(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryUpdatedAtDateTime) Not(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQueryUpdatedAtDateTime) Before(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userQueryUpdatedAtDateTime) After(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userQueryUpdatedAtDateTime) BeforeEquals(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userQueryUpdatedAtDateTime) AfterEquals(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type userQueryPasswordPassword struct{}

type userQueryPasswordRelations struct{}

// User -> Password
//
// @relation
// @optional
func (userQueryPasswordRelations) Where(
	params ...PasswordWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryPasswordRelations) Fetch() userToPasswordFindUnique {
	var v userToPasswordFindUnique

	v.query.Operation = "query"
	v.query.Method = "password"
	v.query.Outputs = passwordOutput

	return v
}

func (r userQueryPasswordRelations) Link(
	params PasswordWhereParam,
) userSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return userSetParam{}
	}

	fields = append(fields, f)

	return userSetParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r userQueryPasswordRelations) Unlink() userSetParam {
	var v userSetParam

	v = userSetParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type userQueryNetsNet struct{}

type userQueryNetsRelations struct{}

// User -> Nets
//
// @relation
// @required
func (userQueryNetsRelations) Some(
	params ...NetWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "nets",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Nets
//
// @relation
// @required
func (userQueryNetsRelations) Every(
	params ...NetWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "nets",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryNetsRelations) Fetch(

	params ...NetWhereParam,

) userToNetsFindMany {
	var v userToNetsFindMany

	v.query.Operation = "query"
	v.query.Method = "nets"
	v.query.Outputs = netOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryNetsRelations) Link(
	params ...NetWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "nets",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryNetsRelations) Unlink(
	params ...NetWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "nets",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type userQueryDevicesDevice struct{}

type userQueryDevicesRelations struct{}

// User -> Devices
//
// @relation
// @required
func (userQueryDevicesRelations) Some(
	params ...DeviceWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "devices",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Devices
//
// @relation
// @required
func (userQueryDevicesRelations) Every(
	params ...DeviceWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "devices",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryDevicesRelations) Fetch(

	params ...DeviceWhereParam,

) userToDevicesFindMany {
	var v userToDevicesFindMany

	v.query.Operation = "query"
	v.query.Method = "devices"
	v.query.Outputs = deviceOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryDevicesRelations) Link(
	params ...DeviceWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "devices",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryDevicesRelations) Unlink(
	params ...DeviceWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "devices",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type userQueryInstancesInstance struct{}

type userQueryInstancesRelations struct{}

// User -> Instances
//
// @relation
// @required
func (userQueryInstancesRelations) Some(
	params ...InstanceWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "instances",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Instances
//
// @relation
// @required
func (userQueryInstancesRelations) Every(
	params ...InstanceWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "instances",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryInstancesRelations) Fetch(

	params ...InstanceWhereParam,

) userToInstancesFindMany {
	var v userToInstancesFindMany

	v.query.Operation = "query"
	v.query.Method = "instances"
	v.query.Outputs = instanceOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryInstancesRelations) Link(
	params ...InstanceWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "instances",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryInstancesRelations) Unlink(
	params ...InstanceWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "instances",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type userQuerySessionsSession struct{}

type userQuerySessionsRelations struct{}

// User -> Sessions
//
// @relation
// @required
func (userQuerySessionsRelations) Some(
	params ...SessionWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "sessions",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Sessions
//
// @relation
// @required
func (userQuerySessionsRelations) Every(
	params ...SessionWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "sessions",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (userQuerySessionsRelations) Fetch(

	params ...SessionWhereParam,

) userToSessionsFindMany {
	var v userToSessionsFindMany

	v.query.Operation = "query"
	v.query.Method = "sessions"
	v.query.Outputs = sessionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQuerySessionsRelations) Link(
	params ...SessionWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "sessions",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQuerySessionsRelations) Unlink(
	params ...SessionWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "sessions",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// Password acts as a namespaces to access query methods for the Password model
var Password = passwordQuery{}

// passwordQuery exposes query functions for the password model
type passwordQuery struct {

	// Hash
	//
	// @required
	Hash passwordQueryHashString

	User passwordQueryUserRelations

	// UserID
	//
	// @required
	// @unique
	UserID passwordQueryUserIDString
}

func (passwordQuery) Not(params ...PasswordWhereParam) passwordDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return passwordDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (passwordQuery) Or(params ...PasswordWhereParam) passwordDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return passwordDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (passwordQuery) And(params ...PasswordWhereParam) passwordDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return passwordDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type passwordQueryHashString struct{}

// Set the required value of Hash
func (r passwordQueryHashString) Set(value string) passwordWithPrismaHashSetParam {

	return passwordWithPrismaHashSetParam{
		data: builder.Field{
			Name:  "hash",
			Value: value,
		},
	}

}

// Set the optional value of Hash dynamically
func (r passwordQueryHashString) SetIfPresent(value *string) passwordWithPrismaHashSetParam {
	if value == nil {
		return passwordWithPrismaHashSetParam{}
	}

	return r.Set(*value)
}

func (r passwordQueryHashString) Equals(value string) passwordWithPrismaHashEqualsParam {

	return passwordWithPrismaHashEqualsParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryHashString) EqualsIfPresent(value *string) passwordWithPrismaHashEqualsParam {
	if value == nil {
		return passwordWithPrismaHashEqualsParam{}
	}
	return r.Equals(*value)
}

func (r passwordQueryHashString) Order(direction SortOrder) passwordDefaultParam {
	return passwordDefaultParam{
		data: builder.Field{
			Name:  "hash",
			Value: direction,
		},
	}
}

func (r passwordQueryHashString) Cursor(cursor string) passwordCursorParam {
	return passwordCursorParam{
		data: builder.Field{
			Name:  "hash",
			Value: cursor,
		},
	}
}

func (r passwordQueryHashString) In(value []string) passwordDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return passwordDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r passwordQueryHashString) InIfPresent(value []string) passwordDefaultParam {
	if value == nil {
		return passwordDefaultParam{}
	}
	return r.In(value)
}

func (r passwordQueryHashString) NotIn(value []string) passwordDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return passwordDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r passwordQueryHashString) NotInIfPresent(value []string) passwordDefaultParam {
	if value == nil {
		return passwordDefaultParam{}
	}
	return r.NotIn(value)
}

func (r passwordQueryHashString) Lt(value string) passwordDefaultParam {

	return passwordDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryHashString) LtIfPresent(value *string) passwordDefaultParam {
	if value == nil {
		return passwordDefaultParam{}
	}
	return r.Lt(*value)
}

func (r passwordQueryHashString) Lte(value string) passwordDefaultParam {

	return passwordDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryHashString) LteIfPresent(value *string) passwordDefaultParam {
	if value == nil {
		return passwordDefaultParam{}
	}
	return r.Lte(*value)
}

func (r passwordQueryHashString) Gt(value string) passwordDefaultParam {

	return passwordDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryHashString) GtIfPresent(value *string) passwordDefaultParam {
	if value == nil {
		return passwordDefaultParam{}
	}
	return r.Gt(*value)
}

func (r passwordQueryHashString) Gte(value string) passwordDefaultParam {

	return passwordDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryHashString) GteIfPresent(value *string) passwordDefaultParam {
	if value == nil {
		return passwordDefaultParam{}
	}
	return r.Gte(*value)
}

func (r passwordQueryHashString) Contains(value string) passwordDefaultParam {

	return passwordDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryHashString) ContainsIfPresent(value *string) passwordDefaultParam {
	if value == nil {
		return passwordDefaultParam{}
	}
	return r.Contains(*value)
}

func (r passwordQueryHashString) StartsWith(value string) passwordDefaultParam {

	return passwordDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryHashString) StartsWithIfPresent(value *string) passwordDefaultParam {
	if value == nil {
		return passwordDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r passwordQueryHashString) EndsWith(value string) passwordDefaultParam {

	return passwordDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryHashString) EndsWithIfPresent(value *string) passwordDefaultParam {
	if value == nil {
		return passwordDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r passwordQueryHashString) Mode(value QueryMode) passwordDefaultParam {

	return passwordDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryHashString) ModeIfPresent(value *QueryMode) passwordDefaultParam {
	if value == nil {
		return passwordDefaultParam{}
	}
	return r.Mode(*value)
}

func (r passwordQueryHashString) Not(value string) passwordDefaultParam {

	return passwordDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryHashString) NotIfPresent(value *string) passwordDefaultParam {
	if value == nil {
		return passwordDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r passwordQueryHashString) HasPrefix(value string) passwordDefaultParam {

	return passwordDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r passwordQueryHashString) HasPrefixIfPresent(value *string) passwordDefaultParam {
	if value == nil {
		return passwordDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r passwordQueryHashString) HasSuffix(value string) passwordDefaultParam {

	return passwordDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r passwordQueryHashString) HasSuffixIfPresent(value *string) passwordDefaultParam {
	if value == nil {
		return passwordDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type passwordQueryUserUser struct{}

type passwordQueryUserRelations struct{}

// Password -> User
//
// @relation
// @required
func (passwordQueryUserRelations) Where(
	params ...UserWhereParam,
) passwordDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return passwordDefaultParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (passwordQueryUserRelations) Fetch() passwordToUserFindUnique {
	var v passwordToUserFindUnique

	v.query.Operation = "query"
	v.query.Method = "user"
	v.query.Outputs = userOutput

	return v
}

func (r passwordQueryUserRelations) Link(
	params UserWhereParam,
) passwordWithPrismaUserSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return passwordWithPrismaUserSetParam{}
	}

	fields = append(fields, f)

	return passwordWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r passwordQueryUserRelations) Unlink() passwordWithPrismaUserSetParam {
	var v passwordWithPrismaUserSetParam

	v = passwordWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type passwordQueryUserIDString struct{}

// Set the required value of UserID
func (r passwordQueryUserIDString) Set(value string) passwordSetParam {

	return passwordSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r passwordQueryUserIDString) SetIfPresent(value *string) passwordSetParam {
	if value == nil {
		return passwordSetParam{}
	}

	return r.Set(*value)
}

func (r passwordQueryUserIDString) Equals(value string) passwordWithPrismaUserIDEqualsUniqueParam {

	return passwordWithPrismaUserIDEqualsUniqueParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryUserIDString) EqualsIfPresent(value *string) passwordWithPrismaUserIDEqualsUniqueParam {
	if value == nil {
		return passwordWithPrismaUserIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r passwordQueryUserIDString) Order(direction SortOrder) passwordDefaultParam {
	return passwordDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r passwordQueryUserIDString) Cursor(cursor string) passwordCursorParam {
	return passwordCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r passwordQueryUserIDString) In(value []string) passwordParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return passwordParamUnique{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r passwordQueryUserIDString) InIfPresent(value []string) passwordParamUnique {
	if value == nil {
		return passwordParamUnique{}
	}
	return r.In(value)
}

func (r passwordQueryUserIDString) NotIn(value []string) passwordParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return passwordParamUnique{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r passwordQueryUserIDString) NotInIfPresent(value []string) passwordParamUnique {
	if value == nil {
		return passwordParamUnique{}
	}
	return r.NotIn(value)
}

func (r passwordQueryUserIDString) Lt(value string) passwordParamUnique {

	return passwordParamUnique{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryUserIDString) LtIfPresent(value *string) passwordParamUnique {
	if value == nil {
		return passwordParamUnique{}
	}
	return r.Lt(*value)
}

func (r passwordQueryUserIDString) Lte(value string) passwordParamUnique {

	return passwordParamUnique{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryUserIDString) LteIfPresent(value *string) passwordParamUnique {
	if value == nil {
		return passwordParamUnique{}
	}
	return r.Lte(*value)
}

func (r passwordQueryUserIDString) Gt(value string) passwordParamUnique {

	return passwordParamUnique{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryUserIDString) GtIfPresent(value *string) passwordParamUnique {
	if value == nil {
		return passwordParamUnique{}
	}
	return r.Gt(*value)
}

func (r passwordQueryUserIDString) Gte(value string) passwordParamUnique {

	return passwordParamUnique{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryUserIDString) GteIfPresent(value *string) passwordParamUnique {
	if value == nil {
		return passwordParamUnique{}
	}
	return r.Gte(*value)
}

func (r passwordQueryUserIDString) Contains(value string) passwordParamUnique {

	return passwordParamUnique{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryUserIDString) ContainsIfPresent(value *string) passwordParamUnique {
	if value == nil {
		return passwordParamUnique{}
	}
	return r.Contains(*value)
}

func (r passwordQueryUserIDString) StartsWith(value string) passwordParamUnique {

	return passwordParamUnique{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryUserIDString) StartsWithIfPresent(value *string) passwordParamUnique {
	if value == nil {
		return passwordParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r passwordQueryUserIDString) EndsWith(value string) passwordParamUnique {

	return passwordParamUnique{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryUserIDString) EndsWithIfPresent(value *string) passwordParamUnique {
	if value == nil {
		return passwordParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r passwordQueryUserIDString) Mode(value QueryMode) passwordParamUnique {

	return passwordParamUnique{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryUserIDString) ModeIfPresent(value *QueryMode) passwordParamUnique {
	if value == nil {
		return passwordParamUnique{}
	}
	return r.Mode(*value)
}

func (r passwordQueryUserIDString) Not(value string) passwordParamUnique {

	return passwordParamUnique{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r passwordQueryUserIDString) NotIfPresent(value *string) passwordParamUnique {
	if value == nil {
		return passwordParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r passwordQueryUserIDString) HasPrefix(value string) passwordParamUnique {

	return passwordParamUnique{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r passwordQueryUserIDString) HasPrefixIfPresent(value *string) passwordParamUnique {
	if value == nil {
		return passwordParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r passwordQueryUserIDString) HasSuffix(value string) passwordParamUnique {

	return passwordParamUnique{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r passwordQueryUserIDString) HasSuffixIfPresent(value *string) passwordParamUnique {
	if value == nil {
		return passwordParamUnique{}
	}
	return r.HasSuffix(*value)
}

// Net acts as a namespaces to access query methods for the Net model
var Net = netQuery{}

// netQuery exposes query functions for the net model
type netQuery struct {

	// ID
	//
	// @required
	ID netQueryIDString

	// Name
	//
	// @required
	Name netQueryNameString

	// Description
	//
	// @required
	Description netQueryDescriptionString

	// InitialMarking
	//
	// @required
	InitialMarking netQueryInitialMarkingInt

	// CreatedAt
	//
	// @required
	CreatedAt netQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt netQueryUpdatedAtDateTime

	Author netQueryAuthorRelations

	// AuthorID
	//
	// @required
	AuthorID netQueryAuthorIDString

	Arcs netQueryArcsRelations

	Places netQueryPlacesRelations

	Transitions netQueryTransitionsRelations

	Parent netQueryParentRelations

	// ParentID
	//
	// @optional
	ParentID netQueryParentIDString

	Children netQueryChildrenRelations

	Devices netQueryDevicesRelations

	PlaceInterfaces netQueryPlaceInterfacesRelations

	TransitionInterfaces netQueryTransitionInterfacesRelations

	Runs netQueryRunsRelations
}

func (netQuery) Not(params ...NetWhereParam) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (netQuery) Or(params ...NetWhereParam) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (netQuery) And(params ...NetWhereParam) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type netQueryIDString struct{}

// Set the required value of ID
func (r netQueryIDString) Set(value string) netSetParam {

	return netSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r netQueryIDString) SetIfPresent(value *string) netSetParam {
	if value == nil {
		return netSetParam{}
	}

	return r.Set(*value)
}

func (r netQueryIDString) Equals(value string) netWithPrismaIDEqualsUniqueParam {

	return netWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r netQueryIDString) EqualsIfPresent(value *string) netWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return netWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r netQueryIDString) Order(direction SortOrder) netDefaultParam {
	return netDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r netQueryIDString) Cursor(cursor string) netCursorParam {
	return netCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r netQueryIDString) In(value []string) netParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryIDString) InIfPresent(value []string) netParamUnique {
	if value == nil {
		return netParamUnique{}
	}
	return r.In(value)
}

func (r netQueryIDString) NotIn(value []string) netParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryIDString) NotInIfPresent(value []string) netParamUnique {
	if value == nil {
		return netParamUnique{}
	}
	return r.NotIn(value)
}

func (r netQueryIDString) Lt(value string) netParamUnique {

	return netParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryIDString) LtIfPresent(value *string) netParamUnique {
	if value == nil {
		return netParamUnique{}
	}
	return r.Lt(*value)
}

func (r netQueryIDString) Lte(value string) netParamUnique {

	return netParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryIDString) LteIfPresent(value *string) netParamUnique {
	if value == nil {
		return netParamUnique{}
	}
	return r.Lte(*value)
}

func (r netQueryIDString) Gt(value string) netParamUnique {

	return netParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryIDString) GtIfPresent(value *string) netParamUnique {
	if value == nil {
		return netParamUnique{}
	}
	return r.Gt(*value)
}

func (r netQueryIDString) Gte(value string) netParamUnique {

	return netParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryIDString) GteIfPresent(value *string) netParamUnique {
	if value == nil {
		return netParamUnique{}
	}
	return r.Gte(*value)
}

func (r netQueryIDString) Contains(value string) netParamUnique {

	return netParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryIDString) ContainsIfPresent(value *string) netParamUnique {
	if value == nil {
		return netParamUnique{}
	}
	return r.Contains(*value)
}

func (r netQueryIDString) StartsWith(value string) netParamUnique {

	return netParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryIDString) StartsWithIfPresent(value *string) netParamUnique {
	if value == nil {
		return netParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r netQueryIDString) EndsWith(value string) netParamUnique {

	return netParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryIDString) EndsWithIfPresent(value *string) netParamUnique {
	if value == nil {
		return netParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r netQueryIDString) Mode(value QueryMode) netParamUnique {

	return netParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryIDString) ModeIfPresent(value *QueryMode) netParamUnique {
	if value == nil {
		return netParamUnique{}
	}
	return r.Mode(*value)
}

func (r netQueryIDString) Not(value string) netParamUnique {

	return netParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryIDString) NotIfPresent(value *string) netParamUnique {
	if value == nil {
		return netParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r netQueryIDString) HasPrefix(value string) netParamUnique {

	return netParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r netQueryIDString) HasPrefixIfPresent(value *string) netParamUnique {
	if value == nil {
		return netParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r netQueryIDString) HasSuffix(value string) netParamUnique {

	return netParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r netQueryIDString) HasSuffixIfPresent(value *string) netParamUnique {
	if value == nil {
		return netParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type netQueryNameString struct{}

// Set the required value of Name
func (r netQueryNameString) Set(value string) netWithPrismaNameSetParam {

	return netWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r netQueryNameString) SetIfPresent(value *string) netWithPrismaNameSetParam {
	if value == nil {
		return netWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r netQueryNameString) Equals(value string) netWithPrismaNameEqualsParam {

	return netWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r netQueryNameString) EqualsIfPresent(value *string) netWithPrismaNameEqualsParam {
	if value == nil {
		return netWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r netQueryNameString) Order(direction SortOrder) netDefaultParam {
	return netDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r netQueryNameString) Cursor(cursor string) netCursorParam {
	return netCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r netQueryNameString) In(value []string) netDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryNameString) InIfPresent(value []string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.In(value)
}

func (r netQueryNameString) NotIn(value []string) netDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryNameString) NotInIfPresent(value []string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.NotIn(value)
}

func (r netQueryNameString) Lt(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryNameString) LtIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Lt(*value)
}

func (r netQueryNameString) Lte(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryNameString) LteIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Lte(*value)
}

func (r netQueryNameString) Gt(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryNameString) GtIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Gt(*value)
}

func (r netQueryNameString) Gte(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryNameString) GteIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Gte(*value)
}

func (r netQueryNameString) Contains(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryNameString) ContainsIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Contains(*value)
}

func (r netQueryNameString) StartsWith(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryNameString) StartsWithIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r netQueryNameString) EndsWith(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryNameString) EndsWithIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r netQueryNameString) Mode(value QueryMode) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryNameString) ModeIfPresent(value *QueryMode) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Mode(*value)
}

func (r netQueryNameString) Not(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryNameString) NotIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r netQueryNameString) HasPrefix(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r netQueryNameString) HasPrefixIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r netQueryNameString) HasSuffix(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r netQueryNameString) HasSuffixIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type netQueryDescriptionString struct{}

// Set the required value of Description
func (r netQueryDescriptionString) Set(value string) netWithPrismaDescriptionSetParam {

	return netWithPrismaDescriptionSetParam{
		data: builder.Field{
			Name:  "description",
			Value: value,
		},
	}

}

// Set the optional value of Description dynamically
func (r netQueryDescriptionString) SetIfPresent(value *string) netWithPrismaDescriptionSetParam {
	if value == nil {
		return netWithPrismaDescriptionSetParam{}
	}

	return r.Set(*value)
}

func (r netQueryDescriptionString) Equals(value string) netWithPrismaDescriptionEqualsParam {

	return netWithPrismaDescriptionEqualsParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r netQueryDescriptionString) EqualsIfPresent(value *string) netWithPrismaDescriptionEqualsParam {
	if value == nil {
		return netWithPrismaDescriptionEqualsParam{}
	}
	return r.Equals(*value)
}

func (r netQueryDescriptionString) Order(direction SortOrder) netDefaultParam {
	return netDefaultParam{
		data: builder.Field{
			Name:  "description",
			Value: direction,
		},
	}
}

func (r netQueryDescriptionString) Cursor(cursor string) netCursorParam {
	return netCursorParam{
		data: builder.Field{
			Name:  "description",
			Value: cursor,
		},
	}
}

func (r netQueryDescriptionString) In(value []string) netDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryDescriptionString) InIfPresent(value []string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.In(value)
}

func (r netQueryDescriptionString) NotIn(value []string) netDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryDescriptionString) NotInIfPresent(value []string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.NotIn(value)
}

func (r netQueryDescriptionString) Lt(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryDescriptionString) LtIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Lt(*value)
}

func (r netQueryDescriptionString) Lte(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryDescriptionString) LteIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Lte(*value)
}

func (r netQueryDescriptionString) Gt(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryDescriptionString) GtIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Gt(*value)
}

func (r netQueryDescriptionString) Gte(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryDescriptionString) GteIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Gte(*value)
}

func (r netQueryDescriptionString) Contains(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryDescriptionString) ContainsIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Contains(*value)
}

func (r netQueryDescriptionString) StartsWith(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryDescriptionString) StartsWithIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r netQueryDescriptionString) EndsWith(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryDescriptionString) EndsWithIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r netQueryDescriptionString) Mode(value QueryMode) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryDescriptionString) ModeIfPresent(value *QueryMode) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Mode(*value)
}

func (r netQueryDescriptionString) Not(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryDescriptionString) NotIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r netQueryDescriptionString) HasPrefix(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r netQueryDescriptionString) HasPrefixIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r netQueryDescriptionString) HasSuffix(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r netQueryDescriptionString) HasSuffixIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type netQueryInitialMarkingInt struct{}

// Set the required value of InitialMarking
func (r netQueryInitialMarkingInt) Set(value []int) netSetParam {

	if value == nil {
		value = []int{}
	}

	return netSetParam{
		data: builder.Field{
			Name: "initialMarking",
			Fields: []builder.Field{
				builder.Field{
					Name:  "set",
					Value: value,
				},
			},
		},
	}

}

// Set the optional value of InitialMarking dynamically
func (r netQueryInitialMarkingInt) SetIfPresent(value *[]int) netSetParam {
	if value == nil {
		return netSetParam{}
	}

	return r.Set(*value)
}

// Push the required value of InitialMarking
func (r netQueryInitialMarkingInt) Push(value []int) netSetParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netSetParam{
		data: builder.Field{
			Name: "initialMarking",
			Fields: []builder.Field{
				builder.Field{
					Name: "push",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryInitialMarkingInt) PushIfPresent(value []int) netSetParam {
	if value == nil {
		return netSetParam{}
	}
	return r.Push(value)
}

func (r netQueryInitialMarkingInt) Equals(value []int) netWithPrismaInitialMarkingEqualsParam {

	if value == nil {
		value = []int{}
	}

	return netWithPrismaInitialMarkingEqualsParam{
		data: builder.Field{
			Name: "initialMarking",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r netQueryInitialMarkingInt) EqualsIfPresent(value []int) netWithPrismaInitialMarkingEqualsParam {
	if value == nil {
		return netWithPrismaInitialMarkingEqualsParam{}
	}
	return r.Equals(value)
}

func (r netQueryInitialMarkingInt) Order(direction SortOrder) netDefaultParam {
	return netDefaultParam{
		data: builder.Field{
			Name:  "initialMarking",
			Value: direction,
		},
	}
}

func (r netQueryInitialMarkingInt) Cursor(cursor int) netCursorParam {
	return netCursorParam{
		data: builder.Field{
			Name:  "initialMarking",
			Value: cursor,
		},
	}
}

func (r netQueryInitialMarkingInt) Has(value int) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "initialMarking",
			Fields: []builder.Field{
				{
					Name: "has",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryInitialMarkingInt) HasIfPresent(value *int) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Has(*value)
}

func (r netQueryInitialMarkingInt) HasEvery(value []int) netDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "initialMarking",
			Fields: []builder.Field{
				{
					Name: "hasEvery",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryInitialMarkingInt) HasEveryIfPresent(value []int) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.HasEvery(value)
}

func (r netQueryInitialMarkingInt) HasSome(value []int) netDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "initialMarking",
			Fields: []builder.Field{
				{
					Name: "hasSome",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryInitialMarkingInt) HasSomeIfPresent(value []int) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.HasSome(value)
}

func (r netQueryInitialMarkingInt) IsEmpty(value bool) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "initialMarking",
			Fields: []builder.Field{
				{
					Name: "isEmpty",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryInitialMarkingInt) IsEmptyIfPresent(value *bool) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.IsEmpty(*value)
}

// base struct
type netQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r netQueryCreatedAtDateTime) Set(value DateTime) netSetParam {

	return netSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r netQueryCreatedAtDateTime) SetIfPresent(value *DateTime) netSetParam {
	if value == nil {
		return netSetParam{}
	}

	return r.Set(*value)
}

func (r netQueryCreatedAtDateTime) Equals(value DateTime) netWithPrismaCreatedAtEqualsParam {

	return netWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r netQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) netWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return netWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r netQueryCreatedAtDateTime) Order(direction SortOrder) netDefaultParam {
	return netDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r netQueryCreatedAtDateTime) Cursor(cursor DateTime) netCursorParam {
	return netCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r netQueryCreatedAtDateTime) In(value []DateTime) netDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryCreatedAtDateTime) InIfPresent(value []DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.In(value)
}

func (r netQueryCreatedAtDateTime) NotIn(value []DateTime) netDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.NotIn(value)
}

func (r netQueryCreatedAtDateTime) Lt(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryCreatedAtDateTime) LtIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Lt(*value)
}

func (r netQueryCreatedAtDateTime) Lte(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryCreatedAtDateTime) LteIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Lte(*value)
}

func (r netQueryCreatedAtDateTime) Gt(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryCreatedAtDateTime) GtIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Gt(*value)
}

func (r netQueryCreatedAtDateTime) Gte(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryCreatedAtDateTime) GteIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Gte(*value)
}

func (r netQueryCreatedAtDateTime) Not(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryCreatedAtDateTime) NotIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r netQueryCreatedAtDateTime) Before(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r netQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r netQueryCreatedAtDateTime) After(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r netQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r netQueryCreatedAtDateTime) BeforeEquals(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r netQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r netQueryCreatedAtDateTime) AfterEquals(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r netQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type netQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r netQueryUpdatedAtDateTime) Set(value DateTime) netSetParam {

	return netSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r netQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) netSetParam {
	if value == nil {
		return netSetParam{}
	}

	return r.Set(*value)
}

func (r netQueryUpdatedAtDateTime) Equals(value DateTime) netWithPrismaUpdatedAtEqualsParam {

	return netWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r netQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) netWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return netWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r netQueryUpdatedAtDateTime) Order(direction SortOrder) netDefaultParam {
	return netDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r netQueryUpdatedAtDateTime) Cursor(cursor DateTime) netCursorParam {
	return netCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r netQueryUpdatedAtDateTime) In(value []DateTime) netDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryUpdatedAtDateTime) InIfPresent(value []DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.In(value)
}

func (r netQueryUpdatedAtDateTime) NotIn(value []DateTime) netDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.NotIn(value)
}

func (r netQueryUpdatedAtDateTime) Lt(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Lt(*value)
}

func (r netQueryUpdatedAtDateTime) Lte(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Lte(*value)
}

func (r netQueryUpdatedAtDateTime) Gt(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Gt(*value)
}

func (r netQueryUpdatedAtDateTime) Gte(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Gte(*value)
}

func (r netQueryUpdatedAtDateTime) Not(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r netQueryUpdatedAtDateTime) Before(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r netQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r netQueryUpdatedAtDateTime) After(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r netQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r netQueryUpdatedAtDateTime) BeforeEquals(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r netQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r netQueryUpdatedAtDateTime) AfterEquals(value DateTime) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r netQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type netQueryAuthorUser struct{}

type netQueryAuthorRelations struct{}

// Net -> Author
//
// @relation
// @required
func (netQueryAuthorRelations) Where(
	params ...UserWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "author",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (netQueryAuthorRelations) Fetch() netToAuthorFindUnique {
	var v netToAuthorFindUnique

	v.query.Operation = "query"
	v.query.Method = "author"
	v.query.Outputs = userOutput

	return v
}

func (r netQueryAuthorRelations) Link(
	params UserWhereParam,
) netWithPrismaAuthorSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return netWithPrismaAuthorSetParam{}
	}

	fields = append(fields, f)

	return netWithPrismaAuthorSetParam{
		data: builder.Field{
			Name: "author",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r netQueryAuthorRelations) Unlink() netWithPrismaAuthorSetParam {
	var v netWithPrismaAuthorSetParam

	v = netWithPrismaAuthorSetParam{
		data: builder.Field{
			Name: "author",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type netQueryAuthorIDString struct{}

// Set the required value of AuthorID
func (r netQueryAuthorIDString) Set(value string) netSetParam {

	return netSetParam{
		data: builder.Field{
			Name:  "authorID",
			Value: value,
		},
	}

}

// Set the optional value of AuthorID dynamically
func (r netQueryAuthorIDString) SetIfPresent(value *string) netSetParam {
	if value == nil {
		return netSetParam{}
	}

	return r.Set(*value)
}

func (r netQueryAuthorIDString) Equals(value string) netWithPrismaAuthorIDEqualsParam {

	return netWithPrismaAuthorIDEqualsParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r netQueryAuthorIDString) EqualsIfPresent(value *string) netWithPrismaAuthorIDEqualsParam {
	if value == nil {
		return netWithPrismaAuthorIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r netQueryAuthorIDString) Order(direction SortOrder) netDefaultParam {
	return netDefaultParam{
		data: builder.Field{
			Name:  "authorID",
			Value: direction,
		},
	}
}

func (r netQueryAuthorIDString) Cursor(cursor string) netCursorParam {
	return netCursorParam{
		data: builder.Field{
			Name:  "authorID",
			Value: cursor,
		},
	}
}

func (r netQueryAuthorIDString) In(value []string) netDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryAuthorIDString) InIfPresent(value []string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.In(value)
}

func (r netQueryAuthorIDString) NotIn(value []string) netDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryAuthorIDString) NotInIfPresent(value []string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.NotIn(value)
}

func (r netQueryAuthorIDString) Lt(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryAuthorIDString) LtIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Lt(*value)
}

func (r netQueryAuthorIDString) Lte(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryAuthorIDString) LteIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Lte(*value)
}

func (r netQueryAuthorIDString) Gt(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryAuthorIDString) GtIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Gt(*value)
}

func (r netQueryAuthorIDString) Gte(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryAuthorIDString) GteIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Gte(*value)
}

func (r netQueryAuthorIDString) Contains(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryAuthorIDString) ContainsIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Contains(*value)
}

func (r netQueryAuthorIDString) StartsWith(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryAuthorIDString) StartsWithIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r netQueryAuthorIDString) EndsWith(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryAuthorIDString) EndsWithIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r netQueryAuthorIDString) Mode(value QueryMode) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryAuthorIDString) ModeIfPresent(value *QueryMode) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Mode(*value)
}

func (r netQueryAuthorIDString) Not(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryAuthorIDString) NotIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r netQueryAuthorIDString) HasPrefix(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r netQueryAuthorIDString) HasPrefixIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r netQueryAuthorIDString) HasSuffix(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r netQueryAuthorIDString) HasSuffixIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type netQueryArcsArc struct{}

type netQueryArcsRelations struct{}

// Net -> Arcs
//
// @relation
// @required
func (netQueryArcsRelations) Some(
	params ...ArcWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "arcs",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Net -> Arcs
//
// @relation
// @required
func (netQueryArcsRelations) Every(
	params ...ArcWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "arcs",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (netQueryArcsRelations) Fetch(

	params ...ArcWhereParam,

) netToArcsFindMany {
	var v netToArcsFindMany

	v.query.Operation = "query"
	v.query.Method = "arcs"
	v.query.Outputs = arcOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r netQueryArcsRelations) Link(
	params ...ArcWhereParam,
) netSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netSetParam{
		data: builder.Field{
			Name: "arcs",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r netQueryArcsRelations) Unlink(
	params ...ArcWhereParam,
) netSetParam {
	var v netSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = netSetParam{
		data: builder.Field{
			Name: "arcs",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type netQueryPlacesPlace struct{}

type netQueryPlacesRelations struct{}

// Net -> Places
//
// @relation
// @required
func (netQueryPlacesRelations) Some(
	params ...PlaceWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "places",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Net -> Places
//
// @relation
// @required
func (netQueryPlacesRelations) Every(
	params ...PlaceWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "places",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (netQueryPlacesRelations) Fetch(

	params ...PlaceWhereParam,

) netToPlacesFindMany {
	var v netToPlacesFindMany

	v.query.Operation = "query"
	v.query.Method = "places"
	v.query.Outputs = placeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r netQueryPlacesRelations) Link(
	params ...PlaceWhereParam,
) netSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netSetParam{
		data: builder.Field{
			Name: "places",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r netQueryPlacesRelations) Unlink(
	params ...PlaceWhereParam,
) netSetParam {
	var v netSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = netSetParam{
		data: builder.Field{
			Name: "places",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type netQueryTransitionsTransition struct{}

type netQueryTransitionsRelations struct{}

// Net -> Transitions
//
// @relation
// @required
func (netQueryTransitionsRelations) Some(
	params ...TransitionWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "transitions",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Net -> Transitions
//
// @relation
// @required
func (netQueryTransitionsRelations) Every(
	params ...TransitionWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "transitions",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (netQueryTransitionsRelations) Fetch(

	params ...TransitionWhereParam,

) netToTransitionsFindMany {
	var v netToTransitionsFindMany

	v.query.Operation = "query"
	v.query.Method = "transitions"
	v.query.Outputs = transitionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r netQueryTransitionsRelations) Link(
	params ...TransitionWhereParam,
) netSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netSetParam{
		data: builder.Field{
			Name: "transitions",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r netQueryTransitionsRelations) Unlink(
	params ...TransitionWhereParam,
) netSetParam {
	var v netSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = netSetParam{
		data: builder.Field{
			Name: "transitions",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type netQueryParentNet struct{}

type netQueryParentRelations struct{}

// Net -> Parent
//
// @relation
// @optional
func (netQueryParentRelations) Where(
	params ...NetWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "parent",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (netQueryParentRelations) Fetch() netToParentFindUnique {
	var v netToParentFindUnique

	v.query.Operation = "query"
	v.query.Method = "parent"
	v.query.Outputs = netOutput

	return v
}

func (r netQueryParentRelations) Link(
	params NetWhereParam,
) netSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return netSetParam{}
	}

	fields = append(fields, f)

	return netSetParam{
		data: builder.Field{
			Name: "parent",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r netQueryParentRelations) Unlink() netSetParam {
	var v netSetParam

	v = netSetParam{
		data: builder.Field{
			Name: "parent",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type netQueryParentIDString struct{}

// Set the optional value of ParentID
func (r netQueryParentIDString) Set(value string) netSetParam {

	return netSetParam{
		data: builder.Field{
			Name:  "parentID",
			Value: value,
		},
	}

}

// Set the optional value of ParentID dynamically
func (r netQueryParentIDString) SetIfPresent(value *string) netSetParam {
	if value == nil {
		return netSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of ParentID dynamically
func (r netQueryParentIDString) SetOptional(value *string) netSetParam {
	if value == nil {

		var v *string
		return netSetParam{
			data: builder.Field{
				Name:  "parentID",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r netQueryParentIDString) Equals(value string) netWithPrismaParentIDEqualsParam {

	return netWithPrismaParentIDEqualsParam{
		data: builder.Field{
			Name: "parentID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r netQueryParentIDString) EqualsIfPresent(value *string) netWithPrismaParentIDEqualsParam {
	if value == nil {
		return netWithPrismaParentIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r netQueryParentIDString) EqualsOptional(value *string) netDefaultParam {
	return netDefaultParam{
		data: builder.Field{
			Name: "parentID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r netQueryParentIDString) IsNull() netDefaultParam {
	var str *string = nil
	return netDefaultParam{
		data: builder.Field{
			Name: "parentID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r netQueryParentIDString) Order(direction SortOrder) netDefaultParam {
	return netDefaultParam{
		data: builder.Field{
			Name:  "parentID",
			Value: direction,
		},
	}
}

func (r netQueryParentIDString) Cursor(cursor string) netCursorParam {
	return netCursorParam{
		data: builder.Field{
			Name:  "parentID",
			Value: cursor,
		},
	}
}

func (r netQueryParentIDString) In(value []string) netDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "parentID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryParentIDString) InIfPresent(value []string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.In(value)
}

func (r netQueryParentIDString) NotIn(value []string) netDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "parentID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r netQueryParentIDString) NotInIfPresent(value []string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.NotIn(value)
}

func (r netQueryParentIDString) Lt(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "parentID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryParentIDString) LtIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Lt(*value)
}

func (r netQueryParentIDString) Lte(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "parentID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryParentIDString) LteIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Lte(*value)
}

func (r netQueryParentIDString) Gt(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "parentID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryParentIDString) GtIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Gt(*value)
}

func (r netQueryParentIDString) Gte(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "parentID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryParentIDString) GteIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Gte(*value)
}

func (r netQueryParentIDString) Contains(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "parentID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryParentIDString) ContainsIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Contains(*value)
}

func (r netQueryParentIDString) StartsWith(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "parentID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryParentIDString) StartsWithIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r netQueryParentIDString) EndsWith(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "parentID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryParentIDString) EndsWithIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r netQueryParentIDString) Mode(value QueryMode) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "parentID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryParentIDString) ModeIfPresent(value *QueryMode) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Mode(*value)
}

func (r netQueryParentIDString) Not(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "parentID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r netQueryParentIDString) NotIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r netQueryParentIDString) HasPrefix(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "parentID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r netQueryParentIDString) HasPrefixIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r netQueryParentIDString) HasSuffix(value string) netDefaultParam {

	return netDefaultParam{
		data: builder.Field{
			Name: "parentID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r netQueryParentIDString) HasSuffixIfPresent(value *string) netDefaultParam {
	if value == nil {
		return netDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type netQueryChildrenNet struct{}

type netQueryChildrenRelations struct{}

// Net -> Children
//
// @relation
// @required
func (netQueryChildrenRelations) Some(
	params ...NetWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "children",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Net -> Children
//
// @relation
// @required
func (netQueryChildrenRelations) Every(
	params ...NetWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "children",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (netQueryChildrenRelations) Fetch(

	params ...NetWhereParam,

) netToChildrenFindMany {
	var v netToChildrenFindMany

	v.query.Operation = "query"
	v.query.Method = "children"
	v.query.Outputs = netOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r netQueryChildrenRelations) Link(
	params ...NetWhereParam,
) netSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netSetParam{
		data: builder.Field{
			Name: "children",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r netQueryChildrenRelations) Unlink(
	params ...NetWhereParam,
) netSetParam {
	var v netSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = netSetParam{
		data: builder.Field{
			Name: "children",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type netQueryDevicesDevicesOnNets struct{}

type netQueryDevicesRelations struct{}

// Net -> Devices
//
// @relation
// @required
func (netQueryDevicesRelations) Some(
	params ...DevicesOnNetsWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "devices",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Net -> Devices
//
// @relation
// @required
func (netQueryDevicesRelations) Every(
	params ...DevicesOnNetsWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "devices",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (netQueryDevicesRelations) Fetch(

	params ...DevicesOnNetsWhereParam,

) netToDevicesFindMany {
	var v netToDevicesFindMany

	v.query.Operation = "query"
	v.query.Method = "devices"
	v.query.Outputs = devicesOnNetsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r netQueryDevicesRelations) Link(
	params ...DevicesOnNetsWhereParam,
) netSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netSetParam{
		data: builder.Field{
			Name: "devices",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r netQueryDevicesRelations) Unlink(
	params ...DevicesOnNetsWhereParam,
) netSetParam {
	var v netSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = netSetParam{
		data: builder.Field{
			Name: "devices",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type netQueryPlaceInterfacesPlaceInterface struct{}

type netQueryPlaceInterfacesRelations struct{}

// Net -> PlaceInterfaces
//
// @relation
// @required
func (netQueryPlaceInterfacesRelations) Some(
	params ...PlaceInterfaceWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "placeInterfaces",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Net -> PlaceInterfaces
//
// @relation
// @required
func (netQueryPlaceInterfacesRelations) Every(
	params ...PlaceInterfaceWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "placeInterfaces",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (netQueryPlaceInterfacesRelations) Fetch(

	params ...PlaceInterfaceWhereParam,

) netToPlaceInterfacesFindMany {
	var v netToPlaceInterfacesFindMany

	v.query.Operation = "query"
	v.query.Method = "placeInterfaces"
	v.query.Outputs = placeInterfaceOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r netQueryPlaceInterfacesRelations) Link(
	params ...PlaceInterfaceWhereParam,
) netSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netSetParam{
		data: builder.Field{
			Name: "placeInterfaces",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r netQueryPlaceInterfacesRelations) Unlink(
	params ...PlaceInterfaceWhereParam,
) netSetParam {
	var v netSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = netSetParam{
		data: builder.Field{
			Name: "placeInterfaces",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type netQueryTransitionInterfacesTransitionInterface struct{}

type netQueryTransitionInterfacesRelations struct{}

// Net -> TransitionInterfaces
//
// @relation
// @required
func (netQueryTransitionInterfacesRelations) Some(
	params ...TransitionInterfaceWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaces",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Net -> TransitionInterfaces
//
// @relation
// @required
func (netQueryTransitionInterfacesRelations) Every(
	params ...TransitionInterfaceWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaces",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (netQueryTransitionInterfacesRelations) Fetch(

	params ...TransitionInterfaceWhereParam,

) netToTransitionInterfacesFindMany {
	var v netToTransitionInterfacesFindMany

	v.query.Operation = "query"
	v.query.Method = "transitionInterfaces"
	v.query.Outputs = transitionInterfaceOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r netQueryTransitionInterfacesRelations) Link(
	params ...TransitionInterfaceWhereParam,
) netSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netSetParam{
		data: builder.Field{
			Name: "transitionInterfaces",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r netQueryTransitionInterfacesRelations) Unlink(
	params ...TransitionInterfaceWhereParam,
) netSetParam {
	var v netSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = netSetParam{
		data: builder.Field{
			Name: "transitionInterfaces",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type netQueryRunsRun struct{}

type netQueryRunsRelations struct{}

// Net -> Runs
//
// @relation
// @required
func (netQueryRunsRelations) Some(
	params ...RunWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "runs",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Net -> Runs
//
// @relation
// @required
func (netQueryRunsRelations) Every(
	params ...RunWhereParam,
) netDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netDefaultParam{
		data: builder.Field{
			Name: "runs",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (netQueryRunsRelations) Fetch(

	params ...RunWhereParam,

) netToRunsFindMany {
	var v netToRunsFindMany

	v.query.Operation = "query"
	v.query.Method = "runs"
	v.query.Outputs = runOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r netQueryRunsRelations) Link(
	params ...RunWhereParam,
) netSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return netSetParam{
		data: builder.Field{
			Name: "runs",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r netQueryRunsRelations) Unlink(
	params ...RunWhereParam,
) netSetParam {
	var v netSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = netSetParam{
		data: builder.Field{
			Name: "runs",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// PlaceInterface acts as a namespaces to access query methods for the PlaceInterface model
var PlaceInterface = placeInterfaceQuery{}

// placeInterfaceQuery exposes query functions for the placeInterface model
type placeInterfaceQuery struct {

	// ID
	//
	// @required
	ID placeInterfaceQueryIDString

	// Name
	//
	// @required
	Name placeInterfaceQueryNameString

	Net placeInterfaceQueryNetRelations

	// Bound
	//
	// @required
	Bound placeInterfaceQueryBoundInt

	// NetID
	//
	// @required
	NetID placeInterfaceQueryNetIDString

	Places placeInterfaceQueryPlacesRelations

	// CreatedAt
	//
	// @required
	CreatedAt placeInterfaceQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt placeInterfaceQueryUpdatedAtDateTime
}

func (placeInterfaceQuery) Not(params ...PlaceInterfaceWhereParam) placeInterfaceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (placeInterfaceQuery) Or(params ...PlaceInterfaceWhereParam) placeInterfaceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (placeInterfaceQuery) And(params ...PlaceInterfaceWhereParam) placeInterfaceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type placeInterfaceQueryIDString struct{}

// Set the required value of ID
func (r placeInterfaceQueryIDString) Set(value string) placeInterfaceSetParam {

	return placeInterfaceSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r placeInterfaceQueryIDString) SetIfPresent(value *string) placeInterfaceSetParam {
	if value == nil {
		return placeInterfaceSetParam{}
	}

	return r.Set(*value)
}

func (r placeInterfaceQueryIDString) Equals(value string) placeInterfaceWithPrismaIDEqualsUniqueParam {

	return placeInterfaceWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryIDString) EqualsIfPresent(value *string) placeInterfaceWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return placeInterfaceWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r placeInterfaceQueryIDString) Order(direction SortOrder) placeInterfaceDefaultParam {
	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r placeInterfaceQueryIDString) Cursor(cursor string) placeInterfaceCursorParam {
	return placeInterfaceCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r placeInterfaceQueryIDString) In(value []string) placeInterfaceParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeInterfaceQueryIDString) InIfPresent(value []string) placeInterfaceParamUnique {
	if value == nil {
		return placeInterfaceParamUnique{}
	}
	return r.In(value)
}

func (r placeInterfaceQueryIDString) NotIn(value []string) placeInterfaceParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeInterfaceQueryIDString) NotInIfPresent(value []string) placeInterfaceParamUnique {
	if value == nil {
		return placeInterfaceParamUnique{}
	}
	return r.NotIn(value)
}

func (r placeInterfaceQueryIDString) Lt(value string) placeInterfaceParamUnique {

	return placeInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryIDString) LtIfPresent(value *string) placeInterfaceParamUnique {
	if value == nil {
		return placeInterfaceParamUnique{}
	}
	return r.Lt(*value)
}

func (r placeInterfaceQueryIDString) Lte(value string) placeInterfaceParamUnique {

	return placeInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryIDString) LteIfPresent(value *string) placeInterfaceParamUnique {
	if value == nil {
		return placeInterfaceParamUnique{}
	}
	return r.Lte(*value)
}

func (r placeInterfaceQueryIDString) Gt(value string) placeInterfaceParamUnique {

	return placeInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryIDString) GtIfPresent(value *string) placeInterfaceParamUnique {
	if value == nil {
		return placeInterfaceParamUnique{}
	}
	return r.Gt(*value)
}

func (r placeInterfaceQueryIDString) Gte(value string) placeInterfaceParamUnique {

	return placeInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryIDString) GteIfPresent(value *string) placeInterfaceParamUnique {
	if value == nil {
		return placeInterfaceParamUnique{}
	}
	return r.Gte(*value)
}

func (r placeInterfaceQueryIDString) Contains(value string) placeInterfaceParamUnique {

	return placeInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryIDString) ContainsIfPresent(value *string) placeInterfaceParamUnique {
	if value == nil {
		return placeInterfaceParamUnique{}
	}
	return r.Contains(*value)
}

func (r placeInterfaceQueryIDString) StartsWith(value string) placeInterfaceParamUnique {

	return placeInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryIDString) StartsWithIfPresent(value *string) placeInterfaceParamUnique {
	if value == nil {
		return placeInterfaceParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r placeInterfaceQueryIDString) EndsWith(value string) placeInterfaceParamUnique {

	return placeInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryIDString) EndsWithIfPresent(value *string) placeInterfaceParamUnique {
	if value == nil {
		return placeInterfaceParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r placeInterfaceQueryIDString) Mode(value QueryMode) placeInterfaceParamUnique {

	return placeInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryIDString) ModeIfPresent(value *QueryMode) placeInterfaceParamUnique {
	if value == nil {
		return placeInterfaceParamUnique{}
	}
	return r.Mode(*value)
}

func (r placeInterfaceQueryIDString) Not(value string) placeInterfaceParamUnique {

	return placeInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryIDString) NotIfPresent(value *string) placeInterfaceParamUnique {
	if value == nil {
		return placeInterfaceParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r placeInterfaceQueryIDString) HasPrefix(value string) placeInterfaceParamUnique {

	return placeInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r placeInterfaceQueryIDString) HasPrefixIfPresent(value *string) placeInterfaceParamUnique {
	if value == nil {
		return placeInterfaceParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r placeInterfaceQueryIDString) HasSuffix(value string) placeInterfaceParamUnique {

	return placeInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r placeInterfaceQueryIDString) HasSuffixIfPresent(value *string) placeInterfaceParamUnique {
	if value == nil {
		return placeInterfaceParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type placeInterfaceQueryNameString struct{}

// Set the required value of Name
func (r placeInterfaceQueryNameString) Set(value string) placeInterfaceWithPrismaNameSetParam {

	return placeInterfaceWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r placeInterfaceQueryNameString) SetIfPresent(value *string) placeInterfaceWithPrismaNameSetParam {
	if value == nil {
		return placeInterfaceWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r placeInterfaceQueryNameString) Equals(value string) placeInterfaceWithPrismaNameEqualsParam {

	return placeInterfaceWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNameString) EqualsIfPresent(value *string) placeInterfaceWithPrismaNameEqualsParam {
	if value == nil {
		return placeInterfaceWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r placeInterfaceQueryNameString) Order(direction SortOrder) placeInterfaceDefaultParam {
	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r placeInterfaceQueryNameString) Cursor(cursor string) placeInterfaceCursorParam {
	return placeInterfaceCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r placeInterfaceQueryNameString) In(value []string) placeInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNameString) InIfPresent(value []string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.In(value)
}

func (r placeInterfaceQueryNameString) NotIn(value []string) placeInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNameString) NotInIfPresent(value []string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r placeInterfaceQueryNameString) Lt(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNameString) LtIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r placeInterfaceQueryNameString) Lte(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNameString) LteIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r placeInterfaceQueryNameString) Gt(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNameString) GtIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r placeInterfaceQueryNameString) Gte(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNameString) GteIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r placeInterfaceQueryNameString) Contains(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNameString) ContainsIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Contains(*value)
}

func (r placeInterfaceQueryNameString) StartsWith(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNameString) StartsWithIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r placeInterfaceQueryNameString) EndsWith(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNameString) EndsWithIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r placeInterfaceQueryNameString) Mode(value QueryMode) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNameString) ModeIfPresent(value *QueryMode) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Mode(*value)
}

func (r placeInterfaceQueryNameString) Not(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNameString) NotIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r placeInterfaceQueryNameString) HasPrefix(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r placeInterfaceQueryNameString) HasPrefixIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r placeInterfaceQueryNameString) HasSuffix(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r placeInterfaceQueryNameString) HasSuffixIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type placeInterfaceQueryNetNet struct{}

type placeInterfaceQueryNetRelations struct{}

// PlaceInterface -> Net
//
// @relation
// @required
func (placeInterfaceQueryNetRelations) Where(
	params ...NetWhereParam,
) placeInterfaceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "net",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (placeInterfaceQueryNetRelations) Fetch() placeInterfaceToNetFindUnique {
	var v placeInterfaceToNetFindUnique

	v.query.Operation = "query"
	v.query.Method = "net"
	v.query.Outputs = netOutput

	return v
}

func (r placeInterfaceQueryNetRelations) Link(
	params NetWhereParam,
) placeInterfaceWithPrismaNetSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return placeInterfaceWithPrismaNetSetParam{}
	}

	fields = append(fields, f)

	return placeInterfaceWithPrismaNetSetParam{
		data: builder.Field{
			Name: "net",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r placeInterfaceQueryNetRelations) Unlink() placeInterfaceWithPrismaNetSetParam {
	var v placeInterfaceWithPrismaNetSetParam

	v = placeInterfaceWithPrismaNetSetParam{
		data: builder.Field{
			Name: "net",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type placeInterfaceQueryBoundInt struct{}

// Set the required value of Bound
func (r placeInterfaceQueryBoundInt) Set(value int) placeInterfaceWithPrismaBoundSetParam {

	return placeInterfaceWithPrismaBoundSetParam{
		data: builder.Field{
			Name:  "bound",
			Value: value,
		},
	}

}

// Set the optional value of Bound dynamically
func (r placeInterfaceQueryBoundInt) SetIfPresent(value *int) placeInterfaceWithPrismaBoundSetParam {
	if value == nil {
		return placeInterfaceWithPrismaBoundSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Bound
func (r placeInterfaceQueryBoundInt) Increment(value int) placeInterfaceWithPrismaBoundSetParam {

	return placeInterfaceWithPrismaBoundSetParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				builder.Field{
					Name: "increment",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryBoundInt) IncrementIfPresent(value *int) placeInterfaceWithPrismaBoundSetParam {
	if value == nil {
		return placeInterfaceWithPrismaBoundSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Bound
func (r placeInterfaceQueryBoundInt) Decrement(value int) placeInterfaceWithPrismaBoundSetParam {

	return placeInterfaceWithPrismaBoundSetParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				builder.Field{
					Name: "decrement",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryBoundInt) DecrementIfPresent(value *int) placeInterfaceWithPrismaBoundSetParam {
	if value == nil {
		return placeInterfaceWithPrismaBoundSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Bound
func (r placeInterfaceQueryBoundInt) Multiply(value int) placeInterfaceWithPrismaBoundSetParam {

	return placeInterfaceWithPrismaBoundSetParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				builder.Field{
					Name: "multiply",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryBoundInt) MultiplyIfPresent(value *int) placeInterfaceWithPrismaBoundSetParam {
	if value == nil {
		return placeInterfaceWithPrismaBoundSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Bound
func (r placeInterfaceQueryBoundInt) Divide(value int) placeInterfaceWithPrismaBoundSetParam {

	return placeInterfaceWithPrismaBoundSetParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				builder.Field{
					Name: "divide",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryBoundInt) DivideIfPresent(value *int) placeInterfaceWithPrismaBoundSetParam {
	if value == nil {
		return placeInterfaceWithPrismaBoundSetParam{}
	}
	return r.Divide(*value)
}

func (r placeInterfaceQueryBoundInt) Equals(value int) placeInterfaceWithPrismaBoundEqualsParam {

	return placeInterfaceWithPrismaBoundEqualsParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryBoundInt) EqualsIfPresent(value *int) placeInterfaceWithPrismaBoundEqualsParam {
	if value == nil {
		return placeInterfaceWithPrismaBoundEqualsParam{}
	}
	return r.Equals(*value)
}

func (r placeInterfaceQueryBoundInt) Order(direction SortOrder) placeInterfaceDefaultParam {
	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name:  "bound",
			Value: direction,
		},
	}
}

func (r placeInterfaceQueryBoundInt) Cursor(cursor int) placeInterfaceCursorParam {
	return placeInterfaceCursorParam{
		data: builder.Field{
			Name:  "bound",
			Value: cursor,
		},
	}
}

func (r placeInterfaceQueryBoundInt) In(value []int) placeInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeInterfaceQueryBoundInt) InIfPresent(value []int) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.In(value)
}

func (r placeInterfaceQueryBoundInt) NotIn(value []int) placeInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeInterfaceQueryBoundInt) NotInIfPresent(value []int) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r placeInterfaceQueryBoundInt) Lt(value int) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryBoundInt) LtIfPresent(value *int) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r placeInterfaceQueryBoundInt) Lte(value int) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryBoundInt) LteIfPresent(value *int) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r placeInterfaceQueryBoundInt) Gt(value int) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryBoundInt) GtIfPresent(value *int) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r placeInterfaceQueryBoundInt) Gte(value int) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryBoundInt) GteIfPresent(value *int) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r placeInterfaceQueryBoundInt) Not(value int) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryBoundInt) NotIfPresent(value *int) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r placeInterfaceQueryBoundInt) LT(value int) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r placeInterfaceQueryBoundInt) LTIfPresent(value *int) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r placeInterfaceQueryBoundInt) LTE(value int) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r placeInterfaceQueryBoundInt) LTEIfPresent(value *int) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r placeInterfaceQueryBoundInt) GT(value int) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r placeInterfaceQueryBoundInt) GTIfPresent(value *int) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r placeInterfaceQueryBoundInt) GTE(value int) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r placeInterfaceQueryBoundInt) GTEIfPresent(value *int) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.GTE(*value)
}

// base struct
type placeInterfaceQueryNetIDString struct{}

// Set the required value of NetID
func (r placeInterfaceQueryNetIDString) Set(value string) placeInterfaceSetParam {

	return placeInterfaceSetParam{
		data: builder.Field{
			Name:  "netID",
			Value: value,
		},
	}

}

// Set the optional value of NetID dynamically
func (r placeInterfaceQueryNetIDString) SetIfPresent(value *string) placeInterfaceSetParam {
	if value == nil {
		return placeInterfaceSetParam{}
	}

	return r.Set(*value)
}

func (r placeInterfaceQueryNetIDString) Equals(value string) placeInterfaceWithPrismaNetIDEqualsParam {

	return placeInterfaceWithPrismaNetIDEqualsParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNetIDString) EqualsIfPresent(value *string) placeInterfaceWithPrismaNetIDEqualsParam {
	if value == nil {
		return placeInterfaceWithPrismaNetIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r placeInterfaceQueryNetIDString) Order(direction SortOrder) placeInterfaceDefaultParam {
	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name:  "netID",
			Value: direction,
		},
	}
}

func (r placeInterfaceQueryNetIDString) Cursor(cursor string) placeInterfaceCursorParam {
	return placeInterfaceCursorParam{
		data: builder.Field{
			Name:  "netID",
			Value: cursor,
		},
	}
}

func (r placeInterfaceQueryNetIDString) In(value []string) placeInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNetIDString) InIfPresent(value []string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.In(value)
}

func (r placeInterfaceQueryNetIDString) NotIn(value []string) placeInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNetIDString) NotInIfPresent(value []string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r placeInterfaceQueryNetIDString) Lt(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNetIDString) LtIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r placeInterfaceQueryNetIDString) Lte(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNetIDString) LteIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r placeInterfaceQueryNetIDString) Gt(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNetIDString) GtIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r placeInterfaceQueryNetIDString) Gte(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNetIDString) GteIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r placeInterfaceQueryNetIDString) Contains(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNetIDString) ContainsIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Contains(*value)
}

func (r placeInterfaceQueryNetIDString) StartsWith(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNetIDString) StartsWithIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r placeInterfaceQueryNetIDString) EndsWith(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNetIDString) EndsWithIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r placeInterfaceQueryNetIDString) Mode(value QueryMode) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNetIDString) ModeIfPresent(value *QueryMode) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Mode(*value)
}

func (r placeInterfaceQueryNetIDString) Not(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryNetIDString) NotIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r placeInterfaceQueryNetIDString) HasPrefix(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r placeInterfaceQueryNetIDString) HasPrefixIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r placeInterfaceQueryNetIDString) HasSuffix(value string) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r placeInterfaceQueryNetIDString) HasSuffixIfPresent(value *string) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type placeInterfaceQueryPlacesPlace struct{}

type placeInterfaceQueryPlacesRelations struct{}

// PlaceInterface -> Places
//
// @relation
// @required
func (placeInterfaceQueryPlacesRelations) Some(
	params ...PlaceWhereParam,
) placeInterfaceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "places",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// PlaceInterface -> Places
//
// @relation
// @required
func (placeInterfaceQueryPlacesRelations) Every(
	params ...PlaceWhereParam,
) placeInterfaceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "places",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (placeInterfaceQueryPlacesRelations) Fetch(

	params ...PlaceWhereParam,

) placeInterfaceToPlacesFindMany {
	var v placeInterfaceToPlacesFindMany

	v.query.Operation = "query"
	v.query.Method = "places"
	v.query.Outputs = placeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r placeInterfaceQueryPlacesRelations) Link(
	params ...PlaceWhereParam,
) placeInterfaceSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeInterfaceSetParam{
		data: builder.Field{
			Name: "places",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r placeInterfaceQueryPlacesRelations) Unlink(
	params ...PlaceWhereParam,
) placeInterfaceSetParam {
	var v placeInterfaceSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = placeInterfaceSetParam{
		data: builder.Field{
			Name: "places",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type placeInterfaceQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r placeInterfaceQueryCreatedAtDateTime) Set(value DateTime) placeInterfaceSetParam {

	return placeInterfaceSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r placeInterfaceQueryCreatedAtDateTime) SetIfPresent(value *DateTime) placeInterfaceSetParam {
	if value == nil {
		return placeInterfaceSetParam{}
	}

	return r.Set(*value)
}

func (r placeInterfaceQueryCreatedAtDateTime) Equals(value DateTime) placeInterfaceWithPrismaCreatedAtEqualsParam {

	return placeInterfaceWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) placeInterfaceWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return placeInterfaceWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r placeInterfaceQueryCreatedAtDateTime) Order(direction SortOrder) placeInterfaceDefaultParam {
	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r placeInterfaceQueryCreatedAtDateTime) Cursor(cursor DateTime) placeInterfaceCursorParam {
	return placeInterfaceCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r placeInterfaceQueryCreatedAtDateTime) In(value []DateTime) placeInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeInterfaceQueryCreatedAtDateTime) InIfPresent(value []DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.In(value)
}

func (r placeInterfaceQueryCreatedAtDateTime) NotIn(value []DateTime) placeInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeInterfaceQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r placeInterfaceQueryCreatedAtDateTime) Lt(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryCreatedAtDateTime) LtIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r placeInterfaceQueryCreatedAtDateTime) Lte(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryCreatedAtDateTime) LteIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r placeInterfaceQueryCreatedAtDateTime) Gt(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryCreatedAtDateTime) GtIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r placeInterfaceQueryCreatedAtDateTime) Gte(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryCreatedAtDateTime) GteIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r placeInterfaceQueryCreatedAtDateTime) Not(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryCreatedAtDateTime) NotIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r placeInterfaceQueryCreatedAtDateTime) Before(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r placeInterfaceQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r placeInterfaceQueryCreatedAtDateTime) After(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r placeInterfaceQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r placeInterfaceQueryCreatedAtDateTime) BeforeEquals(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r placeInterfaceQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r placeInterfaceQueryCreatedAtDateTime) AfterEquals(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r placeInterfaceQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type placeInterfaceQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r placeInterfaceQueryUpdatedAtDateTime) Set(value DateTime) placeInterfaceSetParam {

	return placeInterfaceSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r placeInterfaceQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) placeInterfaceSetParam {
	if value == nil {
		return placeInterfaceSetParam{}
	}

	return r.Set(*value)
}

func (r placeInterfaceQueryUpdatedAtDateTime) Equals(value DateTime) placeInterfaceWithPrismaUpdatedAtEqualsParam {

	return placeInterfaceWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) placeInterfaceWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return placeInterfaceWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r placeInterfaceQueryUpdatedAtDateTime) Order(direction SortOrder) placeInterfaceDefaultParam {
	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r placeInterfaceQueryUpdatedAtDateTime) Cursor(cursor DateTime) placeInterfaceCursorParam {
	return placeInterfaceCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r placeInterfaceQueryUpdatedAtDateTime) In(value []DateTime) placeInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeInterfaceQueryUpdatedAtDateTime) InIfPresent(value []DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.In(value)
}

func (r placeInterfaceQueryUpdatedAtDateTime) NotIn(value []DateTime) placeInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeInterfaceQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r placeInterfaceQueryUpdatedAtDateTime) Lt(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r placeInterfaceQueryUpdatedAtDateTime) Lte(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r placeInterfaceQueryUpdatedAtDateTime) Gt(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r placeInterfaceQueryUpdatedAtDateTime) Gte(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r placeInterfaceQueryUpdatedAtDateTime) Not(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r placeInterfaceQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r placeInterfaceQueryUpdatedAtDateTime) Before(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r placeInterfaceQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r placeInterfaceQueryUpdatedAtDateTime) After(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r placeInterfaceQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r placeInterfaceQueryUpdatedAtDateTime) BeforeEquals(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r placeInterfaceQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r placeInterfaceQueryUpdatedAtDateTime) AfterEquals(value DateTime) placeInterfaceDefaultParam {

	return placeInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r placeInterfaceQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) placeInterfaceDefaultParam {
	if value == nil {
		return placeInterfaceDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// TransitionInterface acts as a namespaces to access query methods for the TransitionInterface model
var TransitionInterface = transitionInterfaceQuery{}

// transitionInterfaceQuery exposes query functions for the transitionInterface model
type transitionInterfaceQuery struct {

	// ID
	//
	// @required
	ID transitionInterfaceQueryIDString

	// Name
	//
	// @required
	Name transitionInterfaceQueryNameString

	Net transitionInterfaceQueryNetRelations

	Events transitionInterfaceQueryEventsRelations

	// NetID
	//
	// @required
	NetID transitionInterfaceQueryNetIDString

	Transitions transitionInterfaceQueryTransitionsRelations

	// CreatedAt
	//
	// @required
	CreatedAt transitionInterfaceQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt transitionInterfaceQueryUpdatedAtDateTime
}

func (transitionInterfaceQuery) Not(params ...TransitionInterfaceWhereParam) transitionInterfaceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (transitionInterfaceQuery) Or(params ...TransitionInterfaceWhereParam) transitionInterfaceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (transitionInterfaceQuery) And(params ...TransitionInterfaceWhereParam) transitionInterfaceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type transitionInterfaceQueryIDString struct{}

// Set the required value of ID
func (r transitionInterfaceQueryIDString) Set(value string) transitionInterfaceSetParam {

	return transitionInterfaceSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r transitionInterfaceQueryIDString) SetIfPresent(value *string) transitionInterfaceSetParam {
	if value == nil {
		return transitionInterfaceSetParam{}
	}

	return r.Set(*value)
}

func (r transitionInterfaceQueryIDString) Equals(value string) transitionInterfaceWithPrismaIDEqualsUniqueParam {

	return transitionInterfaceWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryIDString) EqualsIfPresent(value *string) transitionInterfaceWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return transitionInterfaceWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r transitionInterfaceQueryIDString) Order(direction SortOrder) transitionInterfaceDefaultParam {
	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r transitionInterfaceQueryIDString) Cursor(cursor string) transitionInterfaceCursorParam {
	return transitionInterfaceCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r transitionInterfaceQueryIDString) In(value []string) transitionInterfaceParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryIDString) InIfPresent(value []string) transitionInterfaceParamUnique {
	if value == nil {
		return transitionInterfaceParamUnique{}
	}
	return r.In(value)
}

func (r transitionInterfaceQueryIDString) NotIn(value []string) transitionInterfaceParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryIDString) NotInIfPresent(value []string) transitionInterfaceParamUnique {
	if value == nil {
		return transitionInterfaceParamUnique{}
	}
	return r.NotIn(value)
}

func (r transitionInterfaceQueryIDString) Lt(value string) transitionInterfaceParamUnique {

	return transitionInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryIDString) LtIfPresent(value *string) transitionInterfaceParamUnique {
	if value == nil {
		return transitionInterfaceParamUnique{}
	}
	return r.Lt(*value)
}

func (r transitionInterfaceQueryIDString) Lte(value string) transitionInterfaceParamUnique {

	return transitionInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryIDString) LteIfPresent(value *string) transitionInterfaceParamUnique {
	if value == nil {
		return transitionInterfaceParamUnique{}
	}
	return r.Lte(*value)
}

func (r transitionInterfaceQueryIDString) Gt(value string) transitionInterfaceParamUnique {

	return transitionInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryIDString) GtIfPresent(value *string) transitionInterfaceParamUnique {
	if value == nil {
		return transitionInterfaceParamUnique{}
	}
	return r.Gt(*value)
}

func (r transitionInterfaceQueryIDString) Gte(value string) transitionInterfaceParamUnique {

	return transitionInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryIDString) GteIfPresent(value *string) transitionInterfaceParamUnique {
	if value == nil {
		return transitionInterfaceParamUnique{}
	}
	return r.Gte(*value)
}

func (r transitionInterfaceQueryIDString) Contains(value string) transitionInterfaceParamUnique {

	return transitionInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryIDString) ContainsIfPresent(value *string) transitionInterfaceParamUnique {
	if value == nil {
		return transitionInterfaceParamUnique{}
	}
	return r.Contains(*value)
}

func (r transitionInterfaceQueryIDString) StartsWith(value string) transitionInterfaceParamUnique {

	return transitionInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryIDString) StartsWithIfPresent(value *string) transitionInterfaceParamUnique {
	if value == nil {
		return transitionInterfaceParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r transitionInterfaceQueryIDString) EndsWith(value string) transitionInterfaceParamUnique {

	return transitionInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryIDString) EndsWithIfPresent(value *string) transitionInterfaceParamUnique {
	if value == nil {
		return transitionInterfaceParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r transitionInterfaceQueryIDString) Mode(value QueryMode) transitionInterfaceParamUnique {

	return transitionInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryIDString) ModeIfPresent(value *QueryMode) transitionInterfaceParamUnique {
	if value == nil {
		return transitionInterfaceParamUnique{}
	}
	return r.Mode(*value)
}

func (r transitionInterfaceQueryIDString) Not(value string) transitionInterfaceParamUnique {

	return transitionInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryIDString) NotIfPresent(value *string) transitionInterfaceParamUnique {
	if value == nil {
		return transitionInterfaceParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r transitionInterfaceQueryIDString) HasPrefix(value string) transitionInterfaceParamUnique {

	return transitionInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r transitionInterfaceQueryIDString) HasPrefixIfPresent(value *string) transitionInterfaceParamUnique {
	if value == nil {
		return transitionInterfaceParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r transitionInterfaceQueryIDString) HasSuffix(value string) transitionInterfaceParamUnique {

	return transitionInterfaceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r transitionInterfaceQueryIDString) HasSuffixIfPresent(value *string) transitionInterfaceParamUnique {
	if value == nil {
		return transitionInterfaceParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type transitionInterfaceQueryNameString struct{}

// Set the required value of Name
func (r transitionInterfaceQueryNameString) Set(value string) transitionInterfaceWithPrismaNameSetParam {

	return transitionInterfaceWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r transitionInterfaceQueryNameString) SetIfPresent(value *string) transitionInterfaceWithPrismaNameSetParam {
	if value == nil {
		return transitionInterfaceWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r transitionInterfaceQueryNameString) Equals(value string) transitionInterfaceWithPrismaNameEqualsParam {

	return transitionInterfaceWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNameString) EqualsIfPresent(value *string) transitionInterfaceWithPrismaNameEqualsParam {
	if value == nil {
		return transitionInterfaceWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transitionInterfaceQueryNameString) Order(direction SortOrder) transitionInterfaceDefaultParam {
	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r transitionInterfaceQueryNameString) Cursor(cursor string) transitionInterfaceCursorParam {
	return transitionInterfaceCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r transitionInterfaceQueryNameString) In(value []string) transitionInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNameString) InIfPresent(value []string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.In(value)
}

func (r transitionInterfaceQueryNameString) NotIn(value []string) transitionInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNameString) NotInIfPresent(value []string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transitionInterfaceQueryNameString) Lt(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNameString) LtIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transitionInterfaceQueryNameString) Lte(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNameString) LteIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transitionInterfaceQueryNameString) Gt(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNameString) GtIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transitionInterfaceQueryNameString) Gte(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNameString) GteIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transitionInterfaceQueryNameString) Contains(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNameString) ContainsIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Contains(*value)
}

func (r transitionInterfaceQueryNameString) StartsWith(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNameString) StartsWithIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r transitionInterfaceQueryNameString) EndsWith(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNameString) EndsWithIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r transitionInterfaceQueryNameString) Mode(value QueryMode) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNameString) ModeIfPresent(value *QueryMode) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Mode(*value)
}

func (r transitionInterfaceQueryNameString) Not(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNameString) NotIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r transitionInterfaceQueryNameString) HasPrefix(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r transitionInterfaceQueryNameString) HasPrefixIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r transitionInterfaceQueryNameString) HasSuffix(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r transitionInterfaceQueryNameString) HasSuffixIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type transitionInterfaceQueryNetNet struct{}

type transitionInterfaceQueryNetRelations struct{}

// TransitionInterface -> Net
//
// @relation
// @required
func (transitionInterfaceQueryNetRelations) Where(
	params ...NetWhereParam,
) transitionInterfaceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "net",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (transitionInterfaceQueryNetRelations) Fetch() transitionInterfaceToNetFindUnique {
	var v transitionInterfaceToNetFindUnique

	v.query.Operation = "query"
	v.query.Method = "net"
	v.query.Outputs = netOutput

	return v
}

func (r transitionInterfaceQueryNetRelations) Link(
	params NetWhereParam,
) transitionInterfaceWithPrismaNetSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return transitionInterfaceWithPrismaNetSetParam{}
	}

	fields = append(fields, f)

	return transitionInterfaceWithPrismaNetSetParam{
		data: builder.Field{
			Name: "net",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNetRelations) Unlink() transitionInterfaceWithPrismaNetSetParam {
	var v transitionInterfaceWithPrismaNetSetParam

	v = transitionInterfaceWithPrismaNetSetParam{
		data: builder.Field{
			Name: "net",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type transitionInterfaceQueryEventsEvent struct{}

type transitionInterfaceQueryEventsRelations struct{}

// TransitionInterface -> Events
//
// @relation
// @required
func (transitionInterfaceQueryEventsRelations) Some(
	params ...EventWhereParam,
) transitionInterfaceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "events",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// TransitionInterface -> Events
//
// @relation
// @required
func (transitionInterfaceQueryEventsRelations) Every(
	params ...EventWhereParam,
) transitionInterfaceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "events",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (transitionInterfaceQueryEventsRelations) Fetch(

	params ...EventWhereParam,

) transitionInterfaceToEventsFindMany {
	var v transitionInterfaceToEventsFindMany

	v.query.Operation = "query"
	v.query.Method = "events"
	v.query.Outputs = eventOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transitionInterfaceQueryEventsRelations) Link(
	params ...EventWhereParam,
) transitionInterfaceSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionInterfaceSetParam{
		data: builder.Field{
			Name: "events",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryEventsRelations) Unlink(
	params ...EventWhereParam,
) transitionInterfaceSetParam {
	var v transitionInterfaceSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = transitionInterfaceSetParam{
		data: builder.Field{
			Name: "events",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type transitionInterfaceQueryNetIDString struct{}

// Set the required value of NetID
func (r transitionInterfaceQueryNetIDString) Set(value string) transitionInterfaceSetParam {

	return transitionInterfaceSetParam{
		data: builder.Field{
			Name:  "netID",
			Value: value,
		},
	}

}

// Set the optional value of NetID dynamically
func (r transitionInterfaceQueryNetIDString) SetIfPresent(value *string) transitionInterfaceSetParam {
	if value == nil {
		return transitionInterfaceSetParam{}
	}

	return r.Set(*value)
}

func (r transitionInterfaceQueryNetIDString) Equals(value string) transitionInterfaceWithPrismaNetIDEqualsParam {

	return transitionInterfaceWithPrismaNetIDEqualsParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNetIDString) EqualsIfPresent(value *string) transitionInterfaceWithPrismaNetIDEqualsParam {
	if value == nil {
		return transitionInterfaceWithPrismaNetIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transitionInterfaceQueryNetIDString) Order(direction SortOrder) transitionInterfaceDefaultParam {
	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name:  "netID",
			Value: direction,
		},
	}
}

func (r transitionInterfaceQueryNetIDString) Cursor(cursor string) transitionInterfaceCursorParam {
	return transitionInterfaceCursorParam{
		data: builder.Field{
			Name:  "netID",
			Value: cursor,
		},
	}
}

func (r transitionInterfaceQueryNetIDString) In(value []string) transitionInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNetIDString) InIfPresent(value []string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.In(value)
}

func (r transitionInterfaceQueryNetIDString) NotIn(value []string) transitionInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNetIDString) NotInIfPresent(value []string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transitionInterfaceQueryNetIDString) Lt(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNetIDString) LtIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transitionInterfaceQueryNetIDString) Lte(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNetIDString) LteIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transitionInterfaceQueryNetIDString) Gt(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNetIDString) GtIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transitionInterfaceQueryNetIDString) Gte(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNetIDString) GteIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transitionInterfaceQueryNetIDString) Contains(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNetIDString) ContainsIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Contains(*value)
}

func (r transitionInterfaceQueryNetIDString) StartsWith(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNetIDString) StartsWithIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r transitionInterfaceQueryNetIDString) EndsWith(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNetIDString) EndsWithIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r transitionInterfaceQueryNetIDString) Mode(value QueryMode) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNetIDString) ModeIfPresent(value *QueryMode) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Mode(*value)
}

func (r transitionInterfaceQueryNetIDString) Not(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryNetIDString) NotIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r transitionInterfaceQueryNetIDString) HasPrefix(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r transitionInterfaceQueryNetIDString) HasPrefixIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r transitionInterfaceQueryNetIDString) HasSuffix(value string) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r transitionInterfaceQueryNetIDString) HasSuffixIfPresent(value *string) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type transitionInterfaceQueryTransitionsTransition struct{}

type transitionInterfaceQueryTransitionsRelations struct{}

// TransitionInterface -> Transitions
//
// @relation
// @required
func (transitionInterfaceQueryTransitionsRelations) Some(
	params ...TransitionWhereParam,
) transitionInterfaceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "transitions",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// TransitionInterface -> Transitions
//
// @relation
// @required
func (transitionInterfaceQueryTransitionsRelations) Every(
	params ...TransitionWhereParam,
) transitionInterfaceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "transitions",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (transitionInterfaceQueryTransitionsRelations) Fetch(

	params ...TransitionWhereParam,

) transitionInterfaceToTransitionsFindMany {
	var v transitionInterfaceToTransitionsFindMany

	v.query.Operation = "query"
	v.query.Method = "transitions"
	v.query.Outputs = transitionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transitionInterfaceQueryTransitionsRelations) Link(
	params ...TransitionWhereParam,
) transitionInterfaceSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionInterfaceSetParam{
		data: builder.Field{
			Name: "transitions",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryTransitionsRelations) Unlink(
	params ...TransitionWhereParam,
) transitionInterfaceSetParam {
	var v transitionInterfaceSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = transitionInterfaceSetParam{
		data: builder.Field{
			Name: "transitions",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type transitionInterfaceQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r transitionInterfaceQueryCreatedAtDateTime) Set(value DateTime) transitionInterfaceSetParam {

	return transitionInterfaceSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r transitionInterfaceQueryCreatedAtDateTime) SetIfPresent(value *DateTime) transitionInterfaceSetParam {
	if value == nil {
		return transitionInterfaceSetParam{}
	}

	return r.Set(*value)
}

func (r transitionInterfaceQueryCreatedAtDateTime) Equals(value DateTime) transitionInterfaceWithPrismaCreatedAtEqualsParam {

	return transitionInterfaceWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) transitionInterfaceWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return transitionInterfaceWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transitionInterfaceQueryCreatedAtDateTime) Order(direction SortOrder) transitionInterfaceDefaultParam {
	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r transitionInterfaceQueryCreatedAtDateTime) Cursor(cursor DateTime) transitionInterfaceCursorParam {
	return transitionInterfaceCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r transitionInterfaceQueryCreatedAtDateTime) In(value []DateTime) transitionInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryCreatedAtDateTime) InIfPresent(value []DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.In(value)
}

func (r transitionInterfaceQueryCreatedAtDateTime) NotIn(value []DateTime) transitionInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transitionInterfaceQueryCreatedAtDateTime) Lt(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryCreatedAtDateTime) LtIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transitionInterfaceQueryCreatedAtDateTime) Lte(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryCreatedAtDateTime) LteIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transitionInterfaceQueryCreatedAtDateTime) Gt(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryCreatedAtDateTime) GtIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transitionInterfaceQueryCreatedAtDateTime) Gte(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryCreatedAtDateTime) GteIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transitionInterfaceQueryCreatedAtDateTime) Not(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryCreatedAtDateTime) NotIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r transitionInterfaceQueryCreatedAtDateTime) Before(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r transitionInterfaceQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r transitionInterfaceQueryCreatedAtDateTime) After(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r transitionInterfaceQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r transitionInterfaceQueryCreatedAtDateTime) BeforeEquals(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r transitionInterfaceQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r transitionInterfaceQueryCreatedAtDateTime) AfterEquals(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r transitionInterfaceQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type transitionInterfaceQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r transitionInterfaceQueryUpdatedAtDateTime) Set(value DateTime) transitionInterfaceSetParam {

	return transitionInterfaceSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r transitionInterfaceQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) transitionInterfaceSetParam {
	if value == nil {
		return transitionInterfaceSetParam{}
	}

	return r.Set(*value)
}

func (r transitionInterfaceQueryUpdatedAtDateTime) Equals(value DateTime) transitionInterfaceWithPrismaUpdatedAtEqualsParam {

	return transitionInterfaceWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) transitionInterfaceWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return transitionInterfaceWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transitionInterfaceQueryUpdatedAtDateTime) Order(direction SortOrder) transitionInterfaceDefaultParam {
	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r transitionInterfaceQueryUpdatedAtDateTime) Cursor(cursor DateTime) transitionInterfaceCursorParam {
	return transitionInterfaceCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r transitionInterfaceQueryUpdatedAtDateTime) In(value []DateTime) transitionInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryUpdatedAtDateTime) InIfPresent(value []DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.In(value)
}

func (r transitionInterfaceQueryUpdatedAtDateTime) NotIn(value []DateTime) transitionInterfaceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transitionInterfaceQueryUpdatedAtDateTime) Lt(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transitionInterfaceQueryUpdatedAtDateTime) Lte(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transitionInterfaceQueryUpdatedAtDateTime) Gt(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transitionInterfaceQueryUpdatedAtDateTime) Gte(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transitionInterfaceQueryUpdatedAtDateTime) Not(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r transitionInterfaceQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r transitionInterfaceQueryUpdatedAtDateTime) Before(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r transitionInterfaceQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r transitionInterfaceQueryUpdatedAtDateTime) After(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r transitionInterfaceQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r transitionInterfaceQueryUpdatedAtDateTime) BeforeEquals(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r transitionInterfaceQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r transitionInterfaceQueryUpdatedAtDateTime) AfterEquals(value DateTime) transitionInterfaceDefaultParam {

	return transitionInterfaceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r transitionInterfaceQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) transitionInterfaceDefaultParam {
	if value == nil {
		return transitionInterfaceDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// Place acts as a namespaces to access query methods for the Place model
var Place = placeQuery{}

// placeQuery exposes query functions for the place model
type placeQuery struct {

	// ID
	//
	// @required
	ID placeQueryIDString

	// Name
	//
	// @required
	Name placeQueryNameString

	// Description
	//
	// @optional
	Description placeQueryDescriptionString

	// CreatedAt
	//
	// @required
	CreatedAt placeQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt placeQueryUpdatedAtDateTime

	Arcs placeQueryArcsRelations

	// Bound
	//
	// @required
	Bound placeQueryBoundInt

	Nets placeQueryNetsRelations

	Interfaces placeQueryInterfacesRelations
}

func (placeQuery) Not(params ...PlaceWhereParam) placeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (placeQuery) Or(params ...PlaceWhereParam) placeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (placeQuery) And(params ...PlaceWhereParam) placeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type placeQueryIDString struct{}

// Set the required value of ID
func (r placeQueryIDString) Set(value string) placeSetParam {

	return placeSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r placeQueryIDString) SetIfPresent(value *string) placeSetParam {
	if value == nil {
		return placeSetParam{}
	}

	return r.Set(*value)
}

func (r placeQueryIDString) Equals(value string) placeWithPrismaIDEqualsUniqueParam {

	return placeWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r placeQueryIDString) EqualsIfPresent(value *string) placeWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return placeWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r placeQueryIDString) Order(direction SortOrder) placeDefaultParam {
	return placeDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r placeQueryIDString) Cursor(cursor string) placeCursorParam {
	return placeCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r placeQueryIDString) In(value []string) placeParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeQueryIDString) InIfPresent(value []string) placeParamUnique {
	if value == nil {
		return placeParamUnique{}
	}
	return r.In(value)
}

func (r placeQueryIDString) NotIn(value []string) placeParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeQueryIDString) NotInIfPresent(value []string) placeParamUnique {
	if value == nil {
		return placeParamUnique{}
	}
	return r.NotIn(value)
}

func (r placeQueryIDString) Lt(value string) placeParamUnique {

	return placeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryIDString) LtIfPresent(value *string) placeParamUnique {
	if value == nil {
		return placeParamUnique{}
	}
	return r.Lt(*value)
}

func (r placeQueryIDString) Lte(value string) placeParamUnique {

	return placeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryIDString) LteIfPresent(value *string) placeParamUnique {
	if value == nil {
		return placeParamUnique{}
	}
	return r.Lte(*value)
}

func (r placeQueryIDString) Gt(value string) placeParamUnique {

	return placeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryIDString) GtIfPresent(value *string) placeParamUnique {
	if value == nil {
		return placeParamUnique{}
	}
	return r.Gt(*value)
}

func (r placeQueryIDString) Gte(value string) placeParamUnique {

	return placeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryIDString) GteIfPresent(value *string) placeParamUnique {
	if value == nil {
		return placeParamUnique{}
	}
	return r.Gte(*value)
}

func (r placeQueryIDString) Contains(value string) placeParamUnique {

	return placeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryIDString) ContainsIfPresent(value *string) placeParamUnique {
	if value == nil {
		return placeParamUnique{}
	}
	return r.Contains(*value)
}

func (r placeQueryIDString) StartsWith(value string) placeParamUnique {

	return placeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryIDString) StartsWithIfPresent(value *string) placeParamUnique {
	if value == nil {
		return placeParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r placeQueryIDString) EndsWith(value string) placeParamUnique {

	return placeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryIDString) EndsWithIfPresent(value *string) placeParamUnique {
	if value == nil {
		return placeParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r placeQueryIDString) Mode(value QueryMode) placeParamUnique {

	return placeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryIDString) ModeIfPresent(value *QueryMode) placeParamUnique {
	if value == nil {
		return placeParamUnique{}
	}
	return r.Mode(*value)
}

func (r placeQueryIDString) Not(value string) placeParamUnique {

	return placeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryIDString) NotIfPresent(value *string) placeParamUnique {
	if value == nil {
		return placeParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r placeQueryIDString) HasPrefix(value string) placeParamUnique {

	return placeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r placeQueryIDString) HasPrefixIfPresent(value *string) placeParamUnique {
	if value == nil {
		return placeParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r placeQueryIDString) HasSuffix(value string) placeParamUnique {

	return placeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r placeQueryIDString) HasSuffixIfPresent(value *string) placeParamUnique {
	if value == nil {
		return placeParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type placeQueryNameString struct{}

// Set the required value of Name
func (r placeQueryNameString) Set(value string) placeWithPrismaNameSetParam {

	return placeWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r placeQueryNameString) SetIfPresent(value *string) placeWithPrismaNameSetParam {
	if value == nil {
		return placeWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r placeQueryNameString) Equals(value string) placeWithPrismaNameEqualsParam {

	return placeWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r placeQueryNameString) EqualsIfPresent(value *string) placeWithPrismaNameEqualsParam {
	if value == nil {
		return placeWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r placeQueryNameString) Order(direction SortOrder) placeDefaultParam {
	return placeDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r placeQueryNameString) Cursor(cursor string) placeCursorParam {
	return placeCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r placeQueryNameString) In(value []string) placeDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeQueryNameString) InIfPresent(value []string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.In(value)
}

func (r placeQueryNameString) NotIn(value []string) placeDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeQueryNameString) NotInIfPresent(value []string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.NotIn(value)
}

func (r placeQueryNameString) Lt(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryNameString) LtIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Lt(*value)
}

func (r placeQueryNameString) Lte(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryNameString) LteIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Lte(*value)
}

func (r placeQueryNameString) Gt(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryNameString) GtIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Gt(*value)
}

func (r placeQueryNameString) Gte(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryNameString) GteIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Gte(*value)
}

func (r placeQueryNameString) Contains(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryNameString) ContainsIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Contains(*value)
}

func (r placeQueryNameString) StartsWith(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryNameString) StartsWithIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r placeQueryNameString) EndsWith(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryNameString) EndsWithIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r placeQueryNameString) Mode(value QueryMode) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryNameString) ModeIfPresent(value *QueryMode) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Mode(*value)
}

func (r placeQueryNameString) Not(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryNameString) NotIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r placeQueryNameString) HasPrefix(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r placeQueryNameString) HasPrefixIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r placeQueryNameString) HasSuffix(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r placeQueryNameString) HasSuffixIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type placeQueryDescriptionString struct{}

// Set the optional value of Description
func (r placeQueryDescriptionString) Set(value string) placeSetParam {

	return placeSetParam{
		data: builder.Field{
			Name:  "description",
			Value: value,
		},
	}

}

// Set the optional value of Description dynamically
func (r placeQueryDescriptionString) SetIfPresent(value *string) placeSetParam {
	if value == nil {
		return placeSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Description dynamically
func (r placeQueryDescriptionString) SetOptional(value *string) placeSetParam {
	if value == nil {

		var v *string
		return placeSetParam{
			data: builder.Field{
				Name:  "description",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r placeQueryDescriptionString) Equals(value string) placeWithPrismaDescriptionEqualsParam {

	return placeWithPrismaDescriptionEqualsParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r placeQueryDescriptionString) EqualsIfPresent(value *string) placeWithPrismaDescriptionEqualsParam {
	if value == nil {
		return placeWithPrismaDescriptionEqualsParam{}
	}
	return r.Equals(*value)
}

func (r placeQueryDescriptionString) EqualsOptional(value *string) placeDefaultParam {
	return placeDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r placeQueryDescriptionString) IsNull() placeDefaultParam {
	var str *string = nil
	return placeDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r placeQueryDescriptionString) Order(direction SortOrder) placeDefaultParam {
	return placeDefaultParam{
		data: builder.Field{
			Name:  "description",
			Value: direction,
		},
	}
}

func (r placeQueryDescriptionString) Cursor(cursor string) placeCursorParam {
	return placeCursorParam{
		data: builder.Field{
			Name:  "description",
			Value: cursor,
		},
	}
}

func (r placeQueryDescriptionString) In(value []string) placeDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeQueryDescriptionString) InIfPresent(value []string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.In(value)
}

func (r placeQueryDescriptionString) NotIn(value []string) placeDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeQueryDescriptionString) NotInIfPresent(value []string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.NotIn(value)
}

func (r placeQueryDescriptionString) Lt(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryDescriptionString) LtIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Lt(*value)
}

func (r placeQueryDescriptionString) Lte(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryDescriptionString) LteIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Lte(*value)
}

func (r placeQueryDescriptionString) Gt(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryDescriptionString) GtIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Gt(*value)
}

func (r placeQueryDescriptionString) Gte(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryDescriptionString) GteIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Gte(*value)
}

func (r placeQueryDescriptionString) Contains(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryDescriptionString) ContainsIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Contains(*value)
}

func (r placeQueryDescriptionString) StartsWith(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryDescriptionString) StartsWithIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r placeQueryDescriptionString) EndsWith(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryDescriptionString) EndsWithIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r placeQueryDescriptionString) Mode(value QueryMode) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryDescriptionString) ModeIfPresent(value *QueryMode) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Mode(*value)
}

func (r placeQueryDescriptionString) Not(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryDescriptionString) NotIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r placeQueryDescriptionString) HasPrefix(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r placeQueryDescriptionString) HasPrefixIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r placeQueryDescriptionString) HasSuffix(value string) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r placeQueryDescriptionString) HasSuffixIfPresent(value *string) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type placeQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r placeQueryCreatedAtDateTime) Set(value DateTime) placeSetParam {

	return placeSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r placeQueryCreatedAtDateTime) SetIfPresent(value *DateTime) placeSetParam {
	if value == nil {
		return placeSetParam{}
	}

	return r.Set(*value)
}

func (r placeQueryCreatedAtDateTime) Equals(value DateTime) placeWithPrismaCreatedAtEqualsParam {

	return placeWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r placeQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) placeWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return placeWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r placeQueryCreatedAtDateTime) Order(direction SortOrder) placeDefaultParam {
	return placeDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r placeQueryCreatedAtDateTime) Cursor(cursor DateTime) placeCursorParam {
	return placeCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r placeQueryCreatedAtDateTime) In(value []DateTime) placeDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeQueryCreatedAtDateTime) InIfPresent(value []DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.In(value)
}

func (r placeQueryCreatedAtDateTime) NotIn(value []DateTime) placeDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.NotIn(value)
}

func (r placeQueryCreatedAtDateTime) Lt(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryCreatedAtDateTime) LtIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Lt(*value)
}

func (r placeQueryCreatedAtDateTime) Lte(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryCreatedAtDateTime) LteIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Lte(*value)
}

func (r placeQueryCreatedAtDateTime) Gt(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryCreatedAtDateTime) GtIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Gt(*value)
}

func (r placeQueryCreatedAtDateTime) Gte(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryCreatedAtDateTime) GteIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Gte(*value)
}

func (r placeQueryCreatedAtDateTime) Not(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryCreatedAtDateTime) NotIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r placeQueryCreatedAtDateTime) Before(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r placeQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r placeQueryCreatedAtDateTime) After(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r placeQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r placeQueryCreatedAtDateTime) BeforeEquals(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r placeQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r placeQueryCreatedAtDateTime) AfterEquals(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r placeQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type placeQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r placeQueryUpdatedAtDateTime) Set(value DateTime) placeSetParam {

	return placeSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r placeQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) placeSetParam {
	if value == nil {
		return placeSetParam{}
	}

	return r.Set(*value)
}

func (r placeQueryUpdatedAtDateTime) Equals(value DateTime) placeWithPrismaUpdatedAtEqualsParam {

	return placeWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r placeQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) placeWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return placeWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r placeQueryUpdatedAtDateTime) Order(direction SortOrder) placeDefaultParam {
	return placeDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r placeQueryUpdatedAtDateTime) Cursor(cursor DateTime) placeCursorParam {
	return placeCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r placeQueryUpdatedAtDateTime) In(value []DateTime) placeDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeQueryUpdatedAtDateTime) InIfPresent(value []DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.In(value)
}

func (r placeQueryUpdatedAtDateTime) NotIn(value []DateTime) placeDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.NotIn(value)
}

func (r placeQueryUpdatedAtDateTime) Lt(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Lt(*value)
}

func (r placeQueryUpdatedAtDateTime) Lte(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Lte(*value)
}

func (r placeQueryUpdatedAtDateTime) Gt(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Gt(*value)
}

func (r placeQueryUpdatedAtDateTime) Gte(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Gte(*value)
}

func (r placeQueryUpdatedAtDateTime) Not(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r placeQueryUpdatedAtDateTime) Before(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r placeQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r placeQueryUpdatedAtDateTime) After(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r placeQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r placeQueryUpdatedAtDateTime) BeforeEquals(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r placeQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r placeQueryUpdatedAtDateTime) AfterEquals(value DateTime) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r placeQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type placeQueryArcsArc struct{}

type placeQueryArcsRelations struct{}

// Place -> Arcs
//
// @relation
// @required
func (placeQueryArcsRelations) Some(
	params ...ArcWhereParam,
) placeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeDefaultParam{
		data: builder.Field{
			Name: "arcs",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Place -> Arcs
//
// @relation
// @required
func (placeQueryArcsRelations) Every(
	params ...ArcWhereParam,
) placeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeDefaultParam{
		data: builder.Field{
			Name: "arcs",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (placeQueryArcsRelations) Fetch(

	params ...ArcWhereParam,

) placeToArcsFindMany {
	var v placeToArcsFindMany

	v.query.Operation = "query"
	v.query.Method = "arcs"
	v.query.Outputs = arcOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r placeQueryArcsRelations) Link(
	params ...ArcWhereParam,
) placeSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeSetParam{
		data: builder.Field{
			Name: "arcs",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r placeQueryArcsRelations) Unlink(
	params ...ArcWhereParam,
) placeSetParam {
	var v placeSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = placeSetParam{
		data: builder.Field{
			Name: "arcs",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type placeQueryBoundInt struct{}

// Set the required value of Bound
func (r placeQueryBoundInt) Set(value int) placeWithPrismaBoundSetParam {

	return placeWithPrismaBoundSetParam{
		data: builder.Field{
			Name:  "bound",
			Value: value,
		},
	}

}

// Set the optional value of Bound dynamically
func (r placeQueryBoundInt) SetIfPresent(value *int) placeWithPrismaBoundSetParam {
	if value == nil {
		return placeWithPrismaBoundSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Bound
func (r placeQueryBoundInt) Increment(value int) placeWithPrismaBoundSetParam {

	return placeWithPrismaBoundSetParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				builder.Field{
					Name: "increment",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryBoundInt) IncrementIfPresent(value *int) placeWithPrismaBoundSetParam {
	if value == nil {
		return placeWithPrismaBoundSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Bound
func (r placeQueryBoundInt) Decrement(value int) placeWithPrismaBoundSetParam {

	return placeWithPrismaBoundSetParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				builder.Field{
					Name: "decrement",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryBoundInt) DecrementIfPresent(value *int) placeWithPrismaBoundSetParam {
	if value == nil {
		return placeWithPrismaBoundSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Bound
func (r placeQueryBoundInt) Multiply(value int) placeWithPrismaBoundSetParam {

	return placeWithPrismaBoundSetParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				builder.Field{
					Name: "multiply",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryBoundInt) MultiplyIfPresent(value *int) placeWithPrismaBoundSetParam {
	if value == nil {
		return placeWithPrismaBoundSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Bound
func (r placeQueryBoundInt) Divide(value int) placeWithPrismaBoundSetParam {

	return placeWithPrismaBoundSetParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				builder.Field{
					Name: "divide",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryBoundInt) DivideIfPresent(value *int) placeWithPrismaBoundSetParam {
	if value == nil {
		return placeWithPrismaBoundSetParam{}
	}
	return r.Divide(*value)
}

func (r placeQueryBoundInt) Equals(value int) placeWithPrismaBoundEqualsParam {

	return placeWithPrismaBoundEqualsParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r placeQueryBoundInt) EqualsIfPresent(value *int) placeWithPrismaBoundEqualsParam {
	if value == nil {
		return placeWithPrismaBoundEqualsParam{}
	}
	return r.Equals(*value)
}

func (r placeQueryBoundInt) Order(direction SortOrder) placeDefaultParam {
	return placeDefaultParam{
		data: builder.Field{
			Name:  "bound",
			Value: direction,
		},
	}
}

func (r placeQueryBoundInt) Cursor(cursor int) placeCursorParam {
	return placeCursorParam{
		data: builder.Field{
			Name:  "bound",
			Value: cursor,
		},
	}
}

func (r placeQueryBoundInt) In(value []int) placeDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeQueryBoundInt) InIfPresent(value []int) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.In(value)
}

func (r placeQueryBoundInt) NotIn(value []int) placeDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return placeDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r placeQueryBoundInt) NotInIfPresent(value []int) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.NotIn(value)
}

func (r placeQueryBoundInt) Lt(value int) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryBoundInt) LtIfPresent(value *int) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Lt(*value)
}

func (r placeQueryBoundInt) Lte(value int) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryBoundInt) LteIfPresent(value *int) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Lte(*value)
}

func (r placeQueryBoundInt) Gt(value int) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryBoundInt) GtIfPresent(value *int) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Gt(*value)
}

func (r placeQueryBoundInt) Gte(value int) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryBoundInt) GteIfPresent(value *int) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Gte(*value)
}

func (r placeQueryBoundInt) Not(value int) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r placeQueryBoundInt) NotIfPresent(value *int) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r placeQueryBoundInt) LT(value int) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r placeQueryBoundInt) LTIfPresent(value *int) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r placeQueryBoundInt) LTE(value int) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r placeQueryBoundInt) LTEIfPresent(value *int) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r placeQueryBoundInt) GT(value int) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r placeQueryBoundInt) GTIfPresent(value *int) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r placeQueryBoundInt) GTE(value int) placeDefaultParam {

	return placeDefaultParam{
		data: builder.Field{
			Name: "bound",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r placeQueryBoundInt) GTEIfPresent(value *int) placeDefaultParam {
	if value == nil {
		return placeDefaultParam{}
	}
	return r.GTE(*value)
}

// base struct
type placeQueryNetsNet struct{}

type placeQueryNetsRelations struct{}

// Place -> Nets
//
// @relation
// @required
func (placeQueryNetsRelations) Some(
	params ...NetWhereParam,
) placeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeDefaultParam{
		data: builder.Field{
			Name: "nets",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Place -> Nets
//
// @relation
// @required
func (placeQueryNetsRelations) Every(
	params ...NetWhereParam,
) placeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeDefaultParam{
		data: builder.Field{
			Name: "nets",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (placeQueryNetsRelations) Fetch(

	params ...NetWhereParam,

) placeToNetsFindMany {
	var v placeToNetsFindMany

	v.query.Operation = "query"
	v.query.Method = "nets"
	v.query.Outputs = netOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r placeQueryNetsRelations) Link(
	params ...NetWhereParam,
) placeSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeSetParam{
		data: builder.Field{
			Name: "nets",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r placeQueryNetsRelations) Unlink(
	params ...NetWhereParam,
) placeSetParam {
	var v placeSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = placeSetParam{
		data: builder.Field{
			Name: "nets",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type placeQueryInterfacesPlaceInterface struct{}

type placeQueryInterfacesRelations struct{}

// Place -> Interfaces
//
// @relation
// @required
func (placeQueryInterfacesRelations) Some(
	params ...PlaceInterfaceWhereParam,
) placeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeDefaultParam{
		data: builder.Field{
			Name: "interfaces",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Place -> Interfaces
//
// @relation
// @required
func (placeQueryInterfacesRelations) Every(
	params ...PlaceInterfaceWhereParam,
) placeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeDefaultParam{
		data: builder.Field{
			Name: "interfaces",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (placeQueryInterfacesRelations) Fetch(

	params ...PlaceInterfaceWhereParam,

) placeToInterfacesFindMany {
	var v placeToInterfacesFindMany

	v.query.Operation = "query"
	v.query.Method = "interfaces"
	v.query.Outputs = placeInterfaceOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r placeQueryInterfacesRelations) Link(
	params ...PlaceInterfaceWhereParam,
) placeSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return placeSetParam{
		data: builder.Field{
			Name: "interfaces",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r placeQueryInterfacesRelations) Unlink(
	params ...PlaceInterfaceWhereParam,
) placeSetParam {
	var v placeSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = placeSetParam{
		data: builder.Field{
			Name: "interfaces",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// Transition acts as a namespaces to access query methods for the Transition model
var Transition = transitionQuery{}

// transitionQuery exposes query functions for the transition model
type transitionQuery struct {

	// ID
	//
	// @required
	ID transitionQueryIDString

	// Condition
	//
	// @optional
	Condition transitionQueryConditionString

	// Description
	//
	// @optional
	Description transitionQueryDescriptionString

	// Name
	//
	// @required
	Name transitionQueryNameString

	Arcs transitionQueryArcsRelations

	Events transitionQueryEventsRelations

	// CreatedAt
	//
	// @required
	CreatedAt transitionQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt transitionQueryUpdatedAtDateTime

	Nets transitionQueryNetsRelations

	Interfaces transitionQueryInterfacesRelations
}

func (transitionQuery) Not(params ...TransitionWhereParam) transitionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (transitionQuery) Or(params ...TransitionWhereParam) transitionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (transitionQuery) And(params ...TransitionWhereParam) transitionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type transitionQueryIDString struct{}

// Set the required value of ID
func (r transitionQueryIDString) Set(value string) transitionSetParam {

	return transitionSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r transitionQueryIDString) SetIfPresent(value *string) transitionSetParam {
	if value == nil {
		return transitionSetParam{}
	}

	return r.Set(*value)
}

func (r transitionQueryIDString) Equals(value string) transitionWithPrismaIDEqualsUniqueParam {

	return transitionWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryIDString) EqualsIfPresent(value *string) transitionWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return transitionWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r transitionQueryIDString) Order(direction SortOrder) transitionDefaultParam {
	return transitionDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r transitionQueryIDString) Cursor(cursor string) transitionCursorParam {
	return transitionCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r transitionQueryIDString) In(value []string) transitionParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionQueryIDString) InIfPresent(value []string) transitionParamUnique {
	if value == nil {
		return transitionParamUnique{}
	}
	return r.In(value)
}

func (r transitionQueryIDString) NotIn(value []string) transitionParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionQueryIDString) NotInIfPresent(value []string) transitionParamUnique {
	if value == nil {
		return transitionParamUnique{}
	}
	return r.NotIn(value)
}

func (r transitionQueryIDString) Lt(value string) transitionParamUnique {

	return transitionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryIDString) LtIfPresent(value *string) transitionParamUnique {
	if value == nil {
		return transitionParamUnique{}
	}
	return r.Lt(*value)
}

func (r transitionQueryIDString) Lte(value string) transitionParamUnique {

	return transitionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryIDString) LteIfPresent(value *string) transitionParamUnique {
	if value == nil {
		return transitionParamUnique{}
	}
	return r.Lte(*value)
}

func (r transitionQueryIDString) Gt(value string) transitionParamUnique {

	return transitionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryIDString) GtIfPresent(value *string) transitionParamUnique {
	if value == nil {
		return transitionParamUnique{}
	}
	return r.Gt(*value)
}

func (r transitionQueryIDString) Gte(value string) transitionParamUnique {

	return transitionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryIDString) GteIfPresent(value *string) transitionParamUnique {
	if value == nil {
		return transitionParamUnique{}
	}
	return r.Gte(*value)
}

func (r transitionQueryIDString) Contains(value string) transitionParamUnique {

	return transitionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryIDString) ContainsIfPresent(value *string) transitionParamUnique {
	if value == nil {
		return transitionParamUnique{}
	}
	return r.Contains(*value)
}

func (r transitionQueryIDString) StartsWith(value string) transitionParamUnique {

	return transitionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryIDString) StartsWithIfPresent(value *string) transitionParamUnique {
	if value == nil {
		return transitionParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r transitionQueryIDString) EndsWith(value string) transitionParamUnique {

	return transitionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryIDString) EndsWithIfPresent(value *string) transitionParamUnique {
	if value == nil {
		return transitionParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r transitionQueryIDString) Mode(value QueryMode) transitionParamUnique {

	return transitionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryIDString) ModeIfPresent(value *QueryMode) transitionParamUnique {
	if value == nil {
		return transitionParamUnique{}
	}
	return r.Mode(*value)
}

func (r transitionQueryIDString) Not(value string) transitionParamUnique {

	return transitionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryIDString) NotIfPresent(value *string) transitionParamUnique {
	if value == nil {
		return transitionParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r transitionQueryIDString) HasPrefix(value string) transitionParamUnique {

	return transitionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r transitionQueryIDString) HasPrefixIfPresent(value *string) transitionParamUnique {
	if value == nil {
		return transitionParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r transitionQueryIDString) HasSuffix(value string) transitionParamUnique {

	return transitionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r transitionQueryIDString) HasSuffixIfPresent(value *string) transitionParamUnique {
	if value == nil {
		return transitionParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type transitionQueryConditionString struct{}

// Set the optional value of Condition
func (r transitionQueryConditionString) Set(value string) transitionSetParam {

	return transitionSetParam{
		data: builder.Field{
			Name:  "condition",
			Value: value,
		},
	}

}

// Set the optional value of Condition dynamically
func (r transitionQueryConditionString) SetIfPresent(value *string) transitionSetParam {
	if value == nil {
		return transitionSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Condition dynamically
func (r transitionQueryConditionString) SetOptional(value *string) transitionSetParam {
	if value == nil {

		var v *string
		return transitionSetParam{
			data: builder.Field{
				Name:  "condition",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r transitionQueryConditionString) Equals(value string) transitionWithPrismaConditionEqualsParam {

	return transitionWithPrismaConditionEqualsParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryConditionString) EqualsIfPresent(value *string) transitionWithPrismaConditionEqualsParam {
	if value == nil {
		return transitionWithPrismaConditionEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transitionQueryConditionString) EqualsOptional(value *string) transitionDefaultParam {
	return transitionDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryConditionString) IsNull() transitionDefaultParam {
	var str *string = nil
	return transitionDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r transitionQueryConditionString) Order(direction SortOrder) transitionDefaultParam {
	return transitionDefaultParam{
		data: builder.Field{
			Name:  "condition",
			Value: direction,
		},
	}
}

func (r transitionQueryConditionString) Cursor(cursor string) transitionCursorParam {
	return transitionCursorParam{
		data: builder.Field{
			Name:  "condition",
			Value: cursor,
		},
	}
}

func (r transitionQueryConditionString) In(value []string) transitionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionQueryConditionString) InIfPresent(value []string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.In(value)
}

func (r transitionQueryConditionString) NotIn(value []string) transitionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionQueryConditionString) NotInIfPresent(value []string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transitionQueryConditionString) Lt(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryConditionString) LtIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transitionQueryConditionString) Lte(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryConditionString) LteIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transitionQueryConditionString) Gt(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryConditionString) GtIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transitionQueryConditionString) Gte(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryConditionString) GteIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transitionQueryConditionString) Contains(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryConditionString) ContainsIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Contains(*value)
}

func (r transitionQueryConditionString) StartsWith(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryConditionString) StartsWithIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r transitionQueryConditionString) EndsWith(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryConditionString) EndsWithIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r transitionQueryConditionString) Mode(value QueryMode) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryConditionString) ModeIfPresent(value *QueryMode) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Mode(*value)
}

func (r transitionQueryConditionString) Not(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryConditionString) NotIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r transitionQueryConditionString) HasPrefix(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r transitionQueryConditionString) HasPrefixIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r transitionQueryConditionString) HasSuffix(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r transitionQueryConditionString) HasSuffixIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type transitionQueryDescriptionString struct{}

// Set the optional value of Description
func (r transitionQueryDescriptionString) Set(value string) transitionSetParam {

	return transitionSetParam{
		data: builder.Field{
			Name:  "description",
			Value: value,
		},
	}

}

// Set the optional value of Description dynamically
func (r transitionQueryDescriptionString) SetIfPresent(value *string) transitionSetParam {
	if value == nil {
		return transitionSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Description dynamically
func (r transitionQueryDescriptionString) SetOptional(value *string) transitionSetParam {
	if value == nil {

		var v *string
		return transitionSetParam{
			data: builder.Field{
				Name:  "description",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r transitionQueryDescriptionString) Equals(value string) transitionWithPrismaDescriptionEqualsParam {

	return transitionWithPrismaDescriptionEqualsParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryDescriptionString) EqualsIfPresent(value *string) transitionWithPrismaDescriptionEqualsParam {
	if value == nil {
		return transitionWithPrismaDescriptionEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transitionQueryDescriptionString) EqualsOptional(value *string) transitionDefaultParam {
	return transitionDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryDescriptionString) IsNull() transitionDefaultParam {
	var str *string = nil
	return transitionDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r transitionQueryDescriptionString) Order(direction SortOrder) transitionDefaultParam {
	return transitionDefaultParam{
		data: builder.Field{
			Name:  "description",
			Value: direction,
		},
	}
}

func (r transitionQueryDescriptionString) Cursor(cursor string) transitionCursorParam {
	return transitionCursorParam{
		data: builder.Field{
			Name:  "description",
			Value: cursor,
		},
	}
}

func (r transitionQueryDescriptionString) In(value []string) transitionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionQueryDescriptionString) InIfPresent(value []string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.In(value)
}

func (r transitionQueryDescriptionString) NotIn(value []string) transitionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionQueryDescriptionString) NotInIfPresent(value []string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transitionQueryDescriptionString) Lt(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryDescriptionString) LtIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transitionQueryDescriptionString) Lte(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryDescriptionString) LteIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transitionQueryDescriptionString) Gt(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryDescriptionString) GtIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transitionQueryDescriptionString) Gte(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryDescriptionString) GteIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transitionQueryDescriptionString) Contains(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryDescriptionString) ContainsIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Contains(*value)
}

func (r transitionQueryDescriptionString) StartsWith(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryDescriptionString) StartsWithIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r transitionQueryDescriptionString) EndsWith(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryDescriptionString) EndsWithIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r transitionQueryDescriptionString) Mode(value QueryMode) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryDescriptionString) ModeIfPresent(value *QueryMode) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Mode(*value)
}

func (r transitionQueryDescriptionString) Not(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryDescriptionString) NotIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r transitionQueryDescriptionString) HasPrefix(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r transitionQueryDescriptionString) HasPrefixIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r transitionQueryDescriptionString) HasSuffix(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r transitionQueryDescriptionString) HasSuffixIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type transitionQueryNameString struct{}

// Set the required value of Name
func (r transitionQueryNameString) Set(value string) transitionWithPrismaNameSetParam {

	return transitionWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r transitionQueryNameString) SetIfPresent(value *string) transitionWithPrismaNameSetParam {
	if value == nil {
		return transitionWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r transitionQueryNameString) Equals(value string) transitionWithPrismaNameEqualsParam {

	return transitionWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryNameString) EqualsIfPresent(value *string) transitionWithPrismaNameEqualsParam {
	if value == nil {
		return transitionWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transitionQueryNameString) Order(direction SortOrder) transitionDefaultParam {
	return transitionDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r transitionQueryNameString) Cursor(cursor string) transitionCursorParam {
	return transitionCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r transitionQueryNameString) In(value []string) transitionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionQueryNameString) InIfPresent(value []string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.In(value)
}

func (r transitionQueryNameString) NotIn(value []string) transitionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionQueryNameString) NotInIfPresent(value []string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transitionQueryNameString) Lt(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryNameString) LtIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transitionQueryNameString) Lte(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryNameString) LteIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transitionQueryNameString) Gt(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryNameString) GtIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transitionQueryNameString) Gte(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryNameString) GteIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transitionQueryNameString) Contains(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryNameString) ContainsIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Contains(*value)
}

func (r transitionQueryNameString) StartsWith(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryNameString) StartsWithIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r transitionQueryNameString) EndsWith(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryNameString) EndsWithIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r transitionQueryNameString) Mode(value QueryMode) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryNameString) ModeIfPresent(value *QueryMode) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Mode(*value)
}

func (r transitionQueryNameString) Not(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryNameString) NotIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r transitionQueryNameString) HasPrefix(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r transitionQueryNameString) HasPrefixIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r transitionQueryNameString) HasSuffix(value string) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r transitionQueryNameString) HasSuffixIfPresent(value *string) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type transitionQueryArcsArc struct{}

type transitionQueryArcsRelations struct{}

// Transition -> Arcs
//
// @relation
// @required
func (transitionQueryArcsRelations) Some(
	params ...ArcWhereParam,
) transitionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "arcs",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Transition -> Arcs
//
// @relation
// @required
func (transitionQueryArcsRelations) Every(
	params ...ArcWhereParam,
) transitionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "arcs",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (transitionQueryArcsRelations) Fetch(

	params ...ArcWhereParam,

) transitionToArcsFindMany {
	var v transitionToArcsFindMany

	v.query.Operation = "query"
	v.query.Method = "arcs"
	v.query.Outputs = arcOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transitionQueryArcsRelations) Link(
	params ...ArcWhereParam,
) transitionSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionSetParam{
		data: builder.Field{
			Name: "arcs",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r transitionQueryArcsRelations) Unlink(
	params ...ArcWhereParam,
) transitionSetParam {
	var v transitionSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = transitionSetParam{
		data: builder.Field{
			Name: "arcs",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type transitionQueryEventsEvent struct{}

type transitionQueryEventsRelations struct{}

// Transition -> Events
//
// @relation
// @required
func (transitionQueryEventsRelations) Some(
	params ...EventWhereParam,
) transitionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "events",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Transition -> Events
//
// @relation
// @required
func (transitionQueryEventsRelations) Every(
	params ...EventWhereParam,
) transitionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "events",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (transitionQueryEventsRelations) Fetch(

	params ...EventWhereParam,

) transitionToEventsFindMany {
	var v transitionToEventsFindMany

	v.query.Operation = "query"
	v.query.Method = "events"
	v.query.Outputs = eventOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transitionQueryEventsRelations) Link(
	params ...EventWhereParam,
) transitionSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionSetParam{
		data: builder.Field{
			Name: "events",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r transitionQueryEventsRelations) Unlink(
	params ...EventWhereParam,
) transitionSetParam {
	var v transitionSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = transitionSetParam{
		data: builder.Field{
			Name: "events",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type transitionQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r transitionQueryCreatedAtDateTime) Set(value DateTime) transitionSetParam {

	return transitionSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r transitionQueryCreatedAtDateTime) SetIfPresent(value *DateTime) transitionSetParam {
	if value == nil {
		return transitionSetParam{}
	}

	return r.Set(*value)
}

func (r transitionQueryCreatedAtDateTime) Equals(value DateTime) transitionWithPrismaCreatedAtEqualsParam {

	return transitionWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) transitionWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return transitionWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transitionQueryCreatedAtDateTime) Order(direction SortOrder) transitionDefaultParam {
	return transitionDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r transitionQueryCreatedAtDateTime) Cursor(cursor DateTime) transitionCursorParam {
	return transitionCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r transitionQueryCreatedAtDateTime) In(value []DateTime) transitionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionQueryCreatedAtDateTime) InIfPresent(value []DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.In(value)
}

func (r transitionQueryCreatedAtDateTime) NotIn(value []DateTime) transitionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transitionQueryCreatedAtDateTime) Lt(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryCreatedAtDateTime) LtIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transitionQueryCreatedAtDateTime) Lte(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryCreatedAtDateTime) LteIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transitionQueryCreatedAtDateTime) Gt(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryCreatedAtDateTime) GtIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transitionQueryCreatedAtDateTime) Gte(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryCreatedAtDateTime) GteIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transitionQueryCreatedAtDateTime) Not(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryCreatedAtDateTime) NotIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r transitionQueryCreatedAtDateTime) Before(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r transitionQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r transitionQueryCreatedAtDateTime) After(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r transitionQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r transitionQueryCreatedAtDateTime) BeforeEquals(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r transitionQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r transitionQueryCreatedAtDateTime) AfterEquals(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r transitionQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type transitionQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r transitionQueryUpdatedAtDateTime) Set(value DateTime) transitionSetParam {

	return transitionSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r transitionQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) transitionSetParam {
	if value == nil {
		return transitionSetParam{}
	}

	return r.Set(*value)
}

func (r transitionQueryUpdatedAtDateTime) Equals(value DateTime) transitionWithPrismaUpdatedAtEqualsParam {

	return transitionWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) transitionWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return transitionWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transitionQueryUpdatedAtDateTime) Order(direction SortOrder) transitionDefaultParam {
	return transitionDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r transitionQueryUpdatedAtDateTime) Cursor(cursor DateTime) transitionCursorParam {
	return transitionCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r transitionQueryUpdatedAtDateTime) In(value []DateTime) transitionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionQueryUpdatedAtDateTime) InIfPresent(value []DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.In(value)
}

func (r transitionQueryUpdatedAtDateTime) NotIn(value []DateTime) transitionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r transitionQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transitionQueryUpdatedAtDateTime) Lt(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transitionQueryUpdatedAtDateTime) Lte(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transitionQueryUpdatedAtDateTime) Gt(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transitionQueryUpdatedAtDateTime) Gte(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transitionQueryUpdatedAtDateTime) Not(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r transitionQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r transitionQueryUpdatedAtDateTime) Before(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r transitionQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r transitionQueryUpdatedAtDateTime) After(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r transitionQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r transitionQueryUpdatedAtDateTime) BeforeEquals(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r transitionQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r transitionQueryUpdatedAtDateTime) AfterEquals(value DateTime) transitionDefaultParam {

	return transitionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r transitionQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) transitionDefaultParam {
	if value == nil {
		return transitionDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type transitionQueryNetsNet struct{}

type transitionQueryNetsRelations struct{}

// Transition -> Nets
//
// @relation
// @required
func (transitionQueryNetsRelations) Some(
	params ...NetWhereParam,
) transitionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "nets",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Transition -> Nets
//
// @relation
// @required
func (transitionQueryNetsRelations) Every(
	params ...NetWhereParam,
) transitionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "nets",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (transitionQueryNetsRelations) Fetch(

	params ...NetWhereParam,

) transitionToNetsFindMany {
	var v transitionToNetsFindMany

	v.query.Operation = "query"
	v.query.Method = "nets"
	v.query.Outputs = netOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transitionQueryNetsRelations) Link(
	params ...NetWhereParam,
) transitionSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionSetParam{
		data: builder.Field{
			Name: "nets",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r transitionQueryNetsRelations) Unlink(
	params ...NetWhereParam,
) transitionSetParam {
	var v transitionSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = transitionSetParam{
		data: builder.Field{
			Name: "nets",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type transitionQueryInterfacesTransitionInterface struct{}

type transitionQueryInterfacesRelations struct{}

// Transition -> Interfaces
//
// @relation
// @required
func (transitionQueryInterfacesRelations) Some(
	params ...TransitionInterfaceWhereParam,
) transitionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "interfaces",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Transition -> Interfaces
//
// @relation
// @required
func (transitionQueryInterfacesRelations) Every(
	params ...TransitionInterfaceWhereParam,
) transitionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionDefaultParam{
		data: builder.Field{
			Name: "interfaces",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (transitionQueryInterfacesRelations) Fetch(

	params ...TransitionInterfaceWhereParam,

) transitionToInterfacesFindMany {
	var v transitionToInterfacesFindMany

	v.query.Operation = "query"
	v.query.Method = "interfaces"
	v.query.Outputs = transitionInterfaceOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transitionQueryInterfacesRelations) Link(
	params ...TransitionInterfaceWhereParam,
) transitionSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transitionSetParam{
		data: builder.Field{
			Name: "interfaces",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r transitionQueryInterfacesRelations) Unlink(
	params ...TransitionInterfaceWhereParam,
) transitionSetParam {
	var v transitionSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = transitionSetParam{
		data: builder.Field{
			Name: "interfaces",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// Arc acts as a namespaces to access query methods for the Arc model
var Arc = arcQuery{}

// arcQuery exposes query functions for the arc model
type arcQuery struct {

	// ID
	//
	// @required
	ID arcQueryIDString

	Net arcQueryNetRelations

	// NetID
	//
	// @required
	NetID arcQueryNetIDString

	// FromPlace
	//
	// @required
	FromPlace arcQueryFromPlaceBoolean

	Place arcQueryPlaceRelations

	// PlaceID
	//
	// @required
	PlaceID arcQueryPlaceIDString

	Transition arcQueryTransitionRelations

	// TransitionID
	//
	// @required
	TransitionID arcQueryTransitionIDString

	// CreatedAt
	//
	// @required
	CreatedAt arcQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt arcQueryUpdatedAtDateTime
}

func (arcQuery) Not(params ...ArcWhereParam) arcDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return arcDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (arcQuery) Or(params ...ArcWhereParam) arcDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return arcDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (arcQuery) And(params ...ArcWhereParam) arcDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return arcDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type arcQueryIDString struct{}

// Set the required value of ID
func (r arcQueryIDString) Set(value string) arcSetParam {

	return arcSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r arcQueryIDString) SetIfPresent(value *string) arcSetParam {
	if value == nil {
		return arcSetParam{}
	}

	return r.Set(*value)
}

func (r arcQueryIDString) Equals(value string) arcWithPrismaIDEqualsUniqueParam {

	return arcWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r arcQueryIDString) EqualsIfPresent(value *string) arcWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return arcWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r arcQueryIDString) Order(direction SortOrder) arcDefaultParam {
	return arcDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r arcQueryIDString) Cursor(cursor string) arcCursorParam {
	return arcCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r arcQueryIDString) In(value []string) arcParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return arcParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r arcQueryIDString) InIfPresent(value []string) arcParamUnique {
	if value == nil {
		return arcParamUnique{}
	}
	return r.In(value)
}

func (r arcQueryIDString) NotIn(value []string) arcParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return arcParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r arcQueryIDString) NotInIfPresent(value []string) arcParamUnique {
	if value == nil {
		return arcParamUnique{}
	}
	return r.NotIn(value)
}

func (r arcQueryIDString) Lt(value string) arcParamUnique {

	return arcParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryIDString) LtIfPresent(value *string) arcParamUnique {
	if value == nil {
		return arcParamUnique{}
	}
	return r.Lt(*value)
}

func (r arcQueryIDString) Lte(value string) arcParamUnique {

	return arcParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryIDString) LteIfPresent(value *string) arcParamUnique {
	if value == nil {
		return arcParamUnique{}
	}
	return r.Lte(*value)
}

func (r arcQueryIDString) Gt(value string) arcParamUnique {

	return arcParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryIDString) GtIfPresent(value *string) arcParamUnique {
	if value == nil {
		return arcParamUnique{}
	}
	return r.Gt(*value)
}

func (r arcQueryIDString) Gte(value string) arcParamUnique {

	return arcParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryIDString) GteIfPresent(value *string) arcParamUnique {
	if value == nil {
		return arcParamUnique{}
	}
	return r.Gte(*value)
}

func (r arcQueryIDString) Contains(value string) arcParamUnique {

	return arcParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryIDString) ContainsIfPresent(value *string) arcParamUnique {
	if value == nil {
		return arcParamUnique{}
	}
	return r.Contains(*value)
}

func (r arcQueryIDString) StartsWith(value string) arcParamUnique {

	return arcParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryIDString) StartsWithIfPresent(value *string) arcParamUnique {
	if value == nil {
		return arcParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r arcQueryIDString) EndsWith(value string) arcParamUnique {

	return arcParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryIDString) EndsWithIfPresent(value *string) arcParamUnique {
	if value == nil {
		return arcParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r arcQueryIDString) Mode(value QueryMode) arcParamUnique {

	return arcParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryIDString) ModeIfPresent(value *QueryMode) arcParamUnique {
	if value == nil {
		return arcParamUnique{}
	}
	return r.Mode(*value)
}

func (r arcQueryIDString) Not(value string) arcParamUnique {

	return arcParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryIDString) NotIfPresent(value *string) arcParamUnique {
	if value == nil {
		return arcParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r arcQueryIDString) HasPrefix(value string) arcParamUnique {

	return arcParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r arcQueryIDString) HasPrefixIfPresent(value *string) arcParamUnique {
	if value == nil {
		return arcParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r arcQueryIDString) HasSuffix(value string) arcParamUnique {

	return arcParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r arcQueryIDString) HasSuffixIfPresent(value *string) arcParamUnique {
	if value == nil {
		return arcParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type arcQueryNetNet struct{}

type arcQueryNetRelations struct{}

// Arc -> Net
//
// @relation
// @required
func (arcQueryNetRelations) Where(
	params ...NetWhereParam,
) arcDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return arcDefaultParam{
		data: builder.Field{
			Name: "net",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (arcQueryNetRelations) Fetch() arcToNetFindUnique {
	var v arcToNetFindUnique

	v.query.Operation = "query"
	v.query.Method = "net"
	v.query.Outputs = netOutput

	return v
}

func (r arcQueryNetRelations) Link(
	params NetWhereParam,
) arcWithPrismaNetSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return arcWithPrismaNetSetParam{}
	}

	fields = append(fields, f)

	return arcWithPrismaNetSetParam{
		data: builder.Field{
			Name: "net",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r arcQueryNetRelations) Unlink() arcWithPrismaNetSetParam {
	var v arcWithPrismaNetSetParam

	v = arcWithPrismaNetSetParam{
		data: builder.Field{
			Name: "net",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type arcQueryNetIDString struct{}

// Set the required value of NetID
func (r arcQueryNetIDString) Set(value string) arcSetParam {

	return arcSetParam{
		data: builder.Field{
			Name:  "netID",
			Value: value,
		},
	}

}

// Set the optional value of NetID dynamically
func (r arcQueryNetIDString) SetIfPresent(value *string) arcSetParam {
	if value == nil {
		return arcSetParam{}
	}

	return r.Set(*value)
}

func (r arcQueryNetIDString) Equals(value string) arcWithPrismaNetIDEqualsParam {

	return arcWithPrismaNetIDEqualsParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r arcQueryNetIDString) EqualsIfPresent(value *string) arcWithPrismaNetIDEqualsParam {
	if value == nil {
		return arcWithPrismaNetIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r arcQueryNetIDString) Order(direction SortOrder) arcDefaultParam {
	return arcDefaultParam{
		data: builder.Field{
			Name:  "netID",
			Value: direction,
		},
	}
}

func (r arcQueryNetIDString) Cursor(cursor string) arcCursorParam {
	return arcCursorParam{
		data: builder.Field{
			Name:  "netID",
			Value: cursor,
		},
	}
}

func (r arcQueryNetIDString) In(value []string) arcDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return arcDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r arcQueryNetIDString) InIfPresent(value []string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.In(value)
}

func (r arcQueryNetIDString) NotIn(value []string) arcDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return arcDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r arcQueryNetIDString) NotInIfPresent(value []string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.NotIn(value)
}

func (r arcQueryNetIDString) Lt(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryNetIDString) LtIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Lt(*value)
}

func (r arcQueryNetIDString) Lte(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryNetIDString) LteIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Lte(*value)
}

func (r arcQueryNetIDString) Gt(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryNetIDString) GtIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Gt(*value)
}

func (r arcQueryNetIDString) Gte(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryNetIDString) GteIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Gte(*value)
}

func (r arcQueryNetIDString) Contains(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryNetIDString) ContainsIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Contains(*value)
}

func (r arcQueryNetIDString) StartsWith(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryNetIDString) StartsWithIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r arcQueryNetIDString) EndsWith(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryNetIDString) EndsWithIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r arcQueryNetIDString) Mode(value QueryMode) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryNetIDString) ModeIfPresent(value *QueryMode) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Mode(*value)
}

func (r arcQueryNetIDString) Not(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryNetIDString) NotIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r arcQueryNetIDString) HasPrefix(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r arcQueryNetIDString) HasPrefixIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r arcQueryNetIDString) HasSuffix(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r arcQueryNetIDString) HasSuffixIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type arcQueryFromPlaceBoolean struct{}

// Set the required value of FromPlace
func (r arcQueryFromPlaceBoolean) Set(value bool) arcWithPrismaFromPlaceSetParam {

	return arcWithPrismaFromPlaceSetParam{
		data: builder.Field{
			Name:  "fromPlace",
			Value: value,
		},
	}

}

// Set the optional value of FromPlace dynamically
func (r arcQueryFromPlaceBoolean) SetIfPresent(value *bool) arcWithPrismaFromPlaceSetParam {
	if value == nil {
		return arcWithPrismaFromPlaceSetParam{}
	}

	return r.Set(*value)
}

func (r arcQueryFromPlaceBoolean) Equals(value bool) arcWithPrismaFromPlaceEqualsParam {

	return arcWithPrismaFromPlaceEqualsParam{
		data: builder.Field{
			Name: "fromPlace",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r arcQueryFromPlaceBoolean) EqualsIfPresent(value *bool) arcWithPrismaFromPlaceEqualsParam {
	if value == nil {
		return arcWithPrismaFromPlaceEqualsParam{}
	}
	return r.Equals(*value)
}

func (r arcQueryFromPlaceBoolean) Order(direction SortOrder) arcDefaultParam {
	return arcDefaultParam{
		data: builder.Field{
			Name:  "fromPlace",
			Value: direction,
		},
	}
}

func (r arcQueryFromPlaceBoolean) Cursor(cursor bool) arcCursorParam {
	return arcCursorParam{
		data: builder.Field{
			Name:  "fromPlace",
			Value: cursor,
		},
	}
}

// base struct
type arcQueryPlacePlace struct{}

type arcQueryPlaceRelations struct{}

// Arc -> Place
//
// @relation
// @required
func (arcQueryPlaceRelations) Where(
	params ...PlaceWhereParam,
) arcDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return arcDefaultParam{
		data: builder.Field{
			Name: "place",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (arcQueryPlaceRelations) Fetch() arcToPlaceFindUnique {
	var v arcToPlaceFindUnique

	v.query.Operation = "query"
	v.query.Method = "place"
	v.query.Outputs = placeOutput

	return v
}

func (r arcQueryPlaceRelations) Link(
	params PlaceWhereParam,
) arcWithPrismaPlaceSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return arcWithPrismaPlaceSetParam{}
	}

	fields = append(fields, f)

	return arcWithPrismaPlaceSetParam{
		data: builder.Field{
			Name: "place",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r arcQueryPlaceRelations) Unlink() arcWithPrismaPlaceSetParam {
	var v arcWithPrismaPlaceSetParam

	v = arcWithPrismaPlaceSetParam{
		data: builder.Field{
			Name: "place",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type arcQueryPlaceIDString struct{}

// Set the required value of PlaceID
func (r arcQueryPlaceIDString) Set(value string) arcSetParam {

	return arcSetParam{
		data: builder.Field{
			Name:  "placeID",
			Value: value,
		},
	}

}

// Set the optional value of PlaceID dynamically
func (r arcQueryPlaceIDString) SetIfPresent(value *string) arcSetParam {
	if value == nil {
		return arcSetParam{}
	}

	return r.Set(*value)
}

func (r arcQueryPlaceIDString) Equals(value string) arcWithPrismaPlaceIDEqualsParam {

	return arcWithPrismaPlaceIDEqualsParam{
		data: builder.Field{
			Name: "placeID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r arcQueryPlaceIDString) EqualsIfPresent(value *string) arcWithPrismaPlaceIDEqualsParam {
	if value == nil {
		return arcWithPrismaPlaceIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r arcQueryPlaceIDString) Order(direction SortOrder) arcDefaultParam {
	return arcDefaultParam{
		data: builder.Field{
			Name:  "placeID",
			Value: direction,
		},
	}
}

func (r arcQueryPlaceIDString) Cursor(cursor string) arcCursorParam {
	return arcCursorParam{
		data: builder.Field{
			Name:  "placeID",
			Value: cursor,
		},
	}
}

func (r arcQueryPlaceIDString) In(value []string) arcDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return arcDefaultParam{
		data: builder.Field{
			Name: "placeID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r arcQueryPlaceIDString) InIfPresent(value []string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.In(value)
}

func (r arcQueryPlaceIDString) NotIn(value []string) arcDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return arcDefaultParam{
		data: builder.Field{
			Name: "placeID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r arcQueryPlaceIDString) NotInIfPresent(value []string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.NotIn(value)
}

func (r arcQueryPlaceIDString) Lt(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "placeID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryPlaceIDString) LtIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Lt(*value)
}

func (r arcQueryPlaceIDString) Lte(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "placeID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryPlaceIDString) LteIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Lte(*value)
}

func (r arcQueryPlaceIDString) Gt(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "placeID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryPlaceIDString) GtIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Gt(*value)
}

func (r arcQueryPlaceIDString) Gte(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "placeID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryPlaceIDString) GteIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Gte(*value)
}

func (r arcQueryPlaceIDString) Contains(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "placeID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryPlaceIDString) ContainsIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Contains(*value)
}

func (r arcQueryPlaceIDString) StartsWith(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "placeID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryPlaceIDString) StartsWithIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r arcQueryPlaceIDString) EndsWith(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "placeID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryPlaceIDString) EndsWithIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r arcQueryPlaceIDString) Mode(value QueryMode) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "placeID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryPlaceIDString) ModeIfPresent(value *QueryMode) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Mode(*value)
}

func (r arcQueryPlaceIDString) Not(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "placeID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryPlaceIDString) NotIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r arcQueryPlaceIDString) HasPrefix(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "placeID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r arcQueryPlaceIDString) HasPrefixIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r arcQueryPlaceIDString) HasSuffix(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "placeID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r arcQueryPlaceIDString) HasSuffixIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type arcQueryTransitionTransition struct{}

type arcQueryTransitionRelations struct{}

// Arc -> Transition
//
// @relation
// @required
func (arcQueryTransitionRelations) Where(
	params ...TransitionWhereParam,
) arcDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return arcDefaultParam{
		data: builder.Field{
			Name: "transition",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (arcQueryTransitionRelations) Fetch() arcToTransitionFindUnique {
	var v arcToTransitionFindUnique

	v.query.Operation = "query"
	v.query.Method = "transition"
	v.query.Outputs = transitionOutput

	return v
}

func (r arcQueryTransitionRelations) Link(
	params TransitionWhereParam,
) arcWithPrismaTransitionSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return arcWithPrismaTransitionSetParam{}
	}

	fields = append(fields, f)

	return arcWithPrismaTransitionSetParam{
		data: builder.Field{
			Name: "transition",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r arcQueryTransitionRelations) Unlink() arcWithPrismaTransitionSetParam {
	var v arcWithPrismaTransitionSetParam

	v = arcWithPrismaTransitionSetParam{
		data: builder.Field{
			Name: "transition",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type arcQueryTransitionIDString struct{}

// Set the required value of TransitionID
func (r arcQueryTransitionIDString) Set(value string) arcSetParam {

	return arcSetParam{
		data: builder.Field{
			Name:  "transitionID",
			Value: value,
		},
	}

}

// Set the optional value of TransitionID dynamically
func (r arcQueryTransitionIDString) SetIfPresent(value *string) arcSetParam {
	if value == nil {
		return arcSetParam{}
	}

	return r.Set(*value)
}

func (r arcQueryTransitionIDString) Equals(value string) arcWithPrismaTransitionIDEqualsParam {

	return arcWithPrismaTransitionIDEqualsParam{
		data: builder.Field{
			Name: "transitionID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r arcQueryTransitionIDString) EqualsIfPresent(value *string) arcWithPrismaTransitionIDEqualsParam {
	if value == nil {
		return arcWithPrismaTransitionIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r arcQueryTransitionIDString) Order(direction SortOrder) arcDefaultParam {
	return arcDefaultParam{
		data: builder.Field{
			Name:  "transitionID",
			Value: direction,
		},
	}
}

func (r arcQueryTransitionIDString) Cursor(cursor string) arcCursorParam {
	return arcCursorParam{
		data: builder.Field{
			Name:  "transitionID",
			Value: cursor,
		},
	}
}

func (r arcQueryTransitionIDString) In(value []string) arcDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return arcDefaultParam{
		data: builder.Field{
			Name: "transitionID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r arcQueryTransitionIDString) InIfPresent(value []string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.In(value)
}

func (r arcQueryTransitionIDString) NotIn(value []string) arcDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return arcDefaultParam{
		data: builder.Field{
			Name: "transitionID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r arcQueryTransitionIDString) NotInIfPresent(value []string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.NotIn(value)
}

func (r arcQueryTransitionIDString) Lt(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "transitionID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryTransitionIDString) LtIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Lt(*value)
}

func (r arcQueryTransitionIDString) Lte(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "transitionID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryTransitionIDString) LteIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Lte(*value)
}

func (r arcQueryTransitionIDString) Gt(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "transitionID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryTransitionIDString) GtIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Gt(*value)
}

func (r arcQueryTransitionIDString) Gte(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "transitionID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryTransitionIDString) GteIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Gte(*value)
}

func (r arcQueryTransitionIDString) Contains(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "transitionID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryTransitionIDString) ContainsIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Contains(*value)
}

func (r arcQueryTransitionIDString) StartsWith(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "transitionID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryTransitionIDString) StartsWithIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r arcQueryTransitionIDString) EndsWith(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "transitionID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryTransitionIDString) EndsWithIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r arcQueryTransitionIDString) Mode(value QueryMode) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "transitionID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryTransitionIDString) ModeIfPresent(value *QueryMode) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Mode(*value)
}

func (r arcQueryTransitionIDString) Not(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "transitionID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryTransitionIDString) NotIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r arcQueryTransitionIDString) HasPrefix(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "transitionID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r arcQueryTransitionIDString) HasPrefixIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r arcQueryTransitionIDString) HasSuffix(value string) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "transitionID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r arcQueryTransitionIDString) HasSuffixIfPresent(value *string) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type arcQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r arcQueryCreatedAtDateTime) Set(value DateTime) arcSetParam {

	return arcSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r arcQueryCreatedAtDateTime) SetIfPresent(value *DateTime) arcSetParam {
	if value == nil {
		return arcSetParam{}
	}

	return r.Set(*value)
}

func (r arcQueryCreatedAtDateTime) Equals(value DateTime) arcWithPrismaCreatedAtEqualsParam {

	return arcWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r arcQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) arcWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return arcWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r arcQueryCreatedAtDateTime) Order(direction SortOrder) arcDefaultParam {
	return arcDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r arcQueryCreatedAtDateTime) Cursor(cursor DateTime) arcCursorParam {
	return arcCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r arcQueryCreatedAtDateTime) In(value []DateTime) arcDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return arcDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r arcQueryCreatedAtDateTime) InIfPresent(value []DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.In(value)
}

func (r arcQueryCreatedAtDateTime) NotIn(value []DateTime) arcDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return arcDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r arcQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.NotIn(value)
}

func (r arcQueryCreatedAtDateTime) Lt(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryCreatedAtDateTime) LtIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Lt(*value)
}

func (r arcQueryCreatedAtDateTime) Lte(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryCreatedAtDateTime) LteIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Lte(*value)
}

func (r arcQueryCreatedAtDateTime) Gt(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryCreatedAtDateTime) GtIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Gt(*value)
}

func (r arcQueryCreatedAtDateTime) Gte(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryCreatedAtDateTime) GteIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Gte(*value)
}

func (r arcQueryCreatedAtDateTime) Not(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryCreatedAtDateTime) NotIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r arcQueryCreatedAtDateTime) Before(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r arcQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r arcQueryCreatedAtDateTime) After(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r arcQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r arcQueryCreatedAtDateTime) BeforeEquals(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r arcQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r arcQueryCreatedAtDateTime) AfterEquals(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r arcQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type arcQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r arcQueryUpdatedAtDateTime) Set(value DateTime) arcSetParam {

	return arcSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r arcQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) arcSetParam {
	if value == nil {
		return arcSetParam{}
	}

	return r.Set(*value)
}

func (r arcQueryUpdatedAtDateTime) Equals(value DateTime) arcWithPrismaUpdatedAtEqualsParam {

	return arcWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r arcQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) arcWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return arcWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r arcQueryUpdatedAtDateTime) Order(direction SortOrder) arcDefaultParam {
	return arcDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r arcQueryUpdatedAtDateTime) Cursor(cursor DateTime) arcCursorParam {
	return arcCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r arcQueryUpdatedAtDateTime) In(value []DateTime) arcDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return arcDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r arcQueryUpdatedAtDateTime) InIfPresent(value []DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.In(value)
}

func (r arcQueryUpdatedAtDateTime) NotIn(value []DateTime) arcDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return arcDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r arcQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.NotIn(value)
}

func (r arcQueryUpdatedAtDateTime) Lt(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Lt(*value)
}

func (r arcQueryUpdatedAtDateTime) Lte(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Lte(*value)
}

func (r arcQueryUpdatedAtDateTime) Gt(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Gt(*value)
}

func (r arcQueryUpdatedAtDateTime) Gte(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Gte(*value)
}

func (r arcQueryUpdatedAtDateTime) Not(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r arcQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r arcQueryUpdatedAtDateTime) Before(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r arcQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r arcQueryUpdatedAtDateTime) After(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r arcQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r arcQueryUpdatedAtDateTime) BeforeEquals(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r arcQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r arcQueryUpdatedAtDateTime) AfterEquals(value DateTime) arcDefaultParam {

	return arcDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r arcQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) arcDefaultParam {
	if value == nil {
		return arcDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// DevicesOnNets acts as a namespaces to access query methods for the DevicesOnNets model
var DevicesOnNets = devicesOnNetsQuery{}

// devicesOnNetsQuery exposes query functions for the devicesOnNets model
type devicesOnNetsQuery struct {
	Device devicesOnNetsQueryDeviceRelations

	// DeviceID
	//
	// @required
	DeviceID devicesOnNetsQueryDeviceIDString

	Net devicesOnNetsQueryNetRelations

	// NetID
	//
	// @required
	NetID devicesOnNetsQueryNetIDString
}

func (devicesOnNetsQuery) Not(params ...DevicesOnNetsWhereParam) devicesOnNetsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (devicesOnNetsQuery) Or(params ...DevicesOnNetsWhereParam) devicesOnNetsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (devicesOnNetsQuery) And(params ...DevicesOnNetsWhereParam) devicesOnNetsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (devicesOnNetsQuery) DeviceIDNetID(
	_deviceID DevicesOnNetsWithPrismaDeviceIDWhereParam,

	_netID DevicesOnNetsWithPrismaNetIDWhereParam,
) DevicesOnNetsEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _deviceID.field())
	fields = append(fields, _netID.field())

	return devicesOnNetsEqualsUniqueParam{
		data: builder.Field{
			Name:   "deviceID_netID",
			Fields: builder.TransformEquals(fields),
		},
	}
}

// base struct
type devicesOnNetsQueryDeviceDevice struct{}

type devicesOnNetsQueryDeviceRelations struct{}

// DevicesOnNets -> Device
//
// @relation
// @required
func (devicesOnNetsQueryDeviceRelations) Where(
	params ...DeviceWhereParam,
) devicesOnNetsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "device",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (devicesOnNetsQueryDeviceRelations) Fetch() devicesOnNetsToDeviceFindUnique {
	var v devicesOnNetsToDeviceFindUnique

	v.query.Operation = "query"
	v.query.Method = "device"
	v.query.Outputs = deviceOutput

	return v
}

func (r devicesOnNetsQueryDeviceRelations) Link(
	params DeviceWhereParam,
) devicesOnNetsWithPrismaDeviceSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return devicesOnNetsWithPrismaDeviceSetParam{}
	}

	fields = append(fields, f)

	return devicesOnNetsWithPrismaDeviceSetParam{
		data: builder.Field{
			Name: "device",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r devicesOnNetsQueryDeviceRelations) Unlink() devicesOnNetsWithPrismaDeviceSetParam {
	var v devicesOnNetsWithPrismaDeviceSetParam

	v = devicesOnNetsWithPrismaDeviceSetParam{
		data: builder.Field{
			Name: "device",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type devicesOnNetsQueryDeviceIDString struct{}

// Set the required value of DeviceID
func (r devicesOnNetsQueryDeviceIDString) Set(value string) devicesOnNetsSetParam {

	return devicesOnNetsSetParam{
		data: builder.Field{
			Name:  "deviceID",
			Value: value,
		},
	}

}

// Set the optional value of DeviceID dynamically
func (r devicesOnNetsQueryDeviceIDString) SetIfPresent(value *string) devicesOnNetsSetParam {
	if value == nil {
		return devicesOnNetsSetParam{}
	}

	return r.Set(*value)
}

func (r devicesOnNetsQueryDeviceIDString) Equals(value string) devicesOnNetsWithPrismaDeviceIDEqualsParam {

	return devicesOnNetsWithPrismaDeviceIDEqualsParam{
		data: builder.Field{
			Name: "deviceID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryDeviceIDString) EqualsIfPresent(value *string) devicesOnNetsWithPrismaDeviceIDEqualsParam {
	if value == nil {
		return devicesOnNetsWithPrismaDeviceIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r devicesOnNetsQueryDeviceIDString) Order(direction SortOrder) devicesOnNetsDefaultParam {
	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name:  "deviceID",
			Value: direction,
		},
	}
}

func (r devicesOnNetsQueryDeviceIDString) Cursor(cursor string) devicesOnNetsCursorParam {
	return devicesOnNetsCursorParam{
		data: builder.Field{
			Name:  "deviceID",
			Value: cursor,
		},
	}
}

func (r devicesOnNetsQueryDeviceIDString) In(value []string) devicesOnNetsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "deviceID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryDeviceIDString) InIfPresent(value []string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.In(value)
}

func (r devicesOnNetsQueryDeviceIDString) NotIn(value []string) devicesOnNetsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "deviceID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryDeviceIDString) NotInIfPresent(value []string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r devicesOnNetsQueryDeviceIDString) Lt(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "deviceID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryDeviceIDString) LtIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r devicesOnNetsQueryDeviceIDString) Lte(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "deviceID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryDeviceIDString) LteIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r devicesOnNetsQueryDeviceIDString) Gt(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "deviceID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryDeviceIDString) GtIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r devicesOnNetsQueryDeviceIDString) Gte(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "deviceID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryDeviceIDString) GteIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r devicesOnNetsQueryDeviceIDString) Contains(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "deviceID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryDeviceIDString) ContainsIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r devicesOnNetsQueryDeviceIDString) StartsWith(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "deviceID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryDeviceIDString) StartsWithIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r devicesOnNetsQueryDeviceIDString) EndsWith(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "deviceID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryDeviceIDString) EndsWithIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r devicesOnNetsQueryDeviceIDString) Mode(value QueryMode) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "deviceID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryDeviceIDString) ModeIfPresent(value *QueryMode) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r devicesOnNetsQueryDeviceIDString) Not(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "deviceID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryDeviceIDString) NotIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r devicesOnNetsQueryDeviceIDString) HasPrefix(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "deviceID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r devicesOnNetsQueryDeviceIDString) HasPrefixIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r devicesOnNetsQueryDeviceIDString) HasSuffix(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "deviceID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r devicesOnNetsQueryDeviceIDString) HasSuffixIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type devicesOnNetsQueryNetNet struct{}

type devicesOnNetsQueryNetRelations struct{}

// DevicesOnNets -> Net
//
// @relation
// @required
func (devicesOnNetsQueryNetRelations) Where(
	params ...NetWhereParam,
) devicesOnNetsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "net",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (devicesOnNetsQueryNetRelations) Fetch() devicesOnNetsToNetFindUnique {
	var v devicesOnNetsToNetFindUnique

	v.query.Operation = "query"
	v.query.Method = "net"
	v.query.Outputs = netOutput

	return v
}

func (r devicesOnNetsQueryNetRelations) Link(
	params NetWhereParam,
) devicesOnNetsWithPrismaNetSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return devicesOnNetsWithPrismaNetSetParam{}
	}

	fields = append(fields, f)

	return devicesOnNetsWithPrismaNetSetParam{
		data: builder.Field{
			Name: "net",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r devicesOnNetsQueryNetRelations) Unlink() devicesOnNetsWithPrismaNetSetParam {
	var v devicesOnNetsWithPrismaNetSetParam

	v = devicesOnNetsWithPrismaNetSetParam{
		data: builder.Field{
			Name: "net",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type devicesOnNetsQueryNetIDString struct{}

// Set the required value of NetID
func (r devicesOnNetsQueryNetIDString) Set(value string) devicesOnNetsSetParam {

	return devicesOnNetsSetParam{
		data: builder.Field{
			Name:  "netID",
			Value: value,
		},
	}

}

// Set the optional value of NetID dynamically
func (r devicesOnNetsQueryNetIDString) SetIfPresent(value *string) devicesOnNetsSetParam {
	if value == nil {
		return devicesOnNetsSetParam{}
	}

	return r.Set(*value)
}

func (r devicesOnNetsQueryNetIDString) Equals(value string) devicesOnNetsWithPrismaNetIDEqualsParam {

	return devicesOnNetsWithPrismaNetIDEqualsParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryNetIDString) EqualsIfPresent(value *string) devicesOnNetsWithPrismaNetIDEqualsParam {
	if value == nil {
		return devicesOnNetsWithPrismaNetIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r devicesOnNetsQueryNetIDString) Order(direction SortOrder) devicesOnNetsDefaultParam {
	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name:  "netID",
			Value: direction,
		},
	}
}

func (r devicesOnNetsQueryNetIDString) Cursor(cursor string) devicesOnNetsCursorParam {
	return devicesOnNetsCursorParam{
		data: builder.Field{
			Name:  "netID",
			Value: cursor,
		},
	}
}

func (r devicesOnNetsQueryNetIDString) In(value []string) devicesOnNetsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryNetIDString) InIfPresent(value []string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.In(value)
}

func (r devicesOnNetsQueryNetIDString) NotIn(value []string) devicesOnNetsDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryNetIDString) NotInIfPresent(value []string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r devicesOnNetsQueryNetIDString) Lt(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryNetIDString) LtIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r devicesOnNetsQueryNetIDString) Lte(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryNetIDString) LteIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r devicesOnNetsQueryNetIDString) Gt(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryNetIDString) GtIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r devicesOnNetsQueryNetIDString) Gte(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryNetIDString) GteIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r devicesOnNetsQueryNetIDString) Contains(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryNetIDString) ContainsIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r devicesOnNetsQueryNetIDString) StartsWith(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryNetIDString) StartsWithIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r devicesOnNetsQueryNetIDString) EndsWith(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryNetIDString) EndsWithIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r devicesOnNetsQueryNetIDString) Mode(value QueryMode) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryNetIDString) ModeIfPresent(value *QueryMode) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r devicesOnNetsQueryNetIDString) Not(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r devicesOnNetsQueryNetIDString) NotIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r devicesOnNetsQueryNetIDString) HasPrefix(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r devicesOnNetsQueryNetIDString) HasPrefixIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r devicesOnNetsQueryNetIDString) HasSuffix(value string) devicesOnNetsDefaultParam {

	return devicesOnNetsDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r devicesOnNetsQueryNetIDString) HasSuffixIfPresent(value *string) devicesOnNetsDefaultParam {
	if value == nil {
		return devicesOnNetsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// Field acts as a namespaces to access query methods for the Field model
var Field = fieldQuery{}

// fieldQuery exposes query functions for the field model
type fieldQuery struct {

	// ID
	//
	// @required
	ID fieldQueryIDString

	// Name
	//
	// @required
	Name fieldQueryNameString

	// Type
	//
	// @required
	Type fieldQueryTypeString

	// Condition
	//
	// @optional
	Condition fieldQueryConditionString

	Event fieldQueryEventRelations

	// EventID
	//
	// @required
	EventID fieldQueryEventIDString

	// CreatedAt
	//
	// @required
	CreatedAt fieldQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt fieldQueryUpdatedAtDateTime

	Constants fieldQueryConstantsRelations
}

func (fieldQuery) Not(params ...FieldWhereParam) fieldDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (fieldQuery) Or(params ...FieldWhereParam) fieldDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (fieldQuery) And(params ...FieldWhereParam) fieldDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type fieldQueryIDString struct{}

// Set the required value of ID
func (r fieldQueryIDString) Set(value string) fieldSetParam {

	return fieldSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r fieldQueryIDString) SetIfPresent(value *string) fieldSetParam {
	if value == nil {
		return fieldSetParam{}
	}

	return r.Set(*value)
}

func (r fieldQueryIDString) Equals(value string) fieldWithPrismaIDEqualsUniqueParam {

	return fieldWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryIDString) EqualsIfPresent(value *string) fieldWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return fieldWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r fieldQueryIDString) Order(direction SortOrder) fieldDefaultParam {
	return fieldDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r fieldQueryIDString) Cursor(cursor string) fieldCursorParam {
	return fieldCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r fieldQueryIDString) In(value []string) fieldParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return fieldParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fieldQueryIDString) InIfPresent(value []string) fieldParamUnique {
	if value == nil {
		return fieldParamUnique{}
	}
	return r.In(value)
}

func (r fieldQueryIDString) NotIn(value []string) fieldParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return fieldParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fieldQueryIDString) NotInIfPresent(value []string) fieldParamUnique {
	if value == nil {
		return fieldParamUnique{}
	}
	return r.NotIn(value)
}

func (r fieldQueryIDString) Lt(value string) fieldParamUnique {

	return fieldParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryIDString) LtIfPresent(value *string) fieldParamUnique {
	if value == nil {
		return fieldParamUnique{}
	}
	return r.Lt(*value)
}

func (r fieldQueryIDString) Lte(value string) fieldParamUnique {

	return fieldParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryIDString) LteIfPresent(value *string) fieldParamUnique {
	if value == nil {
		return fieldParamUnique{}
	}
	return r.Lte(*value)
}

func (r fieldQueryIDString) Gt(value string) fieldParamUnique {

	return fieldParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryIDString) GtIfPresent(value *string) fieldParamUnique {
	if value == nil {
		return fieldParamUnique{}
	}
	return r.Gt(*value)
}

func (r fieldQueryIDString) Gte(value string) fieldParamUnique {

	return fieldParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryIDString) GteIfPresent(value *string) fieldParamUnique {
	if value == nil {
		return fieldParamUnique{}
	}
	return r.Gte(*value)
}

func (r fieldQueryIDString) Contains(value string) fieldParamUnique {

	return fieldParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryIDString) ContainsIfPresent(value *string) fieldParamUnique {
	if value == nil {
		return fieldParamUnique{}
	}
	return r.Contains(*value)
}

func (r fieldQueryIDString) StartsWith(value string) fieldParamUnique {

	return fieldParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryIDString) StartsWithIfPresent(value *string) fieldParamUnique {
	if value == nil {
		return fieldParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r fieldQueryIDString) EndsWith(value string) fieldParamUnique {

	return fieldParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryIDString) EndsWithIfPresent(value *string) fieldParamUnique {
	if value == nil {
		return fieldParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r fieldQueryIDString) Mode(value QueryMode) fieldParamUnique {

	return fieldParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryIDString) ModeIfPresent(value *QueryMode) fieldParamUnique {
	if value == nil {
		return fieldParamUnique{}
	}
	return r.Mode(*value)
}

func (r fieldQueryIDString) Not(value string) fieldParamUnique {

	return fieldParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryIDString) NotIfPresent(value *string) fieldParamUnique {
	if value == nil {
		return fieldParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r fieldQueryIDString) HasPrefix(value string) fieldParamUnique {

	return fieldParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r fieldQueryIDString) HasPrefixIfPresent(value *string) fieldParamUnique {
	if value == nil {
		return fieldParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r fieldQueryIDString) HasSuffix(value string) fieldParamUnique {

	return fieldParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r fieldQueryIDString) HasSuffixIfPresent(value *string) fieldParamUnique {
	if value == nil {
		return fieldParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type fieldQueryNameString struct{}

// Set the required value of Name
func (r fieldQueryNameString) Set(value string) fieldWithPrismaNameSetParam {

	return fieldWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r fieldQueryNameString) SetIfPresent(value *string) fieldWithPrismaNameSetParam {
	if value == nil {
		return fieldWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r fieldQueryNameString) Equals(value string) fieldWithPrismaNameEqualsParam {

	return fieldWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryNameString) EqualsIfPresent(value *string) fieldWithPrismaNameEqualsParam {
	if value == nil {
		return fieldWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r fieldQueryNameString) Order(direction SortOrder) fieldDefaultParam {
	return fieldDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r fieldQueryNameString) Cursor(cursor string) fieldCursorParam {
	return fieldCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r fieldQueryNameString) In(value []string) fieldDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fieldQueryNameString) InIfPresent(value []string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.In(value)
}

func (r fieldQueryNameString) NotIn(value []string) fieldDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fieldQueryNameString) NotInIfPresent(value []string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.NotIn(value)
}

func (r fieldQueryNameString) Lt(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryNameString) LtIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Lt(*value)
}

func (r fieldQueryNameString) Lte(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryNameString) LteIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Lte(*value)
}

func (r fieldQueryNameString) Gt(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryNameString) GtIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Gt(*value)
}

func (r fieldQueryNameString) Gte(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryNameString) GteIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Gte(*value)
}

func (r fieldQueryNameString) Contains(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryNameString) ContainsIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Contains(*value)
}

func (r fieldQueryNameString) StartsWith(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryNameString) StartsWithIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r fieldQueryNameString) EndsWith(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryNameString) EndsWithIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r fieldQueryNameString) Mode(value QueryMode) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryNameString) ModeIfPresent(value *QueryMode) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Mode(*value)
}

func (r fieldQueryNameString) Not(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryNameString) NotIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r fieldQueryNameString) HasPrefix(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r fieldQueryNameString) HasPrefixIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r fieldQueryNameString) HasSuffix(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r fieldQueryNameString) HasSuffixIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type fieldQueryTypeString struct{}

// Set the required value of Type
func (r fieldQueryTypeString) Set(value string) fieldWithPrismaTypeSetParam {

	return fieldWithPrismaTypeSetParam{
		data: builder.Field{
			Name:  "type",
			Value: value,
		},
	}

}

// Set the optional value of Type dynamically
func (r fieldQueryTypeString) SetIfPresent(value *string) fieldWithPrismaTypeSetParam {
	if value == nil {
		return fieldWithPrismaTypeSetParam{}
	}

	return r.Set(*value)
}

func (r fieldQueryTypeString) Equals(value string) fieldWithPrismaTypeEqualsParam {

	return fieldWithPrismaTypeEqualsParam{
		data: builder.Field{
			Name: "type",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryTypeString) EqualsIfPresent(value *string) fieldWithPrismaTypeEqualsParam {
	if value == nil {
		return fieldWithPrismaTypeEqualsParam{}
	}
	return r.Equals(*value)
}

func (r fieldQueryTypeString) Order(direction SortOrder) fieldDefaultParam {
	return fieldDefaultParam{
		data: builder.Field{
			Name:  "type",
			Value: direction,
		},
	}
}

func (r fieldQueryTypeString) Cursor(cursor string) fieldCursorParam {
	return fieldCursorParam{
		data: builder.Field{
			Name:  "type",
			Value: cursor,
		},
	}
}

func (r fieldQueryTypeString) In(value []string) fieldDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name: "type",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fieldQueryTypeString) InIfPresent(value []string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.In(value)
}

func (r fieldQueryTypeString) NotIn(value []string) fieldDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name: "type",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fieldQueryTypeString) NotInIfPresent(value []string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.NotIn(value)
}

func (r fieldQueryTypeString) Lt(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "type",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryTypeString) LtIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Lt(*value)
}

func (r fieldQueryTypeString) Lte(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "type",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryTypeString) LteIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Lte(*value)
}

func (r fieldQueryTypeString) Gt(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "type",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryTypeString) GtIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Gt(*value)
}

func (r fieldQueryTypeString) Gte(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "type",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryTypeString) GteIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Gte(*value)
}

func (r fieldQueryTypeString) Contains(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "type",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryTypeString) ContainsIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Contains(*value)
}

func (r fieldQueryTypeString) StartsWith(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "type",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryTypeString) StartsWithIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r fieldQueryTypeString) EndsWith(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "type",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryTypeString) EndsWithIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r fieldQueryTypeString) Mode(value QueryMode) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "type",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryTypeString) ModeIfPresent(value *QueryMode) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Mode(*value)
}

func (r fieldQueryTypeString) Not(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "type",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryTypeString) NotIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r fieldQueryTypeString) HasPrefix(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "type",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r fieldQueryTypeString) HasPrefixIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r fieldQueryTypeString) HasSuffix(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "type",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r fieldQueryTypeString) HasSuffixIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type fieldQueryConditionString struct{}

// Set the optional value of Condition
func (r fieldQueryConditionString) Set(value string) fieldSetParam {

	return fieldSetParam{
		data: builder.Field{
			Name:  "condition",
			Value: value,
		},
	}

}

// Set the optional value of Condition dynamically
func (r fieldQueryConditionString) SetIfPresent(value *string) fieldSetParam {
	if value == nil {
		return fieldSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Condition dynamically
func (r fieldQueryConditionString) SetOptional(value *string) fieldSetParam {
	if value == nil {

		var v *string
		return fieldSetParam{
			data: builder.Field{
				Name:  "condition",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r fieldQueryConditionString) Equals(value string) fieldWithPrismaConditionEqualsParam {

	return fieldWithPrismaConditionEqualsParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryConditionString) EqualsIfPresent(value *string) fieldWithPrismaConditionEqualsParam {
	if value == nil {
		return fieldWithPrismaConditionEqualsParam{}
	}
	return r.Equals(*value)
}

func (r fieldQueryConditionString) EqualsOptional(value *string) fieldDefaultParam {
	return fieldDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryConditionString) IsNull() fieldDefaultParam {
	var str *string = nil
	return fieldDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r fieldQueryConditionString) Order(direction SortOrder) fieldDefaultParam {
	return fieldDefaultParam{
		data: builder.Field{
			Name:  "condition",
			Value: direction,
		},
	}
}

func (r fieldQueryConditionString) Cursor(cursor string) fieldCursorParam {
	return fieldCursorParam{
		data: builder.Field{
			Name:  "condition",
			Value: cursor,
		},
	}
}

func (r fieldQueryConditionString) In(value []string) fieldDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fieldQueryConditionString) InIfPresent(value []string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.In(value)
}

func (r fieldQueryConditionString) NotIn(value []string) fieldDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fieldQueryConditionString) NotInIfPresent(value []string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.NotIn(value)
}

func (r fieldQueryConditionString) Lt(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryConditionString) LtIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Lt(*value)
}

func (r fieldQueryConditionString) Lte(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryConditionString) LteIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Lte(*value)
}

func (r fieldQueryConditionString) Gt(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryConditionString) GtIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Gt(*value)
}

func (r fieldQueryConditionString) Gte(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryConditionString) GteIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Gte(*value)
}

func (r fieldQueryConditionString) Contains(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryConditionString) ContainsIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Contains(*value)
}

func (r fieldQueryConditionString) StartsWith(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryConditionString) StartsWithIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r fieldQueryConditionString) EndsWith(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryConditionString) EndsWithIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r fieldQueryConditionString) Mode(value QueryMode) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryConditionString) ModeIfPresent(value *QueryMode) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Mode(*value)
}

func (r fieldQueryConditionString) Not(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryConditionString) NotIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r fieldQueryConditionString) HasPrefix(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r fieldQueryConditionString) HasPrefixIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r fieldQueryConditionString) HasSuffix(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "condition",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r fieldQueryConditionString) HasSuffixIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type fieldQueryEventEvent struct{}

type fieldQueryEventRelations struct{}

// Field -> Event
//
// @relation
// @required
func (fieldQueryEventRelations) Where(
	params ...EventWhereParam,
) fieldDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name: "event",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (fieldQueryEventRelations) Fetch() fieldToEventFindUnique {
	var v fieldToEventFindUnique

	v.query.Operation = "query"
	v.query.Method = "event"
	v.query.Outputs = eventOutput

	return v
}

func (r fieldQueryEventRelations) Link(
	params EventWhereParam,
) fieldWithPrismaEventSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return fieldWithPrismaEventSetParam{}
	}

	fields = append(fields, f)

	return fieldWithPrismaEventSetParam{
		data: builder.Field{
			Name: "event",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r fieldQueryEventRelations) Unlink() fieldWithPrismaEventSetParam {
	var v fieldWithPrismaEventSetParam

	v = fieldWithPrismaEventSetParam{
		data: builder.Field{
			Name: "event",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type fieldQueryEventIDString struct{}

// Set the required value of EventID
func (r fieldQueryEventIDString) Set(value string) fieldSetParam {

	return fieldSetParam{
		data: builder.Field{
			Name:  "eventID",
			Value: value,
		},
	}

}

// Set the optional value of EventID dynamically
func (r fieldQueryEventIDString) SetIfPresent(value *string) fieldSetParam {
	if value == nil {
		return fieldSetParam{}
	}

	return r.Set(*value)
}

func (r fieldQueryEventIDString) Equals(value string) fieldWithPrismaEventIDEqualsParam {

	return fieldWithPrismaEventIDEqualsParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryEventIDString) EqualsIfPresent(value *string) fieldWithPrismaEventIDEqualsParam {
	if value == nil {
		return fieldWithPrismaEventIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r fieldQueryEventIDString) Order(direction SortOrder) fieldDefaultParam {
	return fieldDefaultParam{
		data: builder.Field{
			Name:  "eventID",
			Value: direction,
		},
	}
}

func (r fieldQueryEventIDString) Cursor(cursor string) fieldCursorParam {
	return fieldCursorParam{
		data: builder.Field{
			Name:  "eventID",
			Value: cursor,
		},
	}
}

func (r fieldQueryEventIDString) In(value []string) fieldDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fieldQueryEventIDString) InIfPresent(value []string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.In(value)
}

func (r fieldQueryEventIDString) NotIn(value []string) fieldDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fieldQueryEventIDString) NotInIfPresent(value []string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.NotIn(value)
}

func (r fieldQueryEventIDString) Lt(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryEventIDString) LtIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Lt(*value)
}

func (r fieldQueryEventIDString) Lte(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryEventIDString) LteIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Lte(*value)
}

func (r fieldQueryEventIDString) Gt(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryEventIDString) GtIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Gt(*value)
}

func (r fieldQueryEventIDString) Gte(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryEventIDString) GteIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Gte(*value)
}

func (r fieldQueryEventIDString) Contains(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryEventIDString) ContainsIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Contains(*value)
}

func (r fieldQueryEventIDString) StartsWith(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryEventIDString) StartsWithIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r fieldQueryEventIDString) EndsWith(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryEventIDString) EndsWithIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r fieldQueryEventIDString) Mode(value QueryMode) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryEventIDString) ModeIfPresent(value *QueryMode) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Mode(*value)
}

func (r fieldQueryEventIDString) Not(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryEventIDString) NotIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r fieldQueryEventIDString) HasPrefix(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r fieldQueryEventIDString) HasPrefixIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r fieldQueryEventIDString) HasSuffix(value string) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r fieldQueryEventIDString) HasSuffixIfPresent(value *string) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type fieldQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r fieldQueryCreatedAtDateTime) Set(value DateTime) fieldSetParam {

	return fieldSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r fieldQueryCreatedAtDateTime) SetIfPresent(value *DateTime) fieldSetParam {
	if value == nil {
		return fieldSetParam{}
	}

	return r.Set(*value)
}

func (r fieldQueryCreatedAtDateTime) Equals(value DateTime) fieldWithPrismaCreatedAtEqualsParam {

	return fieldWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) fieldWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return fieldWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r fieldQueryCreatedAtDateTime) Order(direction SortOrder) fieldDefaultParam {
	return fieldDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r fieldQueryCreatedAtDateTime) Cursor(cursor DateTime) fieldCursorParam {
	return fieldCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r fieldQueryCreatedAtDateTime) In(value []DateTime) fieldDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fieldQueryCreatedAtDateTime) InIfPresent(value []DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.In(value)
}

func (r fieldQueryCreatedAtDateTime) NotIn(value []DateTime) fieldDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fieldQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.NotIn(value)
}

func (r fieldQueryCreatedAtDateTime) Lt(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryCreatedAtDateTime) LtIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Lt(*value)
}

func (r fieldQueryCreatedAtDateTime) Lte(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryCreatedAtDateTime) LteIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Lte(*value)
}

func (r fieldQueryCreatedAtDateTime) Gt(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryCreatedAtDateTime) GtIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Gt(*value)
}

func (r fieldQueryCreatedAtDateTime) Gte(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryCreatedAtDateTime) GteIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Gte(*value)
}

func (r fieldQueryCreatedAtDateTime) Not(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryCreatedAtDateTime) NotIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r fieldQueryCreatedAtDateTime) Before(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r fieldQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r fieldQueryCreatedAtDateTime) After(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r fieldQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r fieldQueryCreatedAtDateTime) BeforeEquals(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r fieldQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r fieldQueryCreatedAtDateTime) AfterEquals(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r fieldQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type fieldQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r fieldQueryUpdatedAtDateTime) Set(value DateTime) fieldSetParam {

	return fieldSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r fieldQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) fieldSetParam {
	if value == nil {
		return fieldSetParam{}
	}

	return r.Set(*value)
}

func (r fieldQueryUpdatedAtDateTime) Equals(value DateTime) fieldWithPrismaUpdatedAtEqualsParam {

	return fieldWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) fieldWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return fieldWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r fieldQueryUpdatedAtDateTime) Order(direction SortOrder) fieldDefaultParam {
	return fieldDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r fieldQueryUpdatedAtDateTime) Cursor(cursor DateTime) fieldCursorParam {
	return fieldCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r fieldQueryUpdatedAtDateTime) In(value []DateTime) fieldDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fieldQueryUpdatedAtDateTime) InIfPresent(value []DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.In(value)
}

func (r fieldQueryUpdatedAtDateTime) NotIn(value []DateTime) fieldDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fieldQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.NotIn(value)
}

func (r fieldQueryUpdatedAtDateTime) Lt(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Lt(*value)
}

func (r fieldQueryUpdatedAtDateTime) Lte(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Lte(*value)
}

func (r fieldQueryUpdatedAtDateTime) Gt(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Gt(*value)
}

func (r fieldQueryUpdatedAtDateTime) Gte(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Gte(*value)
}

func (r fieldQueryUpdatedAtDateTime) Not(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r fieldQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r fieldQueryUpdatedAtDateTime) Before(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r fieldQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r fieldQueryUpdatedAtDateTime) After(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r fieldQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r fieldQueryUpdatedAtDateTime) BeforeEquals(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r fieldQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r fieldQueryUpdatedAtDateTime) AfterEquals(value DateTime) fieldDefaultParam {

	return fieldDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r fieldQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) fieldDefaultParam {
	if value == nil {
		return fieldDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type fieldQueryConstantsConstant struct{}

type fieldQueryConstantsRelations struct{}

// Field -> Constants
//
// @relation
// @required
func (fieldQueryConstantsRelations) Some(
	params ...ConstantWhereParam,
) fieldDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name: "constants",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Field -> Constants
//
// @relation
// @required
func (fieldQueryConstantsRelations) Every(
	params ...ConstantWhereParam,
) fieldDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return fieldDefaultParam{
		data: builder.Field{
			Name: "constants",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (fieldQueryConstantsRelations) Fetch(

	params ...ConstantWhereParam,

) fieldToConstantsFindMany {
	var v fieldToConstantsFindMany

	v.query.Operation = "query"
	v.query.Method = "constants"
	v.query.Outputs = constantOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r fieldQueryConstantsRelations) Link(
	params ...ConstantWhereParam,
) fieldSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return fieldSetParam{
		data: builder.Field{
			Name: "constants",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r fieldQueryConstantsRelations) Unlink(
	params ...ConstantWhereParam,
) fieldSetParam {
	var v fieldSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = fieldSetParam{
		data: builder.Field{
			Name: "constants",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// Event acts as a namespaces to access query methods for the Event model
var Event = eventQuery{}

// eventQuery exposes query functions for the event model
type eventQuery struct {

	// ID
	//
	// @required
	ID eventQueryIDString

	// Name
	//
	// @required
	Name eventQueryNameString

	// Description
	//
	// @optional
	Description eventQueryDescriptionString

	Transitions eventQueryTransitionsRelations

	// CreatedAt
	//
	// @required
	CreatedAt eventQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt eventQueryUpdatedAtDateTime

	Fields eventQueryFieldsRelations

	Commands eventQueryCommandsRelations

	Data eventQueryDataRelations

	// PlaceInterfaceID
	//
	// @optional
	PlaceInterfaceID eventQueryPlaceInterfaceIDString

	TransitionInterface eventQueryTransitionInterfaceRelations

	// TransitionInterfaceID
	//
	// @optional
	TransitionInterfaceID eventQueryTransitionInterfaceIDString
}

func (eventQuery) Not(params ...EventWhereParam) eventDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return eventDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (eventQuery) Or(params ...EventWhereParam) eventDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return eventDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (eventQuery) And(params ...EventWhereParam) eventDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return eventDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type eventQueryIDString struct{}

// Set the required value of ID
func (r eventQueryIDString) Set(value string) eventSetParam {

	return eventSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r eventQueryIDString) SetIfPresent(value *string) eventSetParam {
	if value == nil {
		return eventSetParam{}
	}

	return r.Set(*value)
}

func (r eventQueryIDString) Equals(value string) eventWithPrismaIDEqualsUniqueParam {

	return eventWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r eventQueryIDString) EqualsIfPresent(value *string) eventWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return eventWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r eventQueryIDString) Order(direction SortOrder) eventDefaultParam {
	return eventDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r eventQueryIDString) Cursor(cursor string) eventCursorParam {
	return eventCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r eventQueryIDString) In(value []string) eventParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return eventParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r eventQueryIDString) InIfPresent(value []string) eventParamUnique {
	if value == nil {
		return eventParamUnique{}
	}
	return r.In(value)
}

func (r eventQueryIDString) NotIn(value []string) eventParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return eventParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r eventQueryIDString) NotInIfPresent(value []string) eventParamUnique {
	if value == nil {
		return eventParamUnique{}
	}
	return r.NotIn(value)
}

func (r eventQueryIDString) Lt(value string) eventParamUnique {

	return eventParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryIDString) LtIfPresent(value *string) eventParamUnique {
	if value == nil {
		return eventParamUnique{}
	}
	return r.Lt(*value)
}

func (r eventQueryIDString) Lte(value string) eventParamUnique {

	return eventParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryIDString) LteIfPresent(value *string) eventParamUnique {
	if value == nil {
		return eventParamUnique{}
	}
	return r.Lte(*value)
}

func (r eventQueryIDString) Gt(value string) eventParamUnique {

	return eventParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryIDString) GtIfPresent(value *string) eventParamUnique {
	if value == nil {
		return eventParamUnique{}
	}
	return r.Gt(*value)
}

func (r eventQueryIDString) Gte(value string) eventParamUnique {

	return eventParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryIDString) GteIfPresent(value *string) eventParamUnique {
	if value == nil {
		return eventParamUnique{}
	}
	return r.Gte(*value)
}

func (r eventQueryIDString) Contains(value string) eventParamUnique {

	return eventParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryIDString) ContainsIfPresent(value *string) eventParamUnique {
	if value == nil {
		return eventParamUnique{}
	}
	return r.Contains(*value)
}

func (r eventQueryIDString) StartsWith(value string) eventParamUnique {

	return eventParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryIDString) StartsWithIfPresent(value *string) eventParamUnique {
	if value == nil {
		return eventParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r eventQueryIDString) EndsWith(value string) eventParamUnique {

	return eventParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryIDString) EndsWithIfPresent(value *string) eventParamUnique {
	if value == nil {
		return eventParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r eventQueryIDString) Mode(value QueryMode) eventParamUnique {

	return eventParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryIDString) ModeIfPresent(value *QueryMode) eventParamUnique {
	if value == nil {
		return eventParamUnique{}
	}
	return r.Mode(*value)
}

func (r eventQueryIDString) Not(value string) eventParamUnique {

	return eventParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryIDString) NotIfPresent(value *string) eventParamUnique {
	if value == nil {
		return eventParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r eventQueryIDString) HasPrefix(value string) eventParamUnique {

	return eventParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r eventQueryIDString) HasPrefixIfPresent(value *string) eventParamUnique {
	if value == nil {
		return eventParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r eventQueryIDString) HasSuffix(value string) eventParamUnique {

	return eventParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r eventQueryIDString) HasSuffixIfPresent(value *string) eventParamUnique {
	if value == nil {
		return eventParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type eventQueryNameString struct{}

// Set the required value of Name
func (r eventQueryNameString) Set(value string) eventWithPrismaNameSetParam {

	return eventWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r eventQueryNameString) SetIfPresent(value *string) eventWithPrismaNameSetParam {
	if value == nil {
		return eventWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r eventQueryNameString) Equals(value string) eventWithPrismaNameEqualsParam {

	return eventWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r eventQueryNameString) EqualsIfPresent(value *string) eventWithPrismaNameEqualsParam {
	if value == nil {
		return eventWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r eventQueryNameString) Order(direction SortOrder) eventDefaultParam {
	return eventDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r eventQueryNameString) Cursor(cursor string) eventCursorParam {
	return eventCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r eventQueryNameString) In(value []string) eventDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r eventQueryNameString) InIfPresent(value []string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.In(value)
}

func (r eventQueryNameString) NotIn(value []string) eventDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r eventQueryNameString) NotInIfPresent(value []string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.NotIn(value)
}

func (r eventQueryNameString) Lt(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryNameString) LtIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Lt(*value)
}

func (r eventQueryNameString) Lte(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryNameString) LteIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Lte(*value)
}

func (r eventQueryNameString) Gt(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryNameString) GtIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Gt(*value)
}

func (r eventQueryNameString) Gte(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryNameString) GteIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Gte(*value)
}

func (r eventQueryNameString) Contains(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryNameString) ContainsIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Contains(*value)
}

func (r eventQueryNameString) StartsWith(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryNameString) StartsWithIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r eventQueryNameString) EndsWith(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryNameString) EndsWithIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r eventQueryNameString) Mode(value QueryMode) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryNameString) ModeIfPresent(value *QueryMode) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Mode(*value)
}

func (r eventQueryNameString) Not(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryNameString) NotIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r eventQueryNameString) HasPrefix(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r eventQueryNameString) HasPrefixIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r eventQueryNameString) HasSuffix(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r eventQueryNameString) HasSuffixIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type eventQueryDescriptionString struct{}

// Set the optional value of Description
func (r eventQueryDescriptionString) Set(value string) eventSetParam {

	return eventSetParam{
		data: builder.Field{
			Name:  "description",
			Value: value,
		},
	}

}

// Set the optional value of Description dynamically
func (r eventQueryDescriptionString) SetIfPresent(value *string) eventSetParam {
	if value == nil {
		return eventSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Description dynamically
func (r eventQueryDescriptionString) SetOptional(value *string) eventSetParam {
	if value == nil {

		var v *string
		return eventSetParam{
			data: builder.Field{
				Name:  "description",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r eventQueryDescriptionString) Equals(value string) eventWithPrismaDescriptionEqualsParam {

	return eventWithPrismaDescriptionEqualsParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r eventQueryDescriptionString) EqualsIfPresent(value *string) eventWithPrismaDescriptionEqualsParam {
	if value == nil {
		return eventWithPrismaDescriptionEqualsParam{}
	}
	return r.Equals(*value)
}

func (r eventQueryDescriptionString) EqualsOptional(value *string) eventDefaultParam {
	return eventDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r eventQueryDescriptionString) IsNull() eventDefaultParam {
	var str *string = nil
	return eventDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r eventQueryDescriptionString) Order(direction SortOrder) eventDefaultParam {
	return eventDefaultParam{
		data: builder.Field{
			Name:  "description",
			Value: direction,
		},
	}
}

func (r eventQueryDescriptionString) Cursor(cursor string) eventCursorParam {
	return eventCursorParam{
		data: builder.Field{
			Name:  "description",
			Value: cursor,
		},
	}
}

func (r eventQueryDescriptionString) In(value []string) eventDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r eventQueryDescriptionString) InIfPresent(value []string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.In(value)
}

func (r eventQueryDescriptionString) NotIn(value []string) eventDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r eventQueryDescriptionString) NotInIfPresent(value []string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.NotIn(value)
}

func (r eventQueryDescriptionString) Lt(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryDescriptionString) LtIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Lt(*value)
}

func (r eventQueryDescriptionString) Lte(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryDescriptionString) LteIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Lte(*value)
}

func (r eventQueryDescriptionString) Gt(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryDescriptionString) GtIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Gt(*value)
}

func (r eventQueryDescriptionString) Gte(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryDescriptionString) GteIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Gte(*value)
}

func (r eventQueryDescriptionString) Contains(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryDescriptionString) ContainsIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Contains(*value)
}

func (r eventQueryDescriptionString) StartsWith(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryDescriptionString) StartsWithIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r eventQueryDescriptionString) EndsWith(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryDescriptionString) EndsWithIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r eventQueryDescriptionString) Mode(value QueryMode) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryDescriptionString) ModeIfPresent(value *QueryMode) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Mode(*value)
}

func (r eventQueryDescriptionString) Not(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryDescriptionString) NotIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r eventQueryDescriptionString) HasPrefix(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r eventQueryDescriptionString) HasPrefixIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r eventQueryDescriptionString) HasSuffix(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r eventQueryDescriptionString) HasSuffixIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type eventQueryTransitionsTransition struct{}

type eventQueryTransitionsRelations struct{}

// Event -> Transitions
//
// @relation
// @required
func (eventQueryTransitionsRelations) Some(
	params ...TransitionWhereParam,
) eventDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "transitions",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Event -> Transitions
//
// @relation
// @required
func (eventQueryTransitionsRelations) Every(
	params ...TransitionWhereParam,
) eventDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "transitions",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (eventQueryTransitionsRelations) Fetch(

	params ...TransitionWhereParam,

) eventToTransitionsFindMany {
	var v eventToTransitionsFindMany

	v.query.Operation = "query"
	v.query.Method = "transitions"
	v.query.Outputs = transitionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r eventQueryTransitionsRelations) Link(
	params ...TransitionWhereParam,
) eventSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return eventSetParam{
		data: builder.Field{
			Name: "transitions",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r eventQueryTransitionsRelations) Unlink(
	params ...TransitionWhereParam,
) eventSetParam {
	var v eventSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = eventSetParam{
		data: builder.Field{
			Name: "transitions",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type eventQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r eventQueryCreatedAtDateTime) Set(value DateTime) eventSetParam {

	return eventSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r eventQueryCreatedAtDateTime) SetIfPresent(value *DateTime) eventSetParam {
	if value == nil {
		return eventSetParam{}
	}

	return r.Set(*value)
}

func (r eventQueryCreatedAtDateTime) Equals(value DateTime) eventWithPrismaCreatedAtEqualsParam {

	return eventWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r eventQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) eventWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return eventWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r eventQueryCreatedAtDateTime) Order(direction SortOrder) eventDefaultParam {
	return eventDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r eventQueryCreatedAtDateTime) Cursor(cursor DateTime) eventCursorParam {
	return eventCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r eventQueryCreatedAtDateTime) In(value []DateTime) eventDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r eventQueryCreatedAtDateTime) InIfPresent(value []DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.In(value)
}

func (r eventQueryCreatedAtDateTime) NotIn(value []DateTime) eventDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r eventQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.NotIn(value)
}

func (r eventQueryCreatedAtDateTime) Lt(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryCreatedAtDateTime) LtIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Lt(*value)
}

func (r eventQueryCreatedAtDateTime) Lte(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryCreatedAtDateTime) LteIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Lte(*value)
}

func (r eventQueryCreatedAtDateTime) Gt(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryCreatedAtDateTime) GtIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Gt(*value)
}

func (r eventQueryCreatedAtDateTime) Gte(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryCreatedAtDateTime) GteIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Gte(*value)
}

func (r eventQueryCreatedAtDateTime) Not(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryCreatedAtDateTime) NotIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r eventQueryCreatedAtDateTime) Before(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r eventQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r eventQueryCreatedAtDateTime) After(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r eventQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r eventQueryCreatedAtDateTime) BeforeEquals(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r eventQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r eventQueryCreatedAtDateTime) AfterEquals(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r eventQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type eventQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r eventQueryUpdatedAtDateTime) Set(value DateTime) eventSetParam {

	return eventSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r eventQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) eventSetParam {
	if value == nil {
		return eventSetParam{}
	}

	return r.Set(*value)
}

func (r eventQueryUpdatedAtDateTime) Equals(value DateTime) eventWithPrismaUpdatedAtEqualsParam {

	return eventWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r eventQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) eventWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return eventWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r eventQueryUpdatedAtDateTime) Order(direction SortOrder) eventDefaultParam {
	return eventDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r eventQueryUpdatedAtDateTime) Cursor(cursor DateTime) eventCursorParam {
	return eventCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r eventQueryUpdatedAtDateTime) In(value []DateTime) eventDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r eventQueryUpdatedAtDateTime) InIfPresent(value []DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.In(value)
}

func (r eventQueryUpdatedAtDateTime) NotIn(value []DateTime) eventDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r eventQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.NotIn(value)
}

func (r eventQueryUpdatedAtDateTime) Lt(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Lt(*value)
}

func (r eventQueryUpdatedAtDateTime) Lte(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Lte(*value)
}

func (r eventQueryUpdatedAtDateTime) Gt(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Gt(*value)
}

func (r eventQueryUpdatedAtDateTime) Gte(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Gte(*value)
}

func (r eventQueryUpdatedAtDateTime) Not(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r eventQueryUpdatedAtDateTime) Before(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r eventQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r eventQueryUpdatedAtDateTime) After(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r eventQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r eventQueryUpdatedAtDateTime) BeforeEquals(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r eventQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r eventQueryUpdatedAtDateTime) AfterEquals(value DateTime) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r eventQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type eventQueryFieldsField struct{}

type eventQueryFieldsRelations struct{}

// Event -> Fields
//
// @relation
// @required
func (eventQueryFieldsRelations) Some(
	params ...FieldWhereParam,
) eventDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "fields",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Event -> Fields
//
// @relation
// @required
func (eventQueryFieldsRelations) Every(
	params ...FieldWhereParam,
) eventDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "fields",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (eventQueryFieldsRelations) Fetch(

	params ...FieldWhereParam,

) eventToFieldsFindMany {
	var v eventToFieldsFindMany

	v.query.Operation = "query"
	v.query.Method = "fields"
	v.query.Outputs = fieldOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r eventQueryFieldsRelations) Link(
	params ...FieldWhereParam,
) eventSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return eventSetParam{
		data: builder.Field{
			Name: "fields",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r eventQueryFieldsRelations) Unlink(
	params ...FieldWhereParam,
) eventSetParam {
	var v eventSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = eventSetParam{
		data: builder.Field{
			Name: "fields",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type eventQueryCommandsAction struct{}

type eventQueryCommandsRelations struct{}

// Event -> Commands
//
// @relation
// @required
func (eventQueryCommandsRelations) Some(
	params ...ActionWhereParam,
) eventDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "commands",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Event -> Commands
//
// @relation
// @required
func (eventQueryCommandsRelations) Every(
	params ...ActionWhereParam,
) eventDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "commands",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (eventQueryCommandsRelations) Fetch(

	params ...ActionWhereParam,

) eventToCommandsFindMany {
	var v eventToCommandsFindMany

	v.query.Operation = "query"
	v.query.Method = "commands"
	v.query.Outputs = actionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r eventQueryCommandsRelations) Link(
	params ...ActionWhereParam,
) eventSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return eventSetParam{
		data: builder.Field{
			Name: "commands",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r eventQueryCommandsRelations) Unlink(
	params ...ActionWhereParam,
) eventSetParam {
	var v eventSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = eventSetParam{
		data: builder.Field{
			Name: "commands",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type eventQueryDataDatum struct{}

type eventQueryDataRelations struct{}

// Event -> Data
//
// @relation
// @required
func (eventQueryDataRelations) Some(
	params ...DatumWhereParam,
) eventDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "data",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Event -> Data
//
// @relation
// @required
func (eventQueryDataRelations) Every(
	params ...DatumWhereParam,
) eventDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "data",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (eventQueryDataRelations) Fetch(

	params ...DatumWhereParam,

) eventToDataFindMany {
	var v eventToDataFindMany

	v.query.Operation = "query"
	v.query.Method = "data"
	v.query.Outputs = datumOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r eventQueryDataRelations) Link(
	params ...DatumWhereParam,
) eventSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return eventSetParam{
		data: builder.Field{
			Name: "data",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r eventQueryDataRelations) Unlink(
	params ...DatumWhereParam,
) eventSetParam {
	var v eventSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = eventSetParam{
		data: builder.Field{
			Name: "data",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type eventQueryPlaceInterfaceIDString struct{}

// Set the optional value of PlaceInterfaceID
func (r eventQueryPlaceInterfaceIDString) Set(value string) eventSetParam {

	return eventSetParam{
		data: builder.Field{
			Name:  "placeInterfaceId",
			Value: value,
		},
	}

}

// Set the optional value of PlaceInterfaceID dynamically
func (r eventQueryPlaceInterfaceIDString) SetIfPresent(value *string) eventSetParam {
	if value == nil {
		return eventSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of PlaceInterfaceID dynamically
func (r eventQueryPlaceInterfaceIDString) SetOptional(value *string) eventSetParam {
	if value == nil {

		var v *string
		return eventSetParam{
			data: builder.Field{
				Name:  "placeInterfaceId",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r eventQueryPlaceInterfaceIDString) Equals(value string) eventWithPrismaPlaceInterfaceIDEqualsParam {

	return eventWithPrismaPlaceInterfaceIDEqualsParam{
		data: builder.Field{
			Name: "placeInterfaceId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r eventQueryPlaceInterfaceIDString) EqualsIfPresent(value *string) eventWithPrismaPlaceInterfaceIDEqualsParam {
	if value == nil {
		return eventWithPrismaPlaceInterfaceIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r eventQueryPlaceInterfaceIDString) EqualsOptional(value *string) eventDefaultParam {
	return eventDefaultParam{
		data: builder.Field{
			Name: "placeInterfaceId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r eventQueryPlaceInterfaceIDString) IsNull() eventDefaultParam {
	var str *string = nil
	return eventDefaultParam{
		data: builder.Field{
			Name: "placeInterfaceId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r eventQueryPlaceInterfaceIDString) Order(direction SortOrder) eventDefaultParam {
	return eventDefaultParam{
		data: builder.Field{
			Name:  "placeInterfaceId",
			Value: direction,
		},
	}
}

func (r eventQueryPlaceInterfaceIDString) Cursor(cursor string) eventCursorParam {
	return eventCursorParam{
		data: builder.Field{
			Name:  "placeInterfaceId",
			Value: cursor,
		},
	}
}

func (r eventQueryPlaceInterfaceIDString) In(value []string) eventDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "placeInterfaceId",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r eventQueryPlaceInterfaceIDString) InIfPresent(value []string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.In(value)
}

func (r eventQueryPlaceInterfaceIDString) NotIn(value []string) eventDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "placeInterfaceId",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r eventQueryPlaceInterfaceIDString) NotInIfPresent(value []string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.NotIn(value)
}

func (r eventQueryPlaceInterfaceIDString) Lt(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "placeInterfaceId",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryPlaceInterfaceIDString) LtIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Lt(*value)
}

func (r eventQueryPlaceInterfaceIDString) Lte(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "placeInterfaceId",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryPlaceInterfaceIDString) LteIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Lte(*value)
}

func (r eventQueryPlaceInterfaceIDString) Gt(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "placeInterfaceId",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryPlaceInterfaceIDString) GtIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Gt(*value)
}

func (r eventQueryPlaceInterfaceIDString) Gte(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "placeInterfaceId",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryPlaceInterfaceIDString) GteIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Gte(*value)
}

func (r eventQueryPlaceInterfaceIDString) Contains(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "placeInterfaceId",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryPlaceInterfaceIDString) ContainsIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Contains(*value)
}

func (r eventQueryPlaceInterfaceIDString) StartsWith(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "placeInterfaceId",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryPlaceInterfaceIDString) StartsWithIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r eventQueryPlaceInterfaceIDString) EndsWith(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "placeInterfaceId",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryPlaceInterfaceIDString) EndsWithIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r eventQueryPlaceInterfaceIDString) Mode(value QueryMode) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "placeInterfaceId",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryPlaceInterfaceIDString) ModeIfPresent(value *QueryMode) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Mode(*value)
}

func (r eventQueryPlaceInterfaceIDString) Not(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "placeInterfaceId",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryPlaceInterfaceIDString) NotIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r eventQueryPlaceInterfaceIDString) HasPrefix(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "placeInterfaceId",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r eventQueryPlaceInterfaceIDString) HasPrefixIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r eventQueryPlaceInterfaceIDString) HasSuffix(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "placeInterfaceId",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r eventQueryPlaceInterfaceIDString) HasSuffixIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type eventQueryTransitionInterfaceTransitionInterface struct{}

type eventQueryTransitionInterfaceRelations struct{}

// Event -> TransitionInterface
//
// @relation
// @optional
func (eventQueryTransitionInterfaceRelations) Where(
	params ...TransitionInterfaceWhereParam,
) eventDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "transitionInterface",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (eventQueryTransitionInterfaceRelations) Fetch() eventToTransitionInterfaceFindUnique {
	var v eventToTransitionInterfaceFindUnique

	v.query.Operation = "query"
	v.query.Method = "transitionInterface"
	v.query.Outputs = transitionInterfaceOutput

	return v
}

func (r eventQueryTransitionInterfaceRelations) Link(
	params TransitionInterfaceWhereParam,
) eventSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return eventSetParam{}
	}

	fields = append(fields, f)

	return eventSetParam{
		data: builder.Field{
			Name: "transitionInterface",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r eventQueryTransitionInterfaceRelations) Unlink() eventSetParam {
	var v eventSetParam

	v = eventSetParam{
		data: builder.Field{
			Name: "transitionInterface",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type eventQueryTransitionInterfaceIDString struct{}

// Set the optional value of TransitionInterfaceID
func (r eventQueryTransitionInterfaceIDString) Set(value string) eventSetParam {

	return eventSetParam{
		data: builder.Field{
			Name:  "transitionInterfaceId",
			Value: value,
		},
	}

}

// Set the optional value of TransitionInterfaceID dynamically
func (r eventQueryTransitionInterfaceIDString) SetIfPresent(value *string) eventSetParam {
	if value == nil {
		return eventSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of TransitionInterfaceID dynamically
func (r eventQueryTransitionInterfaceIDString) SetOptional(value *string) eventSetParam {
	if value == nil {

		var v *string
		return eventSetParam{
			data: builder.Field{
				Name:  "transitionInterfaceId",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r eventQueryTransitionInterfaceIDString) Equals(value string) eventWithPrismaTransitionInterfaceIDEqualsParam {

	return eventWithPrismaTransitionInterfaceIDEqualsParam{
		data: builder.Field{
			Name: "transitionInterfaceId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r eventQueryTransitionInterfaceIDString) EqualsIfPresent(value *string) eventWithPrismaTransitionInterfaceIDEqualsParam {
	if value == nil {
		return eventWithPrismaTransitionInterfaceIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r eventQueryTransitionInterfaceIDString) EqualsOptional(value *string) eventDefaultParam {
	return eventDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaceId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r eventQueryTransitionInterfaceIDString) IsNull() eventDefaultParam {
	var str *string = nil
	return eventDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaceId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r eventQueryTransitionInterfaceIDString) Order(direction SortOrder) eventDefaultParam {
	return eventDefaultParam{
		data: builder.Field{
			Name:  "transitionInterfaceId",
			Value: direction,
		},
	}
}

func (r eventQueryTransitionInterfaceIDString) Cursor(cursor string) eventCursorParam {
	return eventCursorParam{
		data: builder.Field{
			Name:  "transitionInterfaceId",
			Value: cursor,
		},
	}
}

func (r eventQueryTransitionInterfaceIDString) In(value []string) eventDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaceId",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r eventQueryTransitionInterfaceIDString) InIfPresent(value []string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.In(value)
}

func (r eventQueryTransitionInterfaceIDString) NotIn(value []string) eventDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return eventDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaceId",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r eventQueryTransitionInterfaceIDString) NotInIfPresent(value []string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.NotIn(value)
}

func (r eventQueryTransitionInterfaceIDString) Lt(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaceId",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryTransitionInterfaceIDString) LtIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Lt(*value)
}

func (r eventQueryTransitionInterfaceIDString) Lte(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaceId",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryTransitionInterfaceIDString) LteIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Lte(*value)
}

func (r eventQueryTransitionInterfaceIDString) Gt(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaceId",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryTransitionInterfaceIDString) GtIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Gt(*value)
}

func (r eventQueryTransitionInterfaceIDString) Gte(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaceId",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryTransitionInterfaceIDString) GteIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Gte(*value)
}

func (r eventQueryTransitionInterfaceIDString) Contains(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaceId",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryTransitionInterfaceIDString) ContainsIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Contains(*value)
}

func (r eventQueryTransitionInterfaceIDString) StartsWith(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaceId",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryTransitionInterfaceIDString) StartsWithIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r eventQueryTransitionInterfaceIDString) EndsWith(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaceId",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryTransitionInterfaceIDString) EndsWithIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r eventQueryTransitionInterfaceIDString) Mode(value QueryMode) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaceId",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryTransitionInterfaceIDString) ModeIfPresent(value *QueryMode) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Mode(*value)
}

func (r eventQueryTransitionInterfaceIDString) Not(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaceId",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r eventQueryTransitionInterfaceIDString) NotIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r eventQueryTransitionInterfaceIDString) HasPrefix(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaceId",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r eventQueryTransitionInterfaceIDString) HasPrefixIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r eventQueryTransitionInterfaceIDString) HasSuffix(value string) eventDefaultParam {

	return eventDefaultParam{
		data: builder.Field{
			Name: "transitionInterfaceId",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r eventQueryTransitionInterfaceIDString) HasSuffixIfPresent(value *string) eventDefaultParam {
	if value == nil {
		return eventDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// Instance acts as a namespaces to access query methods for the Instance model
var Instance = instanceQuery{}

// instanceQuery exposes query functions for the instance model
type instanceQuery struct {

	// ID
	//
	// @required
	ID instanceQueryIDString

	Author instanceQueryAuthorRelations

	// CreatedAt
	//
	// @required
	CreatedAt instanceQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt instanceQueryUpdatedAtDateTime

	// AuthorID
	//
	// @required
	AuthorID instanceQueryAuthorIDString

	// Language
	//
	// @required
	Language instanceQueryLanguageLanguage

	// Name
	//
	// @required
	Name instanceQueryNameString

	Device instanceQueryDeviceRelations

	// DeviceID
	//
	// @required
	DeviceID instanceQueryDeviceIDString

	// Addr
	//
	// @required
	Addr instanceQueryAddrString

	Data instanceQueryDataRelations

	Sessions instanceQuerySessionsRelations
}

func (instanceQuery) Not(params ...InstanceWhereParam) instanceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (instanceQuery) Or(params ...InstanceWhereParam) instanceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (instanceQuery) And(params ...InstanceWhereParam) instanceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type instanceQueryIDString struct{}

// Set the required value of ID
func (r instanceQueryIDString) Set(value string) instanceSetParam {

	return instanceSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r instanceQueryIDString) SetIfPresent(value *string) instanceSetParam {
	if value == nil {
		return instanceSetParam{}
	}

	return r.Set(*value)
}

func (r instanceQueryIDString) Equals(value string) instanceWithPrismaIDEqualsUniqueParam {

	return instanceWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryIDString) EqualsIfPresent(value *string) instanceWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return instanceWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r instanceQueryIDString) Order(direction SortOrder) instanceDefaultParam {
	return instanceDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r instanceQueryIDString) Cursor(cursor string) instanceCursorParam {
	return instanceCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r instanceQueryIDString) In(value []string) instanceParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return instanceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r instanceQueryIDString) InIfPresent(value []string) instanceParamUnique {
	if value == nil {
		return instanceParamUnique{}
	}
	return r.In(value)
}

func (r instanceQueryIDString) NotIn(value []string) instanceParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return instanceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r instanceQueryIDString) NotInIfPresent(value []string) instanceParamUnique {
	if value == nil {
		return instanceParamUnique{}
	}
	return r.NotIn(value)
}

func (r instanceQueryIDString) Lt(value string) instanceParamUnique {

	return instanceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryIDString) LtIfPresent(value *string) instanceParamUnique {
	if value == nil {
		return instanceParamUnique{}
	}
	return r.Lt(*value)
}

func (r instanceQueryIDString) Lte(value string) instanceParamUnique {

	return instanceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryIDString) LteIfPresent(value *string) instanceParamUnique {
	if value == nil {
		return instanceParamUnique{}
	}
	return r.Lte(*value)
}

func (r instanceQueryIDString) Gt(value string) instanceParamUnique {

	return instanceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryIDString) GtIfPresent(value *string) instanceParamUnique {
	if value == nil {
		return instanceParamUnique{}
	}
	return r.Gt(*value)
}

func (r instanceQueryIDString) Gte(value string) instanceParamUnique {

	return instanceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryIDString) GteIfPresent(value *string) instanceParamUnique {
	if value == nil {
		return instanceParamUnique{}
	}
	return r.Gte(*value)
}

func (r instanceQueryIDString) Contains(value string) instanceParamUnique {

	return instanceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryIDString) ContainsIfPresent(value *string) instanceParamUnique {
	if value == nil {
		return instanceParamUnique{}
	}
	return r.Contains(*value)
}

func (r instanceQueryIDString) StartsWith(value string) instanceParamUnique {

	return instanceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryIDString) StartsWithIfPresent(value *string) instanceParamUnique {
	if value == nil {
		return instanceParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r instanceQueryIDString) EndsWith(value string) instanceParamUnique {

	return instanceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryIDString) EndsWithIfPresent(value *string) instanceParamUnique {
	if value == nil {
		return instanceParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r instanceQueryIDString) Mode(value QueryMode) instanceParamUnique {

	return instanceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryIDString) ModeIfPresent(value *QueryMode) instanceParamUnique {
	if value == nil {
		return instanceParamUnique{}
	}
	return r.Mode(*value)
}

func (r instanceQueryIDString) Not(value string) instanceParamUnique {

	return instanceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryIDString) NotIfPresent(value *string) instanceParamUnique {
	if value == nil {
		return instanceParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r instanceQueryIDString) HasPrefix(value string) instanceParamUnique {

	return instanceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r instanceQueryIDString) HasPrefixIfPresent(value *string) instanceParamUnique {
	if value == nil {
		return instanceParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r instanceQueryIDString) HasSuffix(value string) instanceParamUnique {

	return instanceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r instanceQueryIDString) HasSuffixIfPresent(value *string) instanceParamUnique {
	if value == nil {
		return instanceParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type instanceQueryAuthorUser struct{}

type instanceQueryAuthorRelations struct{}

// Instance -> Author
//
// @relation
// @required
func (instanceQueryAuthorRelations) Where(
	params ...UserWhereParam,
) instanceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "author",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (instanceQueryAuthorRelations) Fetch() instanceToAuthorFindUnique {
	var v instanceToAuthorFindUnique

	v.query.Operation = "query"
	v.query.Method = "author"
	v.query.Outputs = userOutput

	return v
}

func (r instanceQueryAuthorRelations) Link(
	params UserWhereParam,
) instanceWithPrismaAuthorSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return instanceWithPrismaAuthorSetParam{}
	}

	fields = append(fields, f)

	return instanceWithPrismaAuthorSetParam{
		data: builder.Field{
			Name: "author",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r instanceQueryAuthorRelations) Unlink() instanceWithPrismaAuthorSetParam {
	var v instanceWithPrismaAuthorSetParam

	v = instanceWithPrismaAuthorSetParam{
		data: builder.Field{
			Name: "author",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type instanceQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r instanceQueryCreatedAtDateTime) Set(value DateTime) instanceSetParam {

	return instanceSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r instanceQueryCreatedAtDateTime) SetIfPresent(value *DateTime) instanceSetParam {
	if value == nil {
		return instanceSetParam{}
	}

	return r.Set(*value)
}

func (r instanceQueryCreatedAtDateTime) Equals(value DateTime) instanceWithPrismaCreatedAtEqualsParam {

	return instanceWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) instanceWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return instanceWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r instanceQueryCreatedAtDateTime) Order(direction SortOrder) instanceDefaultParam {
	return instanceDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r instanceQueryCreatedAtDateTime) Cursor(cursor DateTime) instanceCursorParam {
	return instanceCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r instanceQueryCreatedAtDateTime) In(value []DateTime) instanceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r instanceQueryCreatedAtDateTime) InIfPresent(value []DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.In(value)
}

func (r instanceQueryCreatedAtDateTime) NotIn(value []DateTime) instanceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r instanceQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r instanceQueryCreatedAtDateTime) Lt(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryCreatedAtDateTime) LtIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r instanceQueryCreatedAtDateTime) Lte(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryCreatedAtDateTime) LteIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r instanceQueryCreatedAtDateTime) Gt(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryCreatedAtDateTime) GtIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r instanceQueryCreatedAtDateTime) Gte(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryCreatedAtDateTime) GteIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r instanceQueryCreatedAtDateTime) Not(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryCreatedAtDateTime) NotIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r instanceQueryCreatedAtDateTime) Before(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r instanceQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r instanceQueryCreatedAtDateTime) After(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r instanceQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r instanceQueryCreatedAtDateTime) BeforeEquals(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r instanceQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r instanceQueryCreatedAtDateTime) AfterEquals(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r instanceQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type instanceQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r instanceQueryUpdatedAtDateTime) Set(value DateTime) instanceSetParam {

	return instanceSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r instanceQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) instanceSetParam {
	if value == nil {
		return instanceSetParam{}
	}

	return r.Set(*value)
}

func (r instanceQueryUpdatedAtDateTime) Equals(value DateTime) instanceWithPrismaUpdatedAtEqualsParam {

	return instanceWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) instanceWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return instanceWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r instanceQueryUpdatedAtDateTime) Order(direction SortOrder) instanceDefaultParam {
	return instanceDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r instanceQueryUpdatedAtDateTime) Cursor(cursor DateTime) instanceCursorParam {
	return instanceCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r instanceQueryUpdatedAtDateTime) In(value []DateTime) instanceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r instanceQueryUpdatedAtDateTime) InIfPresent(value []DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.In(value)
}

func (r instanceQueryUpdatedAtDateTime) NotIn(value []DateTime) instanceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r instanceQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r instanceQueryUpdatedAtDateTime) Lt(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r instanceQueryUpdatedAtDateTime) Lte(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r instanceQueryUpdatedAtDateTime) Gt(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r instanceQueryUpdatedAtDateTime) Gte(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r instanceQueryUpdatedAtDateTime) Not(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r instanceQueryUpdatedAtDateTime) Before(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r instanceQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r instanceQueryUpdatedAtDateTime) After(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r instanceQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r instanceQueryUpdatedAtDateTime) BeforeEquals(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r instanceQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r instanceQueryUpdatedAtDateTime) AfterEquals(value DateTime) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r instanceQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type instanceQueryAuthorIDString struct{}

// Set the required value of AuthorID
func (r instanceQueryAuthorIDString) Set(value string) instanceSetParam {

	return instanceSetParam{
		data: builder.Field{
			Name:  "authorID",
			Value: value,
		},
	}

}

// Set the optional value of AuthorID dynamically
func (r instanceQueryAuthorIDString) SetIfPresent(value *string) instanceSetParam {
	if value == nil {
		return instanceSetParam{}
	}

	return r.Set(*value)
}

func (r instanceQueryAuthorIDString) Equals(value string) instanceWithPrismaAuthorIDEqualsParam {

	return instanceWithPrismaAuthorIDEqualsParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAuthorIDString) EqualsIfPresent(value *string) instanceWithPrismaAuthorIDEqualsParam {
	if value == nil {
		return instanceWithPrismaAuthorIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r instanceQueryAuthorIDString) Order(direction SortOrder) instanceDefaultParam {
	return instanceDefaultParam{
		data: builder.Field{
			Name:  "authorID",
			Value: direction,
		},
	}
}

func (r instanceQueryAuthorIDString) Cursor(cursor string) instanceCursorParam {
	return instanceCursorParam{
		data: builder.Field{
			Name:  "authorID",
			Value: cursor,
		},
	}
}

func (r instanceQueryAuthorIDString) In(value []string) instanceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r instanceQueryAuthorIDString) InIfPresent(value []string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.In(value)
}

func (r instanceQueryAuthorIDString) NotIn(value []string) instanceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r instanceQueryAuthorIDString) NotInIfPresent(value []string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r instanceQueryAuthorIDString) Lt(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAuthorIDString) LtIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r instanceQueryAuthorIDString) Lte(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAuthorIDString) LteIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r instanceQueryAuthorIDString) Gt(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAuthorIDString) GtIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r instanceQueryAuthorIDString) Gte(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAuthorIDString) GteIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r instanceQueryAuthorIDString) Contains(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAuthorIDString) ContainsIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Contains(*value)
}

func (r instanceQueryAuthorIDString) StartsWith(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAuthorIDString) StartsWithIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r instanceQueryAuthorIDString) EndsWith(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAuthorIDString) EndsWithIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r instanceQueryAuthorIDString) Mode(value QueryMode) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAuthorIDString) ModeIfPresent(value *QueryMode) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Mode(*value)
}

func (r instanceQueryAuthorIDString) Not(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAuthorIDString) NotIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r instanceQueryAuthorIDString) HasPrefix(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r instanceQueryAuthorIDString) HasPrefixIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r instanceQueryAuthorIDString) HasSuffix(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r instanceQueryAuthorIDString) HasSuffixIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type instanceQueryLanguageLanguage struct{}

// Set the required value of Language
func (r instanceQueryLanguageLanguage) Set(value Language) instanceWithPrismaLanguageSetParam {

	return instanceWithPrismaLanguageSetParam{
		data: builder.Field{
			Name:  "language",
			Value: value,
		},
	}

}

// Set the optional value of Language dynamically
func (r instanceQueryLanguageLanguage) SetIfPresent(value *Language) instanceWithPrismaLanguageSetParam {
	if value == nil {
		return instanceWithPrismaLanguageSetParam{}
	}

	return r.Set(*value)
}

func (r instanceQueryLanguageLanguage) Equals(value Language) instanceWithPrismaLanguageEqualsParam {

	return instanceWithPrismaLanguageEqualsParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryLanguageLanguage) EqualsIfPresent(value *Language) instanceWithPrismaLanguageEqualsParam {
	if value == nil {
		return instanceWithPrismaLanguageEqualsParam{}
	}
	return r.Equals(*value)
}

func (r instanceQueryLanguageLanguage) Order(direction SortOrder) instanceDefaultParam {
	return instanceDefaultParam{
		data: builder.Field{
			Name:  "language",
			Value: direction,
		},
	}
}

func (r instanceQueryLanguageLanguage) Cursor(cursor Language) instanceCursorParam {
	return instanceCursorParam{
		data: builder.Field{
			Name:  "language",
			Value: cursor,
		},
	}
}

func (r instanceQueryLanguageLanguage) In(value []Language) instanceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r instanceQueryLanguageLanguage) InIfPresent(value []Language) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.In(value)
}

func (r instanceQueryLanguageLanguage) NotIn(value []Language) instanceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r instanceQueryLanguageLanguage) NotInIfPresent(value []Language) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r instanceQueryLanguageLanguage) Not(value Language) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryLanguageLanguage) NotIfPresent(value *Language) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Not(*value)
}

// base struct
type instanceQueryNameString struct{}

// Set the required value of Name
func (r instanceQueryNameString) Set(value string) instanceWithPrismaNameSetParam {

	return instanceWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r instanceQueryNameString) SetIfPresent(value *string) instanceWithPrismaNameSetParam {
	if value == nil {
		return instanceWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r instanceQueryNameString) Equals(value string) instanceWithPrismaNameEqualsParam {

	return instanceWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryNameString) EqualsIfPresent(value *string) instanceWithPrismaNameEqualsParam {
	if value == nil {
		return instanceWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r instanceQueryNameString) Order(direction SortOrder) instanceDefaultParam {
	return instanceDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r instanceQueryNameString) Cursor(cursor string) instanceCursorParam {
	return instanceCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r instanceQueryNameString) In(value []string) instanceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r instanceQueryNameString) InIfPresent(value []string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.In(value)
}

func (r instanceQueryNameString) NotIn(value []string) instanceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r instanceQueryNameString) NotInIfPresent(value []string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r instanceQueryNameString) Lt(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryNameString) LtIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r instanceQueryNameString) Lte(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryNameString) LteIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r instanceQueryNameString) Gt(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryNameString) GtIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r instanceQueryNameString) Gte(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryNameString) GteIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r instanceQueryNameString) Contains(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryNameString) ContainsIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Contains(*value)
}

func (r instanceQueryNameString) StartsWith(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryNameString) StartsWithIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r instanceQueryNameString) EndsWith(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryNameString) EndsWithIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r instanceQueryNameString) Mode(value QueryMode) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryNameString) ModeIfPresent(value *QueryMode) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Mode(*value)
}

func (r instanceQueryNameString) Not(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryNameString) NotIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r instanceQueryNameString) HasPrefix(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r instanceQueryNameString) HasPrefixIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r instanceQueryNameString) HasSuffix(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r instanceQueryNameString) HasSuffixIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type instanceQueryDeviceDevice struct{}

type instanceQueryDeviceRelations struct{}

// Instance -> Device
//
// @relation
// @required
func (instanceQueryDeviceRelations) Where(
	params ...DeviceWhereParam,
) instanceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "device",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (instanceQueryDeviceRelations) Fetch() instanceToDeviceFindUnique {
	var v instanceToDeviceFindUnique

	v.query.Operation = "query"
	v.query.Method = "device"
	v.query.Outputs = deviceOutput

	return v
}

func (r instanceQueryDeviceRelations) Link(
	params DeviceWhereParam,
) instanceWithPrismaDeviceSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return instanceWithPrismaDeviceSetParam{}
	}

	fields = append(fields, f)

	return instanceWithPrismaDeviceSetParam{
		data: builder.Field{
			Name: "device",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r instanceQueryDeviceRelations) Unlink() instanceWithPrismaDeviceSetParam {
	var v instanceWithPrismaDeviceSetParam

	v = instanceWithPrismaDeviceSetParam{
		data: builder.Field{
			Name: "device",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type instanceQueryDeviceIDString struct{}

// Set the required value of DeviceID
func (r instanceQueryDeviceIDString) Set(value string) instanceSetParam {

	return instanceSetParam{
		data: builder.Field{
			Name:  "deviceId",
			Value: value,
		},
	}

}

// Set the optional value of DeviceID dynamically
func (r instanceQueryDeviceIDString) SetIfPresent(value *string) instanceSetParam {
	if value == nil {
		return instanceSetParam{}
	}

	return r.Set(*value)
}

func (r instanceQueryDeviceIDString) Equals(value string) instanceWithPrismaDeviceIDEqualsParam {

	return instanceWithPrismaDeviceIDEqualsParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryDeviceIDString) EqualsIfPresent(value *string) instanceWithPrismaDeviceIDEqualsParam {
	if value == nil {
		return instanceWithPrismaDeviceIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r instanceQueryDeviceIDString) Order(direction SortOrder) instanceDefaultParam {
	return instanceDefaultParam{
		data: builder.Field{
			Name:  "deviceId",
			Value: direction,
		},
	}
}

func (r instanceQueryDeviceIDString) Cursor(cursor string) instanceCursorParam {
	return instanceCursorParam{
		data: builder.Field{
			Name:  "deviceId",
			Value: cursor,
		},
	}
}

func (r instanceQueryDeviceIDString) In(value []string) instanceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r instanceQueryDeviceIDString) InIfPresent(value []string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.In(value)
}

func (r instanceQueryDeviceIDString) NotIn(value []string) instanceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r instanceQueryDeviceIDString) NotInIfPresent(value []string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r instanceQueryDeviceIDString) Lt(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryDeviceIDString) LtIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r instanceQueryDeviceIDString) Lte(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryDeviceIDString) LteIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r instanceQueryDeviceIDString) Gt(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryDeviceIDString) GtIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r instanceQueryDeviceIDString) Gte(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryDeviceIDString) GteIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r instanceQueryDeviceIDString) Contains(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryDeviceIDString) ContainsIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Contains(*value)
}

func (r instanceQueryDeviceIDString) StartsWith(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryDeviceIDString) StartsWithIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r instanceQueryDeviceIDString) EndsWith(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryDeviceIDString) EndsWithIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r instanceQueryDeviceIDString) Mode(value QueryMode) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryDeviceIDString) ModeIfPresent(value *QueryMode) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Mode(*value)
}

func (r instanceQueryDeviceIDString) Not(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryDeviceIDString) NotIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r instanceQueryDeviceIDString) HasPrefix(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r instanceQueryDeviceIDString) HasPrefixIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r instanceQueryDeviceIDString) HasSuffix(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r instanceQueryDeviceIDString) HasSuffixIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type instanceQueryAddrString struct{}

// Set the required value of Addr
func (r instanceQueryAddrString) Set(value string) instanceWithPrismaAddrSetParam {

	return instanceWithPrismaAddrSetParam{
		data: builder.Field{
			Name:  "addr",
			Value: value,
		},
	}

}

// Set the optional value of Addr dynamically
func (r instanceQueryAddrString) SetIfPresent(value *string) instanceWithPrismaAddrSetParam {
	if value == nil {
		return instanceWithPrismaAddrSetParam{}
	}

	return r.Set(*value)
}

func (r instanceQueryAddrString) Equals(value string) instanceWithPrismaAddrEqualsParam {

	return instanceWithPrismaAddrEqualsParam{
		data: builder.Field{
			Name: "addr",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAddrString) EqualsIfPresent(value *string) instanceWithPrismaAddrEqualsParam {
	if value == nil {
		return instanceWithPrismaAddrEqualsParam{}
	}
	return r.Equals(*value)
}

func (r instanceQueryAddrString) Order(direction SortOrder) instanceDefaultParam {
	return instanceDefaultParam{
		data: builder.Field{
			Name:  "addr",
			Value: direction,
		},
	}
}

func (r instanceQueryAddrString) Cursor(cursor string) instanceCursorParam {
	return instanceCursorParam{
		data: builder.Field{
			Name:  "addr",
			Value: cursor,
		},
	}
}

func (r instanceQueryAddrString) In(value []string) instanceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "addr",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r instanceQueryAddrString) InIfPresent(value []string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.In(value)
}

func (r instanceQueryAddrString) NotIn(value []string) instanceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "addr",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r instanceQueryAddrString) NotInIfPresent(value []string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r instanceQueryAddrString) Lt(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "addr",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAddrString) LtIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r instanceQueryAddrString) Lte(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "addr",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAddrString) LteIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r instanceQueryAddrString) Gt(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "addr",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAddrString) GtIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r instanceQueryAddrString) Gte(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "addr",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAddrString) GteIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r instanceQueryAddrString) Contains(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "addr",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAddrString) ContainsIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Contains(*value)
}

func (r instanceQueryAddrString) StartsWith(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "addr",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAddrString) StartsWithIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r instanceQueryAddrString) EndsWith(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "addr",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAddrString) EndsWithIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r instanceQueryAddrString) Mode(value QueryMode) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "addr",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAddrString) ModeIfPresent(value *QueryMode) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Mode(*value)
}

func (r instanceQueryAddrString) Not(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "addr",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r instanceQueryAddrString) NotIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r instanceQueryAddrString) HasPrefix(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "addr",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r instanceQueryAddrString) HasPrefixIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r instanceQueryAddrString) HasSuffix(value string) instanceDefaultParam {

	return instanceDefaultParam{
		data: builder.Field{
			Name: "addr",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r instanceQueryAddrString) HasSuffixIfPresent(value *string) instanceDefaultParam {
	if value == nil {
		return instanceDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type instanceQueryDataDatum struct{}

type instanceQueryDataRelations struct{}

// Instance -> Data
//
// @relation
// @required
func (instanceQueryDataRelations) Some(
	params ...DatumWhereParam,
) instanceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "data",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Instance -> Data
//
// @relation
// @required
func (instanceQueryDataRelations) Every(
	params ...DatumWhereParam,
) instanceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "data",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (instanceQueryDataRelations) Fetch(

	params ...DatumWhereParam,

) instanceToDataFindMany {
	var v instanceToDataFindMany

	v.query.Operation = "query"
	v.query.Method = "data"
	v.query.Outputs = datumOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r instanceQueryDataRelations) Link(
	params ...DatumWhereParam,
) instanceSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return instanceSetParam{
		data: builder.Field{
			Name: "data",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r instanceQueryDataRelations) Unlink(
	params ...DatumWhereParam,
) instanceSetParam {
	var v instanceSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = instanceSetParam{
		data: builder.Field{
			Name: "data",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type instanceQuerySessionsSession struct{}

type instanceQuerySessionsRelations struct{}

// Instance -> Sessions
//
// @relation
// @required
func (instanceQuerySessionsRelations) Some(
	params ...SessionWhereParam,
) instanceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "sessions",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Instance -> Sessions
//
// @relation
// @required
func (instanceQuerySessionsRelations) Every(
	params ...SessionWhereParam,
) instanceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return instanceDefaultParam{
		data: builder.Field{
			Name: "sessions",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (instanceQuerySessionsRelations) Fetch(

	params ...SessionWhereParam,

) instanceToSessionsFindMany {
	var v instanceToSessionsFindMany

	v.query.Operation = "query"
	v.query.Method = "sessions"
	v.query.Outputs = sessionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r instanceQuerySessionsRelations) Link(
	params ...SessionWhereParam,
) instanceSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return instanceSetParam{
		data: builder.Field{
			Name: "sessions",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r instanceQuerySessionsRelations) Unlink(
	params ...SessionWhereParam,
) instanceSetParam {
	var v instanceSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = instanceSetParam{
		data: builder.Field{
			Name: "sessions",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// Device acts as a namespaces to access query methods for the Device model
var Device = deviceQuery{}

// deviceQuery exposes query functions for the device model
type deviceQuery struct {

	// ID
	//
	// @required
	ID deviceQueryIDString

	Author deviceQueryAuthorRelations

	// AuthorID
	//
	// @required
	AuthorID deviceQueryAuthorIDString

	// Name
	//
	// @required
	Name deviceQueryNameString

	// Description
	//
	// @required
	Description deviceQueryDescriptionString

	Instances deviceQueryInstancesRelations

	// CreatedAt
	//
	// @required
	CreatedAt deviceQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt deviceQueryUpdatedAtDateTime

	// NetIDs
	//
	// @required
	NetIDs deviceQueryNetIDsString

	Nets deviceQueryNetsRelations

	Actions deviceQueryActionsRelations
}

func (deviceQuery) Not(params ...DeviceWhereParam) deviceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (deviceQuery) Or(params ...DeviceWhereParam) deviceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (deviceQuery) And(params ...DeviceWhereParam) deviceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type deviceQueryIDString struct{}

// Set the required value of ID
func (r deviceQueryIDString) Set(value string) deviceSetParam {

	return deviceSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r deviceQueryIDString) SetIfPresent(value *string) deviceSetParam {
	if value == nil {
		return deviceSetParam{}
	}

	return r.Set(*value)
}

func (r deviceQueryIDString) Equals(value string) deviceWithPrismaIDEqualsUniqueParam {

	return deviceWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryIDString) EqualsIfPresent(value *string) deviceWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return deviceWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r deviceQueryIDString) Order(direction SortOrder) deviceDefaultParam {
	return deviceDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r deviceQueryIDString) Cursor(cursor string) deviceCursorParam {
	return deviceCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r deviceQueryIDString) In(value []string) deviceParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return deviceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r deviceQueryIDString) InIfPresent(value []string) deviceParamUnique {
	if value == nil {
		return deviceParamUnique{}
	}
	return r.In(value)
}

func (r deviceQueryIDString) NotIn(value []string) deviceParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return deviceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r deviceQueryIDString) NotInIfPresent(value []string) deviceParamUnique {
	if value == nil {
		return deviceParamUnique{}
	}
	return r.NotIn(value)
}

func (r deviceQueryIDString) Lt(value string) deviceParamUnique {

	return deviceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryIDString) LtIfPresent(value *string) deviceParamUnique {
	if value == nil {
		return deviceParamUnique{}
	}
	return r.Lt(*value)
}

func (r deviceQueryIDString) Lte(value string) deviceParamUnique {

	return deviceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryIDString) LteIfPresent(value *string) deviceParamUnique {
	if value == nil {
		return deviceParamUnique{}
	}
	return r.Lte(*value)
}

func (r deviceQueryIDString) Gt(value string) deviceParamUnique {

	return deviceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryIDString) GtIfPresent(value *string) deviceParamUnique {
	if value == nil {
		return deviceParamUnique{}
	}
	return r.Gt(*value)
}

func (r deviceQueryIDString) Gte(value string) deviceParamUnique {

	return deviceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryIDString) GteIfPresent(value *string) deviceParamUnique {
	if value == nil {
		return deviceParamUnique{}
	}
	return r.Gte(*value)
}

func (r deviceQueryIDString) Contains(value string) deviceParamUnique {

	return deviceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryIDString) ContainsIfPresent(value *string) deviceParamUnique {
	if value == nil {
		return deviceParamUnique{}
	}
	return r.Contains(*value)
}

func (r deviceQueryIDString) StartsWith(value string) deviceParamUnique {

	return deviceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryIDString) StartsWithIfPresent(value *string) deviceParamUnique {
	if value == nil {
		return deviceParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r deviceQueryIDString) EndsWith(value string) deviceParamUnique {

	return deviceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryIDString) EndsWithIfPresent(value *string) deviceParamUnique {
	if value == nil {
		return deviceParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r deviceQueryIDString) Mode(value QueryMode) deviceParamUnique {

	return deviceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryIDString) ModeIfPresent(value *QueryMode) deviceParamUnique {
	if value == nil {
		return deviceParamUnique{}
	}
	return r.Mode(*value)
}

func (r deviceQueryIDString) Not(value string) deviceParamUnique {

	return deviceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryIDString) NotIfPresent(value *string) deviceParamUnique {
	if value == nil {
		return deviceParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r deviceQueryIDString) HasPrefix(value string) deviceParamUnique {

	return deviceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r deviceQueryIDString) HasPrefixIfPresent(value *string) deviceParamUnique {
	if value == nil {
		return deviceParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r deviceQueryIDString) HasSuffix(value string) deviceParamUnique {

	return deviceParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r deviceQueryIDString) HasSuffixIfPresent(value *string) deviceParamUnique {
	if value == nil {
		return deviceParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type deviceQueryAuthorUser struct{}

type deviceQueryAuthorRelations struct{}

// Device -> Author
//
// @relation
// @required
func (deviceQueryAuthorRelations) Where(
	params ...UserWhereParam,
) deviceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "author",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (deviceQueryAuthorRelations) Fetch() deviceToAuthorFindUnique {
	var v deviceToAuthorFindUnique

	v.query.Operation = "query"
	v.query.Method = "author"
	v.query.Outputs = userOutput

	return v
}

func (r deviceQueryAuthorRelations) Link(
	params UserWhereParam,
) deviceWithPrismaAuthorSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return deviceWithPrismaAuthorSetParam{}
	}

	fields = append(fields, f)

	return deviceWithPrismaAuthorSetParam{
		data: builder.Field{
			Name: "author",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r deviceQueryAuthorRelations) Unlink() deviceWithPrismaAuthorSetParam {
	var v deviceWithPrismaAuthorSetParam

	v = deviceWithPrismaAuthorSetParam{
		data: builder.Field{
			Name: "author",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type deviceQueryAuthorIDString struct{}

// Set the required value of AuthorID
func (r deviceQueryAuthorIDString) Set(value string) deviceSetParam {

	return deviceSetParam{
		data: builder.Field{
			Name:  "authorID",
			Value: value,
		},
	}

}

// Set the optional value of AuthorID dynamically
func (r deviceQueryAuthorIDString) SetIfPresent(value *string) deviceSetParam {
	if value == nil {
		return deviceSetParam{}
	}

	return r.Set(*value)
}

func (r deviceQueryAuthorIDString) Equals(value string) deviceWithPrismaAuthorIDEqualsParam {

	return deviceWithPrismaAuthorIDEqualsParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryAuthorIDString) EqualsIfPresent(value *string) deviceWithPrismaAuthorIDEqualsParam {
	if value == nil {
		return deviceWithPrismaAuthorIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r deviceQueryAuthorIDString) Order(direction SortOrder) deviceDefaultParam {
	return deviceDefaultParam{
		data: builder.Field{
			Name:  "authorID",
			Value: direction,
		},
	}
}

func (r deviceQueryAuthorIDString) Cursor(cursor string) deviceCursorParam {
	return deviceCursorParam{
		data: builder.Field{
			Name:  "authorID",
			Value: cursor,
		},
	}
}

func (r deviceQueryAuthorIDString) In(value []string) deviceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r deviceQueryAuthorIDString) InIfPresent(value []string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.In(value)
}

func (r deviceQueryAuthorIDString) NotIn(value []string) deviceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r deviceQueryAuthorIDString) NotInIfPresent(value []string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r deviceQueryAuthorIDString) Lt(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryAuthorIDString) LtIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r deviceQueryAuthorIDString) Lte(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryAuthorIDString) LteIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r deviceQueryAuthorIDString) Gt(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryAuthorIDString) GtIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r deviceQueryAuthorIDString) Gte(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryAuthorIDString) GteIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r deviceQueryAuthorIDString) Contains(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryAuthorIDString) ContainsIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Contains(*value)
}

func (r deviceQueryAuthorIDString) StartsWith(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryAuthorIDString) StartsWithIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r deviceQueryAuthorIDString) EndsWith(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryAuthorIDString) EndsWithIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r deviceQueryAuthorIDString) Mode(value QueryMode) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryAuthorIDString) ModeIfPresent(value *QueryMode) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Mode(*value)
}

func (r deviceQueryAuthorIDString) Not(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryAuthorIDString) NotIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r deviceQueryAuthorIDString) HasPrefix(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r deviceQueryAuthorIDString) HasPrefixIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r deviceQueryAuthorIDString) HasSuffix(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "authorID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r deviceQueryAuthorIDString) HasSuffixIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type deviceQueryNameString struct{}

// Set the required value of Name
func (r deviceQueryNameString) Set(value string) deviceWithPrismaNameSetParam {

	return deviceWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r deviceQueryNameString) SetIfPresent(value *string) deviceWithPrismaNameSetParam {
	if value == nil {
		return deviceWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r deviceQueryNameString) Equals(value string) deviceWithPrismaNameEqualsParam {

	return deviceWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryNameString) EqualsIfPresent(value *string) deviceWithPrismaNameEqualsParam {
	if value == nil {
		return deviceWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r deviceQueryNameString) Order(direction SortOrder) deviceDefaultParam {
	return deviceDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r deviceQueryNameString) Cursor(cursor string) deviceCursorParam {
	return deviceCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r deviceQueryNameString) In(value []string) deviceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r deviceQueryNameString) InIfPresent(value []string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.In(value)
}

func (r deviceQueryNameString) NotIn(value []string) deviceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r deviceQueryNameString) NotInIfPresent(value []string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r deviceQueryNameString) Lt(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryNameString) LtIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r deviceQueryNameString) Lte(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryNameString) LteIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r deviceQueryNameString) Gt(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryNameString) GtIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r deviceQueryNameString) Gte(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryNameString) GteIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r deviceQueryNameString) Contains(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryNameString) ContainsIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Contains(*value)
}

func (r deviceQueryNameString) StartsWith(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryNameString) StartsWithIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r deviceQueryNameString) EndsWith(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryNameString) EndsWithIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r deviceQueryNameString) Mode(value QueryMode) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryNameString) ModeIfPresent(value *QueryMode) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Mode(*value)
}

func (r deviceQueryNameString) Not(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryNameString) NotIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r deviceQueryNameString) HasPrefix(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r deviceQueryNameString) HasPrefixIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r deviceQueryNameString) HasSuffix(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r deviceQueryNameString) HasSuffixIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type deviceQueryDescriptionString struct{}

// Set the required value of Description
func (r deviceQueryDescriptionString) Set(value string) deviceWithPrismaDescriptionSetParam {

	return deviceWithPrismaDescriptionSetParam{
		data: builder.Field{
			Name:  "description",
			Value: value,
		},
	}

}

// Set the optional value of Description dynamically
func (r deviceQueryDescriptionString) SetIfPresent(value *string) deviceWithPrismaDescriptionSetParam {
	if value == nil {
		return deviceWithPrismaDescriptionSetParam{}
	}

	return r.Set(*value)
}

func (r deviceQueryDescriptionString) Equals(value string) deviceWithPrismaDescriptionEqualsParam {

	return deviceWithPrismaDescriptionEqualsParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryDescriptionString) EqualsIfPresent(value *string) deviceWithPrismaDescriptionEqualsParam {
	if value == nil {
		return deviceWithPrismaDescriptionEqualsParam{}
	}
	return r.Equals(*value)
}

func (r deviceQueryDescriptionString) Order(direction SortOrder) deviceDefaultParam {
	return deviceDefaultParam{
		data: builder.Field{
			Name:  "description",
			Value: direction,
		},
	}
}

func (r deviceQueryDescriptionString) Cursor(cursor string) deviceCursorParam {
	return deviceCursorParam{
		data: builder.Field{
			Name:  "description",
			Value: cursor,
		},
	}
}

func (r deviceQueryDescriptionString) In(value []string) deviceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r deviceQueryDescriptionString) InIfPresent(value []string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.In(value)
}

func (r deviceQueryDescriptionString) NotIn(value []string) deviceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r deviceQueryDescriptionString) NotInIfPresent(value []string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r deviceQueryDescriptionString) Lt(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryDescriptionString) LtIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r deviceQueryDescriptionString) Lte(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryDescriptionString) LteIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r deviceQueryDescriptionString) Gt(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryDescriptionString) GtIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r deviceQueryDescriptionString) Gte(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryDescriptionString) GteIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r deviceQueryDescriptionString) Contains(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryDescriptionString) ContainsIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Contains(*value)
}

func (r deviceQueryDescriptionString) StartsWith(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryDescriptionString) StartsWithIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r deviceQueryDescriptionString) EndsWith(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryDescriptionString) EndsWithIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r deviceQueryDescriptionString) Mode(value QueryMode) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryDescriptionString) ModeIfPresent(value *QueryMode) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Mode(*value)
}

func (r deviceQueryDescriptionString) Not(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryDescriptionString) NotIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r deviceQueryDescriptionString) HasPrefix(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r deviceQueryDescriptionString) HasPrefixIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r deviceQueryDescriptionString) HasSuffix(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r deviceQueryDescriptionString) HasSuffixIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type deviceQueryInstancesInstance struct{}

type deviceQueryInstancesRelations struct{}

// Device -> Instances
//
// @relation
// @required
func (deviceQueryInstancesRelations) Some(
	params ...InstanceWhereParam,
) deviceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "instances",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Device -> Instances
//
// @relation
// @required
func (deviceQueryInstancesRelations) Every(
	params ...InstanceWhereParam,
) deviceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "instances",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (deviceQueryInstancesRelations) Fetch(

	params ...InstanceWhereParam,

) deviceToInstancesFindMany {
	var v deviceToInstancesFindMany

	v.query.Operation = "query"
	v.query.Method = "instances"
	v.query.Outputs = instanceOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r deviceQueryInstancesRelations) Link(
	params ...InstanceWhereParam,
) deviceSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return deviceSetParam{
		data: builder.Field{
			Name: "instances",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r deviceQueryInstancesRelations) Unlink(
	params ...InstanceWhereParam,
) deviceSetParam {
	var v deviceSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = deviceSetParam{
		data: builder.Field{
			Name: "instances",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type deviceQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r deviceQueryCreatedAtDateTime) Set(value DateTime) deviceSetParam {

	return deviceSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r deviceQueryCreatedAtDateTime) SetIfPresent(value *DateTime) deviceSetParam {
	if value == nil {
		return deviceSetParam{}
	}

	return r.Set(*value)
}

func (r deviceQueryCreatedAtDateTime) Equals(value DateTime) deviceWithPrismaCreatedAtEqualsParam {

	return deviceWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) deviceWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return deviceWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r deviceQueryCreatedAtDateTime) Order(direction SortOrder) deviceDefaultParam {
	return deviceDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r deviceQueryCreatedAtDateTime) Cursor(cursor DateTime) deviceCursorParam {
	return deviceCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r deviceQueryCreatedAtDateTime) In(value []DateTime) deviceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r deviceQueryCreatedAtDateTime) InIfPresent(value []DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.In(value)
}

func (r deviceQueryCreatedAtDateTime) NotIn(value []DateTime) deviceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r deviceQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r deviceQueryCreatedAtDateTime) Lt(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryCreatedAtDateTime) LtIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r deviceQueryCreatedAtDateTime) Lte(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryCreatedAtDateTime) LteIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r deviceQueryCreatedAtDateTime) Gt(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryCreatedAtDateTime) GtIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r deviceQueryCreatedAtDateTime) Gte(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryCreatedAtDateTime) GteIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r deviceQueryCreatedAtDateTime) Not(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryCreatedAtDateTime) NotIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r deviceQueryCreatedAtDateTime) Before(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r deviceQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r deviceQueryCreatedAtDateTime) After(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r deviceQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r deviceQueryCreatedAtDateTime) BeforeEquals(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r deviceQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r deviceQueryCreatedAtDateTime) AfterEquals(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r deviceQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type deviceQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r deviceQueryUpdatedAtDateTime) Set(value DateTime) deviceSetParam {

	return deviceSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r deviceQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) deviceSetParam {
	if value == nil {
		return deviceSetParam{}
	}

	return r.Set(*value)
}

func (r deviceQueryUpdatedAtDateTime) Equals(value DateTime) deviceWithPrismaUpdatedAtEqualsParam {

	return deviceWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) deviceWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return deviceWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r deviceQueryUpdatedAtDateTime) Order(direction SortOrder) deviceDefaultParam {
	return deviceDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r deviceQueryUpdatedAtDateTime) Cursor(cursor DateTime) deviceCursorParam {
	return deviceCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r deviceQueryUpdatedAtDateTime) In(value []DateTime) deviceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r deviceQueryUpdatedAtDateTime) InIfPresent(value []DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.In(value)
}

func (r deviceQueryUpdatedAtDateTime) NotIn(value []DateTime) deviceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r deviceQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.NotIn(value)
}

func (r deviceQueryUpdatedAtDateTime) Lt(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Lt(*value)
}

func (r deviceQueryUpdatedAtDateTime) Lte(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Lte(*value)
}

func (r deviceQueryUpdatedAtDateTime) Gt(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Gt(*value)
}

func (r deviceQueryUpdatedAtDateTime) Gte(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Gte(*value)
}

func (r deviceQueryUpdatedAtDateTime) Not(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r deviceQueryUpdatedAtDateTime) Before(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r deviceQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r deviceQueryUpdatedAtDateTime) After(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r deviceQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r deviceQueryUpdatedAtDateTime) BeforeEquals(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r deviceQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r deviceQueryUpdatedAtDateTime) AfterEquals(value DateTime) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r deviceQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type deviceQueryNetIDsString struct{}

// Set the required value of NetIDs
func (r deviceQueryNetIDsString) Set(value []string) deviceSetParam {

	if value == nil {
		value = []string{}
	}

	return deviceSetParam{
		data: builder.Field{
			Name: "netIDs",
			Fields: []builder.Field{
				builder.Field{
					Name:  "set",
					Value: value,
				},
			},
		},
	}

}

// Set the optional value of NetIDs dynamically
func (r deviceQueryNetIDsString) SetIfPresent(value *[]string) deviceSetParam {
	if value == nil {
		return deviceSetParam{}
	}

	return r.Set(*value)
}

// Push the required value of NetIDs
func (r deviceQueryNetIDsString) Push(value []string) deviceSetParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return deviceSetParam{
		data: builder.Field{
			Name: "netIDs",
			Fields: []builder.Field{
				builder.Field{
					Name: "push",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r deviceQueryNetIDsString) PushIfPresent(value []string) deviceSetParam {
	if value == nil {
		return deviceSetParam{}
	}
	return r.Push(value)
}

func (r deviceQueryNetIDsString) Equals(value []string) deviceWithPrismaNetIDsEqualsParam {

	if value == nil {
		value = []string{}
	}

	return deviceWithPrismaNetIDsEqualsParam{
		data: builder.Field{
			Name: "netIDs",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryNetIDsString) EqualsIfPresent(value []string) deviceWithPrismaNetIDsEqualsParam {
	if value == nil {
		return deviceWithPrismaNetIDsEqualsParam{}
	}
	return r.Equals(value)
}

func (r deviceQueryNetIDsString) Order(direction SortOrder) deviceDefaultParam {
	return deviceDefaultParam{
		data: builder.Field{
			Name:  "netIDs",
			Value: direction,
		},
	}
}

func (r deviceQueryNetIDsString) Cursor(cursor string) deviceCursorParam {
	return deviceCursorParam{
		data: builder.Field{
			Name:  "netIDs",
			Value: cursor,
		},
	}
}

func (r deviceQueryNetIDsString) Has(value string) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "netIDs",
			Fields: []builder.Field{
				{
					Name: "has",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryNetIDsString) HasIfPresent(value *string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.Has(*value)
}

func (r deviceQueryNetIDsString) HasEvery(value []string) deviceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "netIDs",
			Fields: []builder.Field{
				{
					Name: "hasEvery",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r deviceQueryNetIDsString) HasEveryIfPresent(value []string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.HasEvery(value)
}

func (r deviceQueryNetIDsString) HasSome(value []string) deviceDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "netIDs",
			Fields: []builder.Field{
				{
					Name: "hasSome",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r deviceQueryNetIDsString) HasSomeIfPresent(value []string) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.HasSome(value)
}

func (r deviceQueryNetIDsString) IsEmpty(value bool) deviceDefaultParam {

	return deviceDefaultParam{
		data: builder.Field{
			Name: "netIDs",
			Fields: []builder.Field{
				{
					Name: "isEmpty",

					Value: value,
				},
			},
		},
	}
}

func (r deviceQueryNetIDsString) IsEmptyIfPresent(value *bool) deviceDefaultParam {
	if value == nil {
		return deviceDefaultParam{}
	}
	return r.IsEmpty(*value)
}

// base struct
type deviceQueryNetsDevicesOnNets struct{}

type deviceQueryNetsRelations struct{}

// Device -> Nets
//
// @relation
// @required
func (deviceQueryNetsRelations) Some(
	params ...DevicesOnNetsWhereParam,
) deviceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "nets",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Device -> Nets
//
// @relation
// @required
func (deviceQueryNetsRelations) Every(
	params ...DevicesOnNetsWhereParam,
) deviceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "nets",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (deviceQueryNetsRelations) Fetch(

	params ...DevicesOnNetsWhereParam,

) deviceToNetsFindMany {
	var v deviceToNetsFindMany

	v.query.Operation = "query"
	v.query.Method = "nets"
	v.query.Outputs = devicesOnNetsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r deviceQueryNetsRelations) Link(
	params ...DevicesOnNetsWhereParam,
) deviceSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return deviceSetParam{
		data: builder.Field{
			Name: "nets",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r deviceQueryNetsRelations) Unlink(
	params ...DevicesOnNetsWhereParam,
) deviceSetParam {
	var v deviceSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = deviceSetParam{
		data: builder.Field{
			Name: "nets",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type deviceQueryActionsAction struct{}

type deviceQueryActionsRelations struct{}

// Device -> Actions
//
// @relation
// @required
func (deviceQueryActionsRelations) Some(
	params ...ActionWhereParam,
) deviceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "actions",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Device -> Actions
//
// @relation
// @required
func (deviceQueryActionsRelations) Every(
	params ...ActionWhereParam,
) deviceDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return deviceDefaultParam{
		data: builder.Field{
			Name: "actions",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (deviceQueryActionsRelations) Fetch(

	params ...ActionWhereParam,

) deviceToActionsFindMany {
	var v deviceToActionsFindMany

	v.query.Operation = "query"
	v.query.Method = "actions"
	v.query.Outputs = actionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r deviceQueryActionsRelations) Link(
	params ...ActionWhereParam,
) deviceSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return deviceSetParam{
		data: builder.Field{
			Name: "actions",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r deviceQueryActionsRelations) Unlink(
	params ...ActionWhereParam,
) deviceSetParam {
	var v deviceSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = deviceSetParam{
		data: builder.Field{
			Name: "actions",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// Constant acts as a namespaces to access query methods for the Constant model
var Constant = constantQuery{}

// constantQuery exposes query functions for the constant model
type constantQuery struct {

	// ID
	//
	// @required
	ID constantQueryIDString

	Action constantQueryActionRelations

	// ActionID
	//
	// @required
	ActionID constantQueryActionIDString

	Field constantQueryFieldRelations

	// FieldID
	//
	// @required
	FieldID constantQueryFieldIDString

	// Value
	//
	// @required
	Value constantQueryValueString
}

func (constantQuery) Not(params ...ConstantWhereParam) constantDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return constantDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (constantQuery) Or(params ...ConstantWhereParam) constantDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return constantDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (constantQuery) And(params ...ConstantWhereParam) constantDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return constantDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type constantQueryIDString struct{}

// Set the required value of ID
func (r constantQueryIDString) Set(value string) constantSetParam {

	return constantSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r constantQueryIDString) SetIfPresent(value *string) constantSetParam {
	if value == nil {
		return constantSetParam{}
	}

	return r.Set(*value)
}

func (r constantQueryIDString) Equals(value string) constantWithPrismaIDEqualsUniqueParam {

	return constantWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r constantQueryIDString) EqualsIfPresent(value *string) constantWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return constantWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r constantQueryIDString) Order(direction SortOrder) constantDefaultParam {
	return constantDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r constantQueryIDString) Cursor(cursor string) constantCursorParam {
	return constantCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r constantQueryIDString) In(value []string) constantParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return constantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r constantQueryIDString) InIfPresent(value []string) constantParamUnique {
	if value == nil {
		return constantParamUnique{}
	}
	return r.In(value)
}

func (r constantQueryIDString) NotIn(value []string) constantParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return constantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r constantQueryIDString) NotInIfPresent(value []string) constantParamUnique {
	if value == nil {
		return constantParamUnique{}
	}
	return r.NotIn(value)
}

func (r constantQueryIDString) Lt(value string) constantParamUnique {

	return constantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryIDString) LtIfPresent(value *string) constantParamUnique {
	if value == nil {
		return constantParamUnique{}
	}
	return r.Lt(*value)
}

func (r constantQueryIDString) Lte(value string) constantParamUnique {

	return constantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryIDString) LteIfPresent(value *string) constantParamUnique {
	if value == nil {
		return constantParamUnique{}
	}
	return r.Lte(*value)
}

func (r constantQueryIDString) Gt(value string) constantParamUnique {

	return constantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryIDString) GtIfPresent(value *string) constantParamUnique {
	if value == nil {
		return constantParamUnique{}
	}
	return r.Gt(*value)
}

func (r constantQueryIDString) Gte(value string) constantParamUnique {

	return constantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryIDString) GteIfPresent(value *string) constantParamUnique {
	if value == nil {
		return constantParamUnique{}
	}
	return r.Gte(*value)
}

func (r constantQueryIDString) Contains(value string) constantParamUnique {

	return constantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryIDString) ContainsIfPresent(value *string) constantParamUnique {
	if value == nil {
		return constantParamUnique{}
	}
	return r.Contains(*value)
}

func (r constantQueryIDString) StartsWith(value string) constantParamUnique {

	return constantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryIDString) StartsWithIfPresent(value *string) constantParamUnique {
	if value == nil {
		return constantParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r constantQueryIDString) EndsWith(value string) constantParamUnique {

	return constantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryIDString) EndsWithIfPresent(value *string) constantParamUnique {
	if value == nil {
		return constantParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r constantQueryIDString) Mode(value QueryMode) constantParamUnique {

	return constantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryIDString) ModeIfPresent(value *QueryMode) constantParamUnique {
	if value == nil {
		return constantParamUnique{}
	}
	return r.Mode(*value)
}

func (r constantQueryIDString) Not(value string) constantParamUnique {

	return constantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryIDString) NotIfPresent(value *string) constantParamUnique {
	if value == nil {
		return constantParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r constantQueryIDString) HasPrefix(value string) constantParamUnique {

	return constantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r constantQueryIDString) HasPrefixIfPresent(value *string) constantParamUnique {
	if value == nil {
		return constantParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r constantQueryIDString) HasSuffix(value string) constantParamUnique {

	return constantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r constantQueryIDString) HasSuffixIfPresent(value *string) constantParamUnique {
	if value == nil {
		return constantParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type constantQueryActionAction struct{}

type constantQueryActionRelations struct{}

// Constant -> Action
//
// @relation
// @required
func (constantQueryActionRelations) Where(
	params ...ActionWhereParam,
) constantDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return constantDefaultParam{
		data: builder.Field{
			Name: "action",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (constantQueryActionRelations) Fetch() constantToActionFindUnique {
	var v constantToActionFindUnique

	v.query.Operation = "query"
	v.query.Method = "action"
	v.query.Outputs = actionOutput

	return v
}

func (r constantQueryActionRelations) Link(
	params ActionWhereParam,
) constantWithPrismaActionSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return constantWithPrismaActionSetParam{}
	}

	fields = append(fields, f)

	return constantWithPrismaActionSetParam{
		data: builder.Field{
			Name: "action",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r constantQueryActionRelations) Unlink() constantWithPrismaActionSetParam {
	var v constantWithPrismaActionSetParam

	v = constantWithPrismaActionSetParam{
		data: builder.Field{
			Name: "action",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type constantQueryActionIDString struct{}

// Set the required value of ActionID
func (r constantQueryActionIDString) Set(value string) constantSetParam {

	return constantSetParam{
		data: builder.Field{
			Name:  "actionID",
			Value: value,
		},
	}

}

// Set the optional value of ActionID dynamically
func (r constantQueryActionIDString) SetIfPresent(value *string) constantSetParam {
	if value == nil {
		return constantSetParam{}
	}

	return r.Set(*value)
}

func (r constantQueryActionIDString) Equals(value string) constantWithPrismaActionIDEqualsParam {

	return constantWithPrismaActionIDEqualsParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r constantQueryActionIDString) EqualsIfPresent(value *string) constantWithPrismaActionIDEqualsParam {
	if value == nil {
		return constantWithPrismaActionIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r constantQueryActionIDString) Order(direction SortOrder) constantDefaultParam {
	return constantDefaultParam{
		data: builder.Field{
			Name:  "actionID",
			Value: direction,
		},
	}
}

func (r constantQueryActionIDString) Cursor(cursor string) constantCursorParam {
	return constantCursorParam{
		data: builder.Field{
			Name:  "actionID",
			Value: cursor,
		},
	}
}

func (r constantQueryActionIDString) In(value []string) constantDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return constantDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r constantQueryActionIDString) InIfPresent(value []string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.In(value)
}

func (r constantQueryActionIDString) NotIn(value []string) constantDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return constantDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r constantQueryActionIDString) NotInIfPresent(value []string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.NotIn(value)
}

func (r constantQueryActionIDString) Lt(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryActionIDString) LtIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Lt(*value)
}

func (r constantQueryActionIDString) Lte(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryActionIDString) LteIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Lte(*value)
}

func (r constantQueryActionIDString) Gt(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryActionIDString) GtIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Gt(*value)
}

func (r constantQueryActionIDString) Gte(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryActionIDString) GteIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Gte(*value)
}

func (r constantQueryActionIDString) Contains(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryActionIDString) ContainsIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Contains(*value)
}

func (r constantQueryActionIDString) StartsWith(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryActionIDString) StartsWithIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r constantQueryActionIDString) EndsWith(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryActionIDString) EndsWithIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r constantQueryActionIDString) Mode(value QueryMode) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryActionIDString) ModeIfPresent(value *QueryMode) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Mode(*value)
}

func (r constantQueryActionIDString) Not(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryActionIDString) NotIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r constantQueryActionIDString) HasPrefix(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r constantQueryActionIDString) HasPrefixIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r constantQueryActionIDString) HasSuffix(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r constantQueryActionIDString) HasSuffixIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type constantQueryFieldField struct{}

type constantQueryFieldRelations struct{}

// Constant -> Field
//
// @relation
// @required
func (constantQueryFieldRelations) Where(
	params ...FieldWhereParam,
) constantDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return constantDefaultParam{
		data: builder.Field{
			Name: "field",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (constantQueryFieldRelations) Fetch() constantToFieldFindUnique {
	var v constantToFieldFindUnique

	v.query.Operation = "query"
	v.query.Method = "field"
	v.query.Outputs = fieldOutput

	return v
}

func (r constantQueryFieldRelations) Link(
	params FieldWhereParam,
) constantWithPrismaFieldSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return constantWithPrismaFieldSetParam{}
	}

	fields = append(fields, f)

	return constantWithPrismaFieldSetParam{
		data: builder.Field{
			Name: "field",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r constantQueryFieldRelations) Unlink() constantWithPrismaFieldSetParam {
	var v constantWithPrismaFieldSetParam

	v = constantWithPrismaFieldSetParam{
		data: builder.Field{
			Name: "field",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type constantQueryFieldIDString struct{}

// Set the required value of FieldID
func (r constantQueryFieldIDString) Set(value string) constantSetParam {

	return constantSetParam{
		data: builder.Field{
			Name:  "fieldID",
			Value: value,
		},
	}

}

// Set the optional value of FieldID dynamically
func (r constantQueryFieldIDString) SetIfPresent(value *string) constantSetParam {
	if value == nil {
		return constantSetParam{}
	}

	return r.Set(*value)
}

func (r constantQueryFieldIDString) Equals(value string) constantWithPrismaFieldIDEqualsParam {

	return constantWithPrismaFieldIDEqualsParam{
		data: builder.Field{
			Name: "fieldID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r constantQueryFieldIDString) EqualsIfPresent(value *string) constantWithPrismaFieldIDEqualsParam {
	if value == nil {
		return constantWithPrismaFieldIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r constantQueryFieldIDString) Order(direction SortOrder) constantDefaultParam {
	return constantDefaultParam{
		data: builder.Field{
			Name:  "fieldID",
			Value: direction,
		},
	}
}

func (r constantQueryFieldIDString) Cursor(cursor string) constantCursorParam {
	return constantCursorParam{
		data: builder.Field{
			Name:  "fieldID",
			Value: cursor,
		},
	}
}

func (r constantQueryFieldIDString) In(value []string) constantDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return constantDefaultParam{
		data: builder.Field{
			Name: "fieldID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r constantQueryFieldIDString) InIfPresent(value []string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.In(value)
}

func (r constantQueryFieldIDString) NotIn(value []string) constantDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return constantDefaultParam{
		data: builder.Field{
			Name: "fieldID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r constantQueryFieldIDString) NotInIfPresent(value []string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.NotIn(value)
}

func (r constantQueryFieldIDString) Lt(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "fieldID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryFieldIDString) LtIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Lt(*value)
}

func (r constantQueryFieldIDString) Lte(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "fieldID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryFieldIDString) LteIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Lte(*value)
}

func (r constantQueryFieldIDString) Gt(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "fieldID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryFieldIDString) GtIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Gt(*value)
}

func (r constantQueryFieldIDString) Gte(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "fieldID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryFieldIDString) GteIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Gte(*value)
}

func (r constantQueryFieldIDString) Contains(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "fieldID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryFieldIDString) ContainsIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Contains(*value)
}

func (r constantQueryFieldIDString) StartsWith(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "fieldID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryFieldIDString) StartsWithIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r constantQueryFieldIDString) EndsWith(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "fieldID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryFieldIDString) EndsWithIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r constantQueryFieldIDString) Mode(value QueryMode) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "fieldID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryFieldIDString) ModeIfPresent(value *QueryMode) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Mode(*value)
}

func (r constantQueryFieldIDString) Not(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "fieldID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryFieldIDString) NotIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r constantQueryFieldIDString) HasPrefix(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "fieldID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r constantQueryFieldIDString) HasPrefixIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r constantQueryFieldIDString) HasSuffix(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "fieldID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r constantQueryFieldIDString) HasSuffixIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type constantQueryValueString struct{}

// Set the required value of Value
func (r constantQueryValueString) Set(value string) constantWithPrismaValueSetParam {

	return constantWithPrismaValueSetParam{
		data: builder.Field{
			Name:  "value",
			Value: value,
		},
	}

}

// Set the optional value of Value dynamically
func (r constantQueryValueString) SetIfPresent(value *string) constantWithPrismaValueSetParam {
	if value == nil {
		return constantWithPrismaValueSetParam{}
	}

	return r.Set(*value)
}

func (r constantQueryValueString) Equals(value string) constantWithPrismaValueEqualsParam {

	return constantWithPrismaValueEqualsParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r constantQueryValueString) EqualsIfPresent(value *string) constantWithPrismaValueEqualsParam {
	if value == nil {
		return constantWithPrismaValueEqualsParam{}
	}
	return r.Equals(*value)
}

func (r constantQueryValueString) Order(direction SortOrder) constantDefaultParam {
	return constantDefaultParam{
		data: builder.Field{
			Name:  "value",
			Value: direction,
		},
	}
}

func (r constantQueryValueString) Cursor(cursor string) constantCursorParam {
	return constantCursorParam{
		data: builder.Field{
			Name:  "value",
			Value: cursor,
		},
	}
}

func (r constantQueryValueString) In(value []string) constantDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return constantDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r constantQueryValueString) InIfPresent(value []string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.In(value)
}

func (r constantQueryValueString) NotIn(value []string) constantDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return constantDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r constantQueryValueString) NotInIfPresent(value []string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.NotIn(value)
}

func (r constantQueryValueString) Lt(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryValueString) LtIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Lt(*value)
}

func (r constantQueryValueString) Lte(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryValueString) LteIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Lte(*value)
}

func (r constantQueryValueString) Gt(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryValueString) GtIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Gt(*value)
}

func (r constantQueryValueString) Gte(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryValueString) GteIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Gte(*value)
}

func (r constantQueryValueString) Contains(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryValueString) ContainsIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Contains(*value)
}

func (r constantQueryValueString) StartsWith(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryValueString) StartsWithIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r constantQueryValueString) EndsWith(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryValueString) EndsWithIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r constantQueryValueString) Mode(value QueryMode) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryValueString) ModeIfPresent(value *QueryMode) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Mode(*value)
}

func (r constantQueryValueString) Not(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r constantQueryValueString) NotIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r constantQueryValueString) HasPrefix(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r constantQueryValueString) HasPrefixIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r constantQueryValueString) HasSuffix(value string) constantDefaultParam {

	return constantDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r constantQueryValueString) HasSuffixIfPresent(value *string) constantDefaultParam {
	if value == nil {
		return constantDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// Action acts as a namespaces to access query methods for the Action model
var Action = actionQuery{}

// actionQuery exposes query functions for the action model
type actionQuery struct {

	// ID
	//
	// @required
	ID actionQueryIDString

	// Input
	//
	// @required
	Input actionQueryInputJson

	// Output
	//
	// @required
	Output actionQueryOutputJson

	Device actionQueryDeviceRelations

	// DeviceID
	//
	// @required
	DeviceID actionQueryDeviceIDString

	Event actionQueryEventRelations

	// EventID
	//
	// @required
	EventID actionQueryEventIDString

	// CreatedAt
	//
	// @required
	CreatedAt actionQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt actionQueryUpdatedAtDateTime

	Constants actionQueryConstantsRelations

	Steps actionQueryStepsRelations
}

func (actionQuery) Not(params ...ActionWhereParam) actionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return actionDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (actionQuery) Or(params ...ActionWhereParam) actionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return actionDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (actionQuery) And(params ...ActionWhereParam) actionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return actionDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type actionQueryIDString struct{}

// Set the required value of ID
func (r actionQueryIDString) Set(value string) actionSetParam {

	return actionSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r actionQueryIDString) SetIfPresent(value *string) actionSetParam {
	if value == nil {
		return actionSetParam{}
	}

	return r.Set(*value)
}

func (r actionQueryIDString) Equals(value string) actionWithPrismaIDEqualsUniqueParam {

	return actionWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r actionQueryIDString) EqualsIfPresent(value *string) actionWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return actionWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r actionQueryIDString) Order(direction SortOrder) actionDefaultParam {
	return actionDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r actionQueryIDString) Cursor(cursor string) actionCursorParam {
	return actionCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r actionQueryIDString) In(value []string) actionParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return actionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r actionQueryIDString) InIfPresent(value []string) actionParamUnique {
	if value == nil {
		return actionParamUnique{}
	}
	return r.In(value)
}

func (r actionQueryIDString) NotIn(value []string) actionParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return actionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r actionQueryIDString) NotInIfPresent(value []string) actionParamUnique {
	if value == nil {
		return actionParamUnique{}
	}
	return r.NotIn(value)
}

func (r actionQueryIDString) Lt(value string) actionParamUnique {

	return actionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryIDString) LtIfPresent(value *string) actionParamUnique {
	if value == nil {
		return actionParamUnique{}
	}
	return r.Lt(*value)
}

func (r actionQueryIDString) Lte(value string) actionParamUnique {

	return actionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryIDString) LteIfPresent(value *string) actionParamUnique {
	if value == nil {
		return actionParamUnique{}
	}
	return r.Lte(*value)
}

func (r actionQueryIDString) Gt(value string) actionParamUnique {

	return actionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryIDString) GtIfPresent(value *string) actionParamUnique {
	if value == nil {
		return actionParamUnique{}
	}
	return r.Gt(*value)
}

func (r actionQueryIDString) Gte(value string) actionParamUnique {

	return actionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryIDString) GteIfPresent(value *string) actionParamUnique {
	if value == nil {
		return actionParamUnique{}
	}
	return r.Gte(*value)
}

func (r actionQueryIDString) Contains(value string) actionParamUnique {

	return actionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryIDString) ContainsIfPresent(value *string) actionParamUnique {
	if value == nil {
		return actionParamUnique{}
	}
	return r.Contains(*value)
}

func (r actionQueryIDString) StartsWith(value string) actionParamUnique {

	return actionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryIDString) StartsWithIfPresent(value *string) actionParamUnique {
	if value == nil {
		return actionParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r actionQueryIDString) EndsWith(value string) actionParamUnique {

	return actionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryIDString) EndsWithIfPresent(value *string) actionParamUnique {
	if value == nil {
		return actionParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r actionQueryIDString) Mode(value QueryMode) actionParamUnique {

	return actionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryIDString) ModeIfPresent(value *QueryMode) actionParamUnique {
	if value == nil {
		return actionParamUnique{}
	}
	return r.Mode(*value)
}

func (r actionQueryIDString) Not(value string) actionParamUnique {

	return actionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryIDString) NotIfPresent(value *string) actionParamUnique {
	if value == nil {
		return actionParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r actionQueryIDString) HasPrefix(value string) actionParamUnique {

	return actionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r actionQueryIDString) HasPrefixIfPresent(value *string) actionParamUnique {
	if value == nil {
		return actionParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r actionQueryIDString) HasSuffix(value string) actionParamUnique {

	return actionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r actionQueryIDString) HasSuffixIfPresent(value *string) actionParamUnique {
	if value == nil {
		return actionParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type actionQueryInputJson struct{}

// Set the required value of Input
func (r actionQueryInputJson) Set(value JSON) actionWithPrismaInputSetParam {

	return actionWithPrismaInputSetParam{
		data: builder.Field{
			Name:  "input",
			Value: value,
		},
	}

}

// Set the optional value of Input dynamically
func (r actionQueryInputJson) SetIfPresent(value *JSON) actionWithPrismaInputSetParam {
	if value == nil {
		return actionWithPrismaInputSetParam{}
	}

	return r.Set(*value)
}

func (r actionQueryInputJson) Equals(value JSON) actionWithPrismaInputEqualsParam {

	return actionWithPrismaInputEqualsParam{
		data: builder.Field{
			Name: "input",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r actionQueryInputJson) EqualsIfPresent(value *JSON) actionWithPrismaInputEqualsParam {
	if value == nil {
		return actionWithPrismaInputEqualsParam{}
	}
	return r.Equals(*value)
}

func (r actionQueryInputJson) Order(direction SortOrder) actionDefaultParam {
	return actionDefaultParam{
		data: builder.Field{
			Name:  "input",
			Value: direction,
		},
	}
}

func (r actionQueryInputJson) Cursor(cursor JSON) actionCursorParam {
	return actionCursorParam{
		data: builder.Field{
			Name:  "input",
			Value: cursor,
		},
	}
}

func (r actionQueryInputJson) Path(value []string) actionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return actionDefaultParam{
		data: builder.Field{
			Name: "input",
			Fields: []builder.Field{
				{
					Name: "path",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r actionQueryInputJson) PathIfPresent(value []string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Path(value)
}

func (r actionQueryInputJson) StringContains(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "input",
			Fields: []builder.Field{
				{
					Name: "string_contains",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryInputJson) StringContainsIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.StringContains(*value)
}

func (r actionQueryInputJson) StringStartsWith(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "input",
			Fields: []builder.Field{
				{
					Name: "string_starts_with",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryInputJson) StringStartsWithIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.StringStartsWith(*value)
}

func (r actionQueryInputJson) StringEndsWith(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "input",
			Fields: []builder.Field{
				{
					Name: "string_ends_with",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryInputJson) StringEndsWithIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.StringEndsWith(*value)
}

func (r actionQueryInputJson) ArrayContains(value JSON) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "input",
			Fields: []builder.Field{
				{
					Name: "array_contains",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryInputJson) ArrayContainsIfPresent(value *JSON) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.ArrayContains(*value)
}

func (r actionQueryInputJson) ArrayStartsWith(value JSON) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "input",
			Fields: []builder.Field{
				{
					Name: "array_starts_with",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryInputJson) ArrayStartsWithIfPresent(value *JSON) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.ArrayStartsWith(*value)
}

func (r actionQueryInputJson) ArrayEndsWith(value JSON) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "input",
			Fields: []builder.Field{
				{
					Name: "array_ends_with",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryInputJson) ArrayEndsWithIfPresent(value *JSON) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.ArrayEndsWith(*value)
}

func (r actionQueryInputJson) Lt(value JSON) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "input",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryInputJson) LtIfPresent(value *JSON) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r actionQueryInputJson) Lte(value JSON) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "input",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryInputJson) LteIfPresent(value *JSON) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r actionQueryInputJson) Gt(value JSON) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "input",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryInputJson) GtIfPresent(value *JSON) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r actionQueryInputJson) Gte(value JSON) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "input",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryInputJson) GteIfPresent(value *JSON) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r actionQueryInputJson) Not(value JSONNullValueFilter) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "input",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryInputJson) NotIfPresent(value *JSONNullValueFilter) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Not(*value)
}

// base struct
type actionQueryOutputJson struct{}

// Set the required value of Output
func (r actionQueryOutputJson) Set(value JSON) actionWithPrismaOutputSetParam {

	return actionWithPrismaOutputSetParam{
		data: builder.Field{
			Name:  "output",
			Value: value,
		},
	}

}

// Set the optional value of Output dynamically
func (r actionQueryOutputJson) SetIfPresent(value *JSON) actionWithPrismaOutputSetParam {
	if value == nil {
		return actionWithPrismaOutputSetParam{}
	}

	return r.Set(*value)
}

func (r actionQueryOutputJson) Equals(value JSON) actionWithPrismaOutputEqualsParam {

	return actionWithPrismaOutputEqualsParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r actionQueryOutputJson) EqualsIfPresent(value *JSON) actionWithPrismaOutputEqualsParam {
	if value == nil {
		return actionWithPrismaOutputEqualsParam{}
	}
	return r.Equals(*value)
}

func (r actionQueryOutputJson) Order(direction SortOrder) actionDefaultParam {
	return actionDefaultParam{
		data: builder.Field{
			Name:  "output",
			Value: direction,
		},
	}
}

func (r actionQueryOutputJson) Cursor(cursor JSON) actionCursorParam {
	return actionCursorParam{
		data: builder.Field{
			Name:  "output",
			Value: cursor,
		},
	}
}

func (r actionQueryOutputJson) Path(value []string) actionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return actionDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name: "path",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r actionQueryOutputJson) PathIfPresent(value []string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Path(value)
}

func (r actionQueryOutputJson) StringContains(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name: "string_contains",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryOutputJson) StringContainsIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.StringContains(*value)
}

func (r actionQueryOutputJson) StringStartsWith(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name: "string_starts_with",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryOutputJson) StringStartsWithIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.StringStartsWith(*value)
}

func (r actionQueryOutputJson) StringEndsWith(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name: "string_ends_with",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryOutputJson) StringEndsWithIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.StringEndsWith(*value)
}

func (r actionQueryOutputJson) ArrayContains(value JSON) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name: "array_contains",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryOutputJson) ArrayContainsIfPresent(value *JSON) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.ArrayContains(*value)
}

func (r actionQueryOutputJson) ArrayStartsWith(value JSON) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name: "array_starts_with",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryOutputJson) ArrayStartsWithIfPresent(value *JSON) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.ArrayStartsWith(*value)
}

func (r actionQueryOutputJson) ArrayEndsWith(value JSON) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name: "array_ends_with",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryOutputJson) ArrayEndsWithIfPresent(value *JSON) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.ArrayEndsWith(*value)
}

func (r actionQueryOutputJson) Lt(value JSON) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryOutputJson) LtIfPresent(value *JSON) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r actionQueryOutputJson) Lte(value JSON) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryOutputJson) LteIfPresent(value *JSON) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r actionQueryOutputJson) Gt(value JSON) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryOutputJson) GtIfPresent(value *JSON) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r actionQueryOutputJson) Gte(value JSON) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryOutputJson) GteIfPresent(value *JSON) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r actionQueryOutputJson) Not(value JSONNullValueFilter) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryOutputJson) NotIfPresent(value *JSONNullValueFilter) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Not(*value)
}

// base struct
type actionQueryDeviceDevice struct{}

type actionQueryDeviceRelations struct{}

// Action -> Device
//
// @relation
// @required
func (actionQueryDeviceRelations) Where(
	params ...DeviceWhereParam,
) actionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return actionDefaultParam{
		data: builder.Field{
			Name: "device",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (actionQueryDeviceRelations) Fetch() actionToDeviceFindUnique {
	var v actionToDeviceFindUnique

	v.query.Operation = "query"
	v.query.Method = "device"
	v.query.Outputs = deviceOutput

	return v
}

func (r actionQueryDeviceRelations) Link(
	params DeviceWhereParam,
) actionWithPrismaDeviceSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return actionWithPrismaDeviceSetParam{}
	}

	fields = append(fields, f)

	return actionWithPrismaDeviceSetParam{
		data: builder.Field{
			Name: "device",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r actionQueryDeviceRelations) Unlink() actionWithPrismaDeviceSetParam {
	var v actionWithPrismaDeviceSetParam

	v = actionWithPrismaDeviceSetParam{
		data: builder.Field{
			Name: "device",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type actionQueryDeviceIDString struct{}

// Set the required value of DeviceID
func (r actionQueryDeviceIDString) Set(value string) actionSetParam {

	return actionSetParam{
		data: builder.Field{
			Name:  "deviceId",
			Value: value,
		},
	}

}

// Set the optional value of DeviceID dynamically
func (r actionQueryDeviceIDString) SetIfPresent(value *string) actionSetParam {
	if value == nil {
		return actionSetParam{}
	}

	return r.Set(*value)
}

func (r actionQueryDeviceIDString) Equals(value string) actionWithPrismaDeviceIDEqualsParam {

	return actionWithPrismaDeviceIDEqualsParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r actionQueryDeviceIDString) EqualsIfPresent(value *string) actionWithPrismaDeviceIDEqualsParam {
	if value == nil {
		return actionWithPrismaDeviceIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r actionQueryDeviceIDString) Order(direction SortOrder) actionDefaultParam {
	return actionDefaultParam{
		data: builder.Field{
			Name:  "deviceId",
			Value: direction,
		},
	}
}

func (r actionQueryDeviceIDString) Cursor(cursor string) actionCursorParam {
	return actionCursorParam{
		data: builder.Field{
			Name:  "deviceId",
			Value: cursor,
		},
	}
}

func (r actionQueryDeviceIDString) In(value []string) actionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return actionDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r actionQueryDeviceIDString) InIfPresent(value []string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.In(value)
}

func (r actionQueryDeviceIDString) NotIn(value []string) actionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return actionDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r actionQueryDeviceIDString) NotInIfPresent(value []string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r actionQueryDeviceIDString) Lt(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryDeviceIDString) LtIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r actionQueryDeviceIDString) Lte(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryDeviceIDString) LteIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r actionQueryDeviceIDString) Gt(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryDeviceIDString) GtIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r actionQueryDeviceIDString) Gte(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryDeviceIDString) GteIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r actionQueryDeviceIDString) Contains(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryDeviceIDString) ContainsIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Contains(*value)
}

func (r actionQueryDeviceIDString) StartsWith(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryDeviceIDString) StartsWithIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r actionQueryDeviceIDString) EndsWith(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryDeviceIDString) EndsWithIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r actionQueryDeviceIDString) Mode(value QueryMode) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryDeviceIDString) ModeIfPresent(value *QueryMode) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Mode(*value)
}

func (r actionQueryDeviceIDString) Not(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryDeviceIDString) NotIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r actionQueryDeviceIDString) HasPrefix(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r actionQueryDeviceIDString) HasPrefixIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r actionQueryDeviceIDString) HasSuffix(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "deviceId",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r actionQueryDeviceIDString) HasSuffixIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type actionQueryEventEvent struct{}

type actionQueryEventRelations struct{}

// Action -> Event
//
// @relation
// @required
func (actionQueryEventRelations) Where(
	params ...EventWhereParam,
) actionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return actionDefaultParam{
		data: builder.Field{
			Name: "event",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (actionQueryEventRelations) Fetch() actionToEventFindUnique {
	var v actionToEventFindUnique

	v.query.Operation = "query"
	v.query.Method = "event"
	v.query.Outputs = eventOutput

	return v
}

func (r actionQueryEventRelations) Link(
	params EventWhereParam,
) actionWithPrismaEventSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return actionWithPrismaEventSetParam{}
	}

	fields = append(fields, f)

	return actionWithPrismaEventSetParam{
		data: builder.Field{
			Name: "event",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r actionQueryEventRelations) Unlink() actionWithPrismaEventSetParam {
	var v actionWithPrismaEventSetParam

	v = actionWithPrismaEventSetParam{
		data: builder.Field{
			Name: "event",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type actionQueryEventIDString struct{}

// Set the required value of EventID
func (r actionQueryEventIDString) Set(value string) actionSetParam {

	return actionSetParam{
		data: builder.Field{
			Name:  "eventID",
			Value: value,
		},
	}

}

// Set the optional value of EventID dynamically
func (r actionQueryEventIDString) SetIfPresent(value *string) actionSetParam {
	if value == nil {
		return actionSetParam{}
	}

	return r.Set(*value)
}

func (r actionQueryEventIDString) Equals(value string) actionWithPrismaEventIDEqualsParam {

	return actionWithPrismaEventIDEqualsParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r actionQueryEventIDString) EqualsIfPresent(value *string) actionWithPrismaEventIDEqualsParam {
	if value == nil {
		return actionWithPrismaEventIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r actionQueryEventIDString) Order(direction SortOrder) actionDefaultParam {
	return actionDefaultParam{
		data: builder.Field{
			Name:  "eventID",
			Value: direction,
		},
	}
}

func (r actionQueryEventIDString) Cursor(cursor string) actionCursorParam {
	return actionCursorParam{
		data: builder.Field{
			Name:  "eventID",
			Value: cursor,
		},
	}
}

func (r actionQueryEventIDString) In(value []string) actionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return actionDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r actionQueryEventIDString) InIfPresent(value []string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.In(value)
}

func (r actionQueryEventIDString) NotIn(value []string) actionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return actionDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r actionQueryEventIDString) NotInIfPresent(value []string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r actionQueryEventIDString) Lt(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryEventIDString) LtIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r actionQueryEventIDString) Lte(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryEventIDString) LteIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r actionQueryEventIDString) Gt(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryEventIDString) GtIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r actionQueryEventIDString) Gte(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryEventIDString) GteIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r actionQueryEventIDString) Contains(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryEventIDString) ContainsIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Contains(*value)
}

func (r actionQueryEventIDString) StartsWith(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryEventIDString) StartsWithIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r actionQueryEventIDString) EndsWith(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryEventIDString) EndsWithIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r actionQueryEventIDString) Mode(value QueryMode) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryEventIDString) ModeIfPresent(value *QueryMode) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Mode(*value)
}

func (r actionQueryEventIDString) Not(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryEventIDString) NotIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r actionQueryEventIDString) HasPrefix(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r actionQueryEventIDString) HasPrefixIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r actionQueryEventIDString) HasSuffix(value string) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "eventID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r actionQueryEventIDString) HasSuffixIfPresent(value *string) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type actionQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r actionQueryCreatedAtDateTime) Set(value DateTime) actionSetParam {

	return actionSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r actionQueryCreatedAtDateTime) SetIfPresent(value *DateTime) actionSetParam {
	if value == nil {
		return actionSetParam{}
	}

	return r.Set(*value)
}

func (r actionQueryCreatedAtDateTime) Equals(value DateTime) actionWithPrismaCreatedAtEqualsParam {

	return actionWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r actionQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) actionWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return actionWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r actionQueryCreatedAtDateTime) Order(direction SortOrder) actionDefaultParam {
	return actionDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r actionQueryCreatedAtDateTime) Cursor(cursor DateTime) actionCursorParam {
	return actionCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r actionQueryCreatedAtDateTime) In(value []DateTime) actionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return actionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r actionQueryCreatedAtDateTime) InIfPresent(value []DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.In(value)
}

func (r actionQueryCreatedAtDateTime) NotIn(value []DateTime) actionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return actionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r actionQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r actionQueryCreatedAtDateTime) Lt(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryCreatedAtDateTime) LtIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r actionQueryCreatedAtDateTime) Lte(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryCreatedAtDateTime) LteIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r actionQueryCreatedAtDateTime) Gt(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryCreatedAtDateTime) GtIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r actionQueryCreatedAtDateTime) Gte(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryCreatedAtDateTime) GteIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r actionQueryCreatedAtDateTime) Not(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryCreatedAtDateTime) NotIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r actionQueryCreatedAtDateTime) Before(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r actionQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r actionQueryCreatedAtDateTime) After(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r actionQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r actionQueryCreatedAtDateTime) BeforeEquals(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r actionQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r actionQueryCreatedAtDateTime) AfterEquals(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r actionQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type actionQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r actionQueryUpdatedAtDateTime) Set(value DateTime) actionSetParam {

	return actionSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r actionQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) actionSetParam {
	if value == nil {
		return actionSetParam{}
	}

	return r.Set(*value)
}

func (r actionQueryUpdatedAtDateTime) Equals(value DateTime) actionWithPrismaUpdatedAtEqualsParam {

	return actionWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r actionQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) actionWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return actionWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r actionQueryUpdatedAtDateTime) Order(direction SortOrder) actionDefaultParam {
	return actionDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r actionQueryUpdatedAtDateTime) Cursor(cursor DateTime) actionCursorParam {
	return actionCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r actionQueryUpdatedAtDateTime) In(value []DateTime) actionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return actionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r actionQueryUpdatedAtDateTime) InIfPresent(value []DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.In(value)
}

func (r actionQueryUpdatedAtDateTime) NotIn(value []DateTime) actionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return actionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r actionQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r actionQueryUpdatedAtDateTime) Lt(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r actionQueryUpdatedAtDateTime) Lte(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r actionQueryUpdatedAtDateTime) Gt(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r actionQueryUpdatedAtDateTime) Gte(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r actionQueryUpdatedAtDateTime) Not(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r actionQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r actionQueryUpdatedAtDateTime) Before(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r actionQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r actionQueryUpdatedAtDateTime) After(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r actionQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r actionQueryUpdatedAtDateTime) BeforeEquals(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r actionQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r actionQueryUpdatedAtDateTime) AfterEquals(value DateTime) actionDefaultParam {

	return actionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r actionQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) actionDefaultParam {
	if value == nil {
		return actionDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type actionQueryConstantsConstant struct{}

type actionQueryConstantsRelations struct{}

// Action -> Constants
//
// @relation
// @required
func (actionQueryConstantsRelations) Some(
	params ...ConstantWhereParam,
) actionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return actionDefaultParam{
		data: builder.Field{
			Name: "constants",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Action -> Constants
//
// @relation
// @required
func (actionQueryConstantsRelations) Every(
	params ...ConstantWhereParam,
) actionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return actionDefaultParam{
		data: builder.Field{
			Name: "constants",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (actionQueryConstantsRelations) Fetch(

	params ...ConstantWhereParam,

) actionToConstantsFindMany {
	var v actionToConstantsFindMany

	v.query.Operation = "query"
	v.query.Method = "constants"
	v.query.Outputs = constantOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r actionQueryConstantsRelations) Link(
	params ...ConstantWhereParam,
) actionSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return actionSetParam{
		data: builder.Field{
			Name: "constants",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r actionQueryConstantsRelations) Unlink(
	params ...ConstantWhereParam,
) actionSetParam {
	var v actionSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = actionSetParam{
		data: builder.Field{
			Name: "constants",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type actionQueryStepsStep struct{}

type actionQueryStepsRelations struct{}

// Action -> Steps
//
// @relation
// @required
func (actionQueryStepsRelations) Some(
	params ...StepWhereParam,
) actionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return actionDefaultParam{
		data: builder.Field{
			Name: "steps",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Action -> Steps
//
// @relation
// @required
func (actionQueryStepsRelations) Every(
	params ...StepWhereParam,
) actionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return actionDefaultParam{
		data: builder.Field{
			Name: "steps",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (actionQueryStepsRelations) Fetch(

	params ...StepWhereParam,

) actionToStepsFindMany {
	var v actionToStepsFindMany

	v.query.Operation = "query"
	v.query.Method = "steps"
	v.query.Outputs = stepOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r actionQueryStepsRelations) Link(
	params ...StepWhereParam,
) actionSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return actionSetParam{
		data: builder.Field{
			Name: "steps",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r actionQueryStepsRelations) Unlink(
	params ...StepWhereParam,
) actionSetParam {
	var v actionSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = actionSetParam{
		data: builder.Field{
			Name: "steps",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// Step acts as a namespaces to access query methods for the Step model
var Step = stepQuery{}

// stepQuery exposes query functions for the step model
type stepQuery struct {

	// ID
	//
	// @required
	ID stepQueryIDString

	// Order
	//
	// @required
	Order stepQueryOrderInt

	Run stepQueryRunRelations

	// RunID
	//
	// @required
	RunID stepQueryRunIDString

	Action stepQueryActionRelations

	// ActionID
	//
	// @required
	ActionID stepQueryActionIDString
}

func (stepQuery) Not(params ...StepWhereParam) stepDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return stepDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (stepQuery) Or(params ...StepWhereParam) stepDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return stepDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (stepQuery) And(params ...StepWhereParam) stepDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return stepDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type stepQueryIDString struct{}

// Set the required value of ID
func (r stepQueryIDString) Set(value string) stepSetParam {

	return stepSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r stepQueryIDString) SetIfPresent(value *string) stepSetParam {
	if value == nil {
		return stepSetParam{}
	}

	return r.Set(*value)
}

func (r stepQueryIDString) Equals(value string) stepWithPrismaIDEqualsUniqueParam {

	return stepWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r stepQueryIDString) EqualsIfPresent(value *string) stepWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return stepWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r stepQueryIDString) Order(direction SortOrder) stepDefaultParam {
	return stepDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r stepQueryIDString) Cursor(cursor string) stepCursorParam {
	return stepCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r stepQueryIDString) In(value []string) stepParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return stepParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r stepQueryIDString) InIfPresent(value []string) stepParamUnique {
	if value == nil {
		return stepParamUnique{}
	}
	return r.In(value)
}

func (r stepQueryIDString) NotIn(value []string) stepParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return stepParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r stepQueryIDString) NotInIfPresent(value []string) stepParamUnique {
	if value == nil {
		return stepParamUnique{}
	}
	return r.NotIn(value)
}

func (r stepQueryIDString) Lt(value string) stepParamUnique {

	return stepParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryIDString) LtIfPresent(value *string) stepParamUnique {
	if value == nil {
		return stepParamUnique{}
	}
	return r.Lt(*value)
}

func (r stepQueryIDString) Lte(value string) stepParamUnique {

	return stepParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryIDString) LteIfPresent(value *string) stepParamUnique {
	if value == nil {
		return stepParamUnique{}
	}
	return r.Lte(*value)
}

func (r stepQueryIDString) Gt(value string) stepParamUnique {

	return stepParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryIDString) GtIfPresent(value *string) stepParamUnique {
	if value == nil {
		return stepParamUnique{}
	}
	return r.Gt(*value)
}

func (r stepQueryIDString) Gte(value string) stepParamUnique {

	return stepParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryIDString) GteIfPresent(value *string) stepParamUnique {
	if value == nil {
		return stepParamUnique{}
	}
	return r.Gte(*value)
}

func (r stepQueryIDString) Contains(value string) stepParamUnique {

	return stepParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryIDString) ContainsIfPresent(value *string) stepParamUnique {
	if value == nil {
		return stepParamUnique{}
	}
	return r.Contains(*value)
}

func (r stepQueryIDString) StartsWith(value string) stepParamUnique {

	return stepParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryIDString) StartsWithIfPresent(value *string) stepParamUnique {
	if value == nil {
		return stepParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r stepQueryIDString) EndsWith(value string) stepParamUnique {

	return stepParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryIDString) EndsWithIfPresent(value *string) stepParamUnique {
	if value == nil {
		return stepParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r stepQueryIDString) Mode(value QueryMode) stepParamUnique {

	return stepParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryIDString) ModeIfPresent(value *QueryMode) stepParamUnique {
	if value == nil {
		return stepParamUnique{}
	}
	return r.Mode(*value)
}

func (r stepQueryIDString) Not(value string) stepParamUnique {

	return stepParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryIDString) NotIfPresent(value *string) stepParamUnique {
	if value == nil {
		return stepParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r stepQueryIDString) HasPrefix(value string) stepParamUnique {

	return stepParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r stepQueryIDString) HasPrefixIfPresent(value *string) stepParamUnique {
	if value == nil {
		return stepParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r stepQueryIDString) HasSuffix(value string) stepParamUnique {

	return stepParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r stepQueryIDString) HasSuffixIfPresent(value *string) stepParamUnique {
	if value == nil {
		return stepParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type stepQueryOrderInt struct{}

// Set the required value of Order
func (r stepQueryOrderInt) Set(value int) stepWithPrismaOrderSetParam {

	return stepWithPrismaOrderSetParam{
		data: builder.Field{
			Name:  "order",
			Value: value,
		},
	}

}

// Set the optional value of Order dynamically
func (r stepQueryOrderInt) SetIfPresent(value *int) stepWithPrismaOrderSetParam {
	if value == nil {
		return stepWithPrismaOrderSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Order
func (r stepQueryOrderInt) Increment(value int) stepWithPrismaOrderSetParam {

	return stepWithPrismaOrderSetParam{
		data: builder.Field{
			Name: "order",
			Fields: []builder.Field{
				builder.Field{
					Name: "increment",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryOrderInt) IncrementIfPresent(value *int) stepWithPrismaOrderSetParam {
	if value == nil {
		return stepWithPrismaOrderSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Order
func (r stepQueryOrderInt) Decrement(value int) stepWithPrismaOrderSetParam {

	return stepWithPrismaOrderSetParam{
		data: builder.Field{
			Name: "order",
			Fields: []builder.Field{
				builder.Field{
					Name: "decrement",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryOrderInt) DecrementIfPresent(value *int) stepWithPrismaOrderSetParam {
	if value == nil {
		return stepWithPrismaOrderSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Order
func (r stepQueryOrderInt) Multiply(value int) stepWithPrismaOrderSetParam {

	return stepWithPrismaOrderSetParam{
		data: builder.Field{
			Name: "order",
			Fields: []builder.Field{
				builder.Field{
					Name: "multiply",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryOrderInt) MultiplyIfPresent(value *int) stepWithPrismaOrderSetParam {
	if value == nil {
		return stepWithPrismaOrderSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Order
func (r stepQueryOrderInt) Divide(value int) stepWithPrismaOrderSetParam {

	return stepWithPrismaOrderSetParam{
		data: builder.Field{
			Name: "order",
			Fields: []builder.Field{
				builder.Field{
					Name: "divide",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryOrderInt) DivideIfPresent(value *int) stepWithPrismaOrderSetParam {
	if value == nil {
		return stepWithPrismaOrderSetParam{}
	}
	return r.Divide(*value)
}

func (r stepQueryOrderInt) Equals(value int) stepWithPrismaOrderEqualsParam {

	return stepWithPrismaOrderEqualsParam{
		data: builder.Field{
			Name: "order",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r stepQueryOrderInt) EqualsIfPresent(value *int) stepWithPrismaOrderEqualsParam {
	if value == nil {
		return stepWithPrismaOrderEqualsParam{}
	}
	return r.Equals(*value)
}

func (r stepQueryOrderInt) Order(direction SortOrder) stepDefaultParam {
	return stepDefaultParam{
		data: builder.Field{
			Name:  "order",
			Value: direction,
		},
	}
}

func (r stepQueryOrderInt) Cursor(cursor int) stepCursorParam {
	return stepCursorParam{
		data: builder.Field{
			Name:  "order",
			Value: cursor,
		},
	}
}

func (r stepQueryOrderInt) In(value []int) stepDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return stepDefaultParam{
		data: builder.Field{
			Name: "order",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r stepQueryOrderInt) InIfPresent(value []int) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.In(value)
}

func (r stepQueryOrderInt) NotIn(value []int) stepDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return stepDefaultParam{
		data: builder.Field{
			Name: "order",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r stepQueryOrderInt) NotInIfPresent(value []int) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.NotIn(value)
}

func (r stepQueryOrderInt) Lt(value int) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "order",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryOrderInt) LtIfPresent(value *int) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Lt(*value)
}

func (r stepQueryOrderInt) Lte(value int) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "order",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryOrderInt) LteIfPresent(value *int) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Lte(*value)
}

func (r stepQueryOrderInt) Gt(value int) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "order",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryOrderInt) GtIfPresent(value *int) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Gt(*value)
}

func (r stepQueryOrderInt) Gte(value int) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "order",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryOrderInt) GteIfPresent(value *int) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Gte(*value)
}

func (r stepQueryOrderInt) Not(value int) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "order",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryOrderInt) NotIfPresent(value *int) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r stepQueryOrderInt) LT(value int) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "order",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r stepQueryOrderInt) LTIfPresent(value *int) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r stepQueryOrderInt) LTE(value int) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "order",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r stepQueryOrderInt) LTEIfPresent(value *int) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r stepQueryOrderInt) GT(value int) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "order",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r stepQueryOrderInt) GTIfPresent(value *int) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r stepQueryOrderInt) GTE(value int) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "order",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r stepQueryOrderInt) GTEIfPresent(value *int) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.GTE(*value)
}

// base struct
type stepQueryRunRun struct{}

type stepQueryRunRelations struct{}

// Step -> Run
//
// @relation
// @required
func (stepQueryRunRelations) Where(
	params ...RunWhereParam,
) stepDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return stepDefaultParam{
		data: builder.Field{
			Name: "run",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (stepQueryRunRelations) Fetch() stepToRunFindUnique {
	var v stepToRunFindUnique

	v.query.Operation = "query"
	v.query.Method = "run"
	v.query.Outputs = runOutput

	return v
}

func (r stepQueryRunRelations) Link(
	params RunWhereParam,
) stepWithPrismaRunSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return stepWithPrismaRunSetParam{}
	}

	fields = append(fields, f)

	return stepWithPrismaRunSetParam{
		data: builder.Field{
			Name: "run",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r stepQueryRunRelations) Unlink() stepWithPrismaRunSetParam {
	var v stepWithPrismaRunSetParam

	v = stepWithPrismaRunSetParam{
		data: builder.Field{
			Name: "run",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type stepQueryRunIDString struct{}

// Set the required value of RunID
func (r stepQueryRunIDString) Set(value string) stepSetParam {

	return stepSetParam{
		data: builder.Field{
			Name:  "runID",
			Value: value,
		},
	}

}

// Set the optional value of RunID dynamically
func (r stepQueryRunIDString) SetIfPresent(value *string) stepSetParam {
	if value == nil {
		return stepSetParam{}
	}

	return r.Set(*value)
}

func (r stepQueryRunIDString) Equals(value string) stepWithPrismaRunIDEqualsParam {

	return stepWithPrismaRunIDEqualsParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r stepQueryRunIDString) EqualsIfPresent(value *string) stepWithPrismaRunIDEqualsParam {
	if value == nil {
		return stepWithPrismaRunIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r stepQueryRunIDString) Order(direction SortOrder) stepDefaultParam {
	return stepDefaultParam{
		data: builder.Field{
			Name:  "runID",
			Value: direction,
		},
	}
}

func (r stepQueryRunIDString) Cursor(cursor string) stepCursorParam {
	return stepCursorParam{
		data: builder.Field{
			Name:  "runID",
			Value: cursor,
		},
	}
}

func (r stepQueryRunIDString) In(value []string) stepDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return stepDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r stepQueryRunIDString) InIfPresent(value []string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.In(value)
}

func (r stepQueryRunIDString) NotIn(value []string) stepDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return stepDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r stepQueryRunIDString) NotInIfPresent(value []string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.NotIn(value)
}

func (r stepQueryRunIDString) Lt(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryRunIDString) LtIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Lt(*value)
}

func (r stepQueryRunIDString) Lte(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryRunIDString) LteIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Lte(*value)
}

func (r stepQueryRunIDString) Gt(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryRunIDString) GtIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Gt(*value)
}

func (r stepQueryRunIDString) Gte(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryRunIDString) GteIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Gte(*value)
}

func (r stepQueryRunIDString) Contains(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryRunIDString) ContainsIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Contains(*value)
}

func (r stepQueryRunIDString) StartsWith(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryRunIDString) StartsWithIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r stepQueryRunIDString) EndsWith(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryRunIDString) EndsWithIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r stepQueryRunIDString) Mode(value QueryMode) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryRunIDString) ModeIfPresent(value *QueryMode) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Mode(*value)
}

func (r stepQueryRunIDString) Not(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryRunIDString) NotIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r stepQueryRunIDString) HasPrefix(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r stepQueryRunIDString) HasPrefixIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r stepQueryRunIDString) HasSuffix(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r stepQueryRunIDString) HasSuffixIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type stepQueryActionAction struct{}

type stepQueryActionRelations struct{}

// Step -> Action
//
// @relation
// @required
func (stepQueryActionRelations) Where(
	params ...ActionWhereParam,
) stepDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return stepDefaultParam{
		data: builder.Field{
			Name: "action",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (stepQueryActionRelations) Fetch() stepToActionFindUnique {
	var v stepToActionFindUnique

	v.query.Operation = "query"
	v.query.Method = "action"
	v.query.Outputs = actionOutput

	return v
}

func (r stepQueryActionRelations) Link(
	params ActionWhereParam,
) stepWithPrismaActionSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return stepWithPrismaActionSetParam{}
	}

	fields = append(fields, f)

	return stepWithPrismaActionSetParam{
		data: builder.Field{
			Name: "action",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r stepQueryActionRelations) Unlink() stepWithPrismaActionSetParam {
	var v stepWithPrismaActionSetParam

	v = stepWithPrismaActionSetParam{
		data: builder.Field{
			Name: "action",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type stepQueryActionIDString struct{}

// Set the required value of ActionID
func (r stepQueryActionIDString) Set(value string) stepSetParam {

	return stepSetParam{
		data: builder.Field{
			Name:  "actionID",
			Value: value,
		},
	}

}

// Set the optional value of ActionID dynamically
func (r stepQueryActionIDString) SetIfPresent(value *string) stepSetParam {
	if value == nil {
		return stepSetParam{}
	}

	return r.Set(*value)
}

func (r stepQueryActionIDString) Equals(value string) stepWithPrismaActionIDEqualsParam {

	return stepWithPrismaActionIDEqualsParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r stepQueryActionIDString) EqualsIfPresent(value *string) stepWithPrismaActionIDEqualsParam {
	if value == nil {
		return stepWithPrismaActionIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r stepQueryActionIDString) Order(direction SortOrder) stepDefaultParam {
	return stepDefaultParam{
		data: builder.Field{
			Name:  "actionID",
			Value: direction,
		},
	}
}

func (r stepQueryActionIDString) Cursor(cursor string) stepCursorParam {
	return stepCursorParam{
		data: builder.Field{
			Name:  "actionID",
			Value: cursor,
		},
	}
}

func (r stepQueryActionIDString) In(value []string) stepDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return stepDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r stepQueryActionIDString) InIfPresent(value []string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.In(value)
}

func (r stepQueryActionIDString) NotIn(value []string) stepDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return stepDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r stepQueryActionIDString) NotInIfPresent(value []string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.NotIn(value)
}

func (r stepQueryActionIDString) Lt(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryActionIDString) LtIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Lt(*value)
}

func (r stepQueryActionIDString) Lte(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryActionIDString) LteIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Lte(*value)
}

func (r stepQueryActionIDString) Gt(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryActionIDString) GtIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Gt(*value)
}

func (r stepQueryActionIDString) Gte(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryActionIDString) GteIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Gte(*value)
}

func (r stepQueryActionIDString) Contains(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryActionIDString) ContainsIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Contains(*value)
}

func (r stepQueryActionIDString) StartsWith(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryActionIDString) StartsWithIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r stepQueryActionIDString) EndsWith(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryActionIDString) EndsWithIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r stepQueryActionIDString) Mode(value QueryMode) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryActionIDString) ModeIfPresent(value *QueryMode) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Mode(*value)
}

func (r stepQueryActionIDString) Not(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r stepQueryActionIDString) NotIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r stepQueryActionIDString) HasPrefix(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r stepQueryActionIDString) HasPrefixIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r stepQueryActionIDString) HasSuffix(value string) stepDefaultParam {

	return stepDefaultParam{
		data: builder.Field{
			Name: "actionID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r stepQueryActionIDString) HasSuffixIfPresent(value *string) stepDefaultParam {
	if value == nil {
		return stepDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// Run acts as a namespaces to access query methods for the Run model
var Run = runQuery{}

// runQuery exposes query functions for the run model
type runQuery struct {

	// ID
	//
	// @required
	ID runQueryIDString

	// Name
	//
	// @required
	Name runQueryNameString

	// Description
	//
	// @required
	Description runQueryDescriptionString

	// CreatedAt
	//
	// @required
	CreatedAt runQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt runQueryUpdatedAtDateTime

	Net runQueryNetRelations

	// NetID
	//
	// @required
	NetID runQueryNetIDString

	Sessions runQuerySessionsRelations

	Steps runQueryStepsRelations
}

func (runQuery) Not(params ...RunWhereParam) runDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return runDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (runQuery) Or(params ...RunWhereParam) runDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return runDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (runQuery) And(params ...RunWhereParam) runDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return runDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type runQueryIDString struct{}

// Set the required value of ID
func (r runQueryIDString) Set(value string) runSetParam {

	return runSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r runQueryIDString) SetIfPresent(value *string) runSetParam {
	if value == nil {
		return runSetParam{}
	}

	return r.Set(*value)
}

func (r runQueryIDString) Equals(value string) runWithPrismaIDEqualsUniqueParam {

	return runWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r runQueryIDString) EqualsIfPresent(value *string) runWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return runWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r runQueryIDString) Order(direction SortOrder) runDefaultParam {
	return runDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r runQueryIDString) Cursor(cursor string) runCursorParam {
	return runCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r runQueryIDString) In(value []string) runParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return runParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r runQueryIDString) InIfPresent(value []string) runParamUnique {
	if value == nil {
		return runParamUnique{}
	}
	return r.In(value)
}

func (r runQueryIDString) NotIn(value []string) runParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return runParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r runQueryIDString) NotInIfPresent(value []string) runParamUnique {
	if value == nil {
		return runParamUnique{}
	}
	return r.NotIn(value)
}

func (r runQueryIDString) Lt(value string) runParamUnique {

	return runParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryIDString) LtIfPresent(value *string) runParamUnique {
	if value == nil {
		return runParamUnique{}
	}
	return r.Lt(*value)
}

func (r runQueryIDString) Lte(value string) runParamUnique {

	return runParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryIDString) LteIfPresent(value *string) runParamUnique {
	if value == nil {
		return runParamUnique{}
	}
	return r.Lte(*value)
}

func (r runQueryIDString) Gt(value string) runParamUnique {

	return runParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryIDString) GtIfPresent(value *string) runParamUnique {
	if value == nil {
		return runParamUnique{}
	}
	return r.Gt(*value)
}

func (r runQueryIDString) Gte(value string) runParamUnique {

	return runParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryIDString) GteIfPresent(value *string) runParamUnique {
	if value == nil {
		return runParamUnique{}
	}
	return r.Gte(*value)
}

func (r runQueryIDString) Contains(value string) runParamUnique {

	return runParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryIDString) ContainsIfPresent(value *string) runParamUnique {
	if value == nil {
		return runParamUnique{}
	}
	return r.Contains(*value)
}

func (r runQueryIDString) StartsWith(value string) runParamUnique {

	return runParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryIDString) StartsWithIfPresent(value *string) runParamUnique {
	if value == nil {
		return runParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r runQueryIDString) EndsWith(value string) runParamUnique {

	return runParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryIDString) EndsWithIfPresent(value *string) runParamUnique {
	if value == nil {
		return runParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r runQueryIDString) Mode(value QueryMode) runParamUnique {

	return runParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryIDString) ModeIfPresent(value *QueryMode) runParamUnique {
	if value == nil {
		return runParamUnique{}
	}
	return r.Mode(*value)
}

func (r runQueryIDString) Not(value string) runParamUnique {

	return runParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryIDString) NotIfPresent(value *string) runParamUnique {
	if value == nil {
		return runParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r runQueryIDString) HasPrefix(value string) runParamUnique {

	return runParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r runQueryIDString) HasPrefixIfPresent(value *string) runParamUnique {
	if value == nil {
		return runParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r runQueryIDString) HasSuffix(value string) runParamUnique {

	return runParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r runQueryIDString) HasSuffixIfPresent(value *string) runParamUnique {
	if value == nil {
		return runParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type runQueryNameString struct{}

// Set the required value of Name
func (r runQueryNameString) Set(value string) runWithPrismaNameSetParam {

	return runWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r runQueryNameString) SetIfPresent(value *string) runWithPrismaNameSetParam {
	if value == nil {
		return runWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r runQueryNameString) Equals(value string) runWithPrismaNameEqualsParam {

	return runWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r runQueryNameString) EqualsIfPresent(value *string) runWithPrismaNameEqualsParam {
	if value == nil {
		return runWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r runQueryNameString) Order(direction SortOrder) runDefaultParam {
	return runDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r runQueryNameString) Cursor(cursor string) runCursorParam {
	return runCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r runQueryNameString) In(value []string) runDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return runDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r runQueryNameString) InIfPresent(value []string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.In(value)
}

func (r runQueryNameString) NotIn(value []string) runDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return runDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r runQueryNameString) NotInIfPresent(value []string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.NotIn(value)
}

func (r runQueryNameString) Lt(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNameString) LtIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Lt(*value)
}

func (r runQueryNameString) Lte(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNameString) LteIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Lte(*value)
}

func (r runQueryNameString) Gt(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNameString) GtIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Gt(*value)
}

func (r runQueryNameString) Gte(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNameString) GteIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Gte(*value)
}

func (r runQueryNameString) Contains(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNameString) ContainsIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Contains(*value)
}

func (r runQueryNameString) StartsWith(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNameString) StartsWithIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r runQueryNameString) EndsWith(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNameString) EndsWithIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r runQueryNameString) Mode(value QueryMode) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNameString) ModeIfPresent(value *QueryMode) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Mode(*value)
}

func (r runQueryNameString) Not(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNameString) NotIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r runQueryNameString) HasPrefix(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r runQueryNameString) HasPrefixIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r runQueryNameString) HasSuffix(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r runQueryNameString) HasSuffixIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type runQueryDescriptionString struct{}

// Set the required value of Description
func (r runQueryDescriptionString) Set(value string) runWithPrismaDescriptionSetParam {

	return runWithPrismaDescriptionSetParam{
		data: builder.Field{
			Name:  "description",
			Value: value,
		},
	}

}

// Set the optional value of Description dynamically
func (r runQueryDescriptionString) SetIfPresent(value *string) runWithPrismaDescriptionSetParam {
	if value == nil {
		return runWithPrismaDescriptionSetParam{}
	}

	return r.Set(*value)
}

func (r runQueryDescriptionString) Equals(value string) runWithPrismaDescriptionEqualsParam {

	return runWithPrismaDescriptionEqualsParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r runQueryDescriptionString) EqualsIfPresent(value *string) runWithPrismaDescriptionEqualsParam {
	if value == nil {
		return runWithPrismaDescriptionEqualsParam{}
	}
	return r.Equals(*value)
}

func (r runQueryDescriptionString) Order(direction SortOrder) runDefaultParam {
	return runDefaultParam{
		data: builder.Field{
			Name:  "description",
			Value: direction,
		},
	}
}

func (r runQueryDescriptionString) Cursor(cursor string) runCursorParam {
	return runCursorParam{
		data: builder.Field{
			Name:  "description",
			Value: cursor,
		},
	}
}

func (r runQueryDescriptionString) In(value []string) runDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return runDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r runQueryDescriptionString) InIfPresent(value []string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.In(value)
}

func (r runQueryDescriptionString) NotIn(value []string) runDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return runDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r runQueryDescriptionString) NotInIfPresent(value []string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.NotIn(value)
}

func (r runQueryDescriptionString) Lt(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryDescriptionString) LtIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Lt(*value)
}

func (r runQueryDescriptionString) Lte(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryDescriptionString) LteIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Lte(*value)
}

func (r runQueryDescriptionString) Gt(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryDescriptionString) GtIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Gt(*value)
}

func (r runQueryDescriptionString) Gte(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryDescriptionString) GteIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Gte(*value)
}

func (r runQueryDescriptionString) Contains(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryDescriptionString) ContainsIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Contains(*value)
}

func (r runQueryDescriptionString) StartsWith(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryDescriptionString) StartsWithIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r runQueryDescriptionString) EndsWith(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryDescriptionString) EndsWithIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r runQueryDescriptionString) Mode(value QueryMode) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryDescriptionString) ModeIfPresent(value *QueryMode) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Mode(*value)
}

func (r runQueryDescriptionString) Not(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryDescriptionString) NotIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r runQueryDescriptionString) HasPrefix(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r runQueryDescriptionString) HasPrefixIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r runQueryDescriptionString) HasSuffix(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r runQueryDescriptionString) HasSuffixIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type runQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r runQueryCreatedAtDateTime) Set(value DateTime) runSetParam {

	return runSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r runQueryCreatedAtDateTime) SetIfPresent(value *DateTime) runSetParam {
	if value == nil {
		return runSetParam{}
	}

	return r.Set(*value)
}

func (r runQueryCreatedAtDateTime) Equals(value DateTime) runWithPrismaCreatedAtEqualsParam {

	return runWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r runQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) runWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return runWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r runQueryCreatedAtDateTime) Order(direction SortOrder) runDefaultParam {
	return runDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r runQueryCreatedAtDateTime) Cursor(cursor DateTime) runCursorParam {
	return runCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r runQueryCreatedAtDateTime) In(value []DateTime) runDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return runDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r runQueryCreatedAtDateTime) InIfPresent(value []DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.In(value)
}

func (r runQueryCreatedAtDateTime) NotIn(value []DateTime) runDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return runDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r runQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.NotIn(value)
}

func (r runQueryCreatedAtDateTime) Lt(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryCreatedAtDateTime) LtIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Lt(*value)
}

func (r runQueryCreatedAtDateTime) Lte(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryCreatedAtDateTime) LteIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Lte(*value)
}

func (r runQueryCreatedAtDateTime) Gt(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryCreatedAtDateTime) GtIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Gt(*value)
}

func (r runQueryCreatedAtDateTime) Gte(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryCreatedAtDateTime) GteIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Gte(*value)
}

func (r runQueryCreatedAtDateTime) Not(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryCreatedAtDateTime) NotIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r runQueryCreatedAtDateTime) Before(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r runQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r runQueryCreatedAtDateTime) After(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r runQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r runQueryCreatedAtDateTime) BeforeEquals(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r runQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r runQueryCreatedAtDateTime) AfterEquals(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r runQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type runQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r runQueryUpdatedAtDateTime) Set(value DateTime) runSetParam {

	return runSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r runQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) runSetParam {
	if value == nil {
		return runSetParam{}
	}

	return r.Set(*value)
}

func (r runQueryUpdatedAtDateTime) Equals(value DateTime) runWithPrismaUpdatedAtEqualsParam {

	return runWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r runQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) runWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return runWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r runQueryUpdatedAtDateTime) Order(direction SortOrder) runDefaultParam {
	return runDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r runQueryUpdatedAtDateTime) Cursor(cursor DateTime) runCursorParam {
	return runCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r runQueryUpdatedAtDateTime) In(value []DateTime) runDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return runDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r runQueryUpdatedAtDateTime) InIfPresent(value []DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.In(value)
}

func (r runQueryUpdatedAtDateTime) NotIn(value []DateTime) runDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return runDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r runQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.NotIn(value)
}

func (r runQueryUpdatedAtDateTime) Lt(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Lt(*value)
}

func (r runQueryUpdatedAtDateTime) Lte(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Lte(*value)
}

func (r runQueryUpdatedAtDateTime) Gt(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Gt(*value)
}

func (r runQueryUpdatedAtDateTime) Gte(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Gte(*value)
}

func (r runQueryUpdatedAtDateTime) Not(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r runQueryUpdatedAtDateTime) Before(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r runQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r runQueryUpdatedAtDateTime) After(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r runQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r runQueryUpdatedAtDateTime) BeforeEquals(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r runQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r runQueryUpdatedAtDateTime) AfterEquals(value DateTime) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r runQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type runQueryNetNet struct{}

type runQueryNetRelations struct{}

// Run -> Net
//
// @relation
// @required
func (runQueryNetRelations) Where(
	params ...NetWhereParam,
) runDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return runDefaultParam{
		data: builder.Field{
			Name: "net",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (runQueryNetRelations) Fetch() runToNetFindUnique {
	var v runToNetFindUnique

	v.query.Operation = "query"
	v.query.Method = "net"
	v.query.Outputs = netOutput

	return v
}

func (r runQueryNetRelations) Link(
	params NetWhereParam,
) runWithPrismaNetSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return runWithPrismaNetSetParam{}
	}

	fields = append(fields, f)

	return runWithPrismaNetSetParam{
		data: builder.Field{
			Name: "net",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r runQueryNetRelations) Unlink() runWithPrismaNetSetParam {
	var v runWithPrismaNetSetParam

	v = runWithPrismaNetSetParam{
		data: builder.Field{
			Name: "net",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type runQueryNetIDString struct{}

// Set the required value of NetID
func (r runQueryNetIDString) Set(value string) runSetParam {

	return runSetParam{
		data: builder.Field{
			Name:  "netID",
			Value: value,
		},
	}

}

// Set the optional value of NetID dynamically
func (r runQueryNetIDString) SetIfPresent(value *string) runSetParam {
	if value == nil {
		return runSetParam{}
	}

	return r.Set(*value)
}

func (r runQueryNetIDString) Equals(value string) runWithPrismaNetIDEqualsParam {

	return runWithPrismaNetIDEqualsParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r runQueryNetIDString) EqualsIfPresent(value *string) runWithPrismaNetIDEqualsParam {
	if value == nil {
		return runWithPrismaNetIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r runQueryNetIDString) Order(direction SortOrder) runDefaultParam {
	return runDefaultParam{
		data: builder.Field{
			Name:  "netID",
			Value: direction,
		},
	}
}

func (r runQueryNetIDString) Cursor(cursor string) runCursorParam {
	return runCursorParam{
		data: builder.Field{
			Name:  "netID",
			Value: cursor,
		},
	}
}

func (r runQueryNetIDString) In(value []string) runDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return runDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r runQueryNetIDString) InIfPresent(value []string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.In(value)
}

func (r runQueryNetIDString) NotIn(value []string) runDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return runDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r runQueryNetIDString) NotInIfPresent(value []string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.NotIn(value)
}

func (r runQueryNetIDString) Lt(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNetIDString) LtIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Lt(*value)
}

func (r runQueryNetIDString) Lte(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNetIDString) LteIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Lte(*value)
}

func (r runQueryNetIDString) Gt(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNetIDString) GtIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Gt(*value)
}

func (r runQueryNetIDString) Gte(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNetIDString) GteIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Gte(*value)
}

func (r runQueryNetIDString) Contains(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNetIDString) ContainsIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Contains(*value)
}

func (r runQueryNetIDString) StartsWith(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNetIDString) StartsWithIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r runQueryNetIDString) EndsWith(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNetIDString) EndsWithIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r runQueryNetIDString) Mode(value QueryMode) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNetIDString) ModeIfPresent(value *QueryMode) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Mode(*value)
}

func (r runQueryNetIDString) Not(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r runQueryNetIDString) NotIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r runQueryNetIDString) HasPrefix(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r runQueryNetIDString) HasPrefixIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r runQueryNetIDString) HasSuffix(value string) runDefaultParam {

	return runDefaultParam{
		data: builder.Field{
			Name: "netID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r runQueryNetIDString) HasSuffixIfPresent(value *string) runDefaultParam {
	if value == nil {
		return runDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type runQuerySessionsSession struct{}

type runQuerySessionsRelations struct{}

// Run -> Sessions
//
// @relation
// @required
func (runQuerySessionsRelations) Some(
	params ...SessionWhereParam,
) runDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return runDefaultParam{
		data: builder.Field{
			Name: "sessions",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Run -> Sessions
//
// @relation
// @required
func (runQuerySessionsRelations) Every(
	params ...SessionWhereParam,
) runDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return runDefaultParam{
		data: builder.Field{
			Name: "sessions",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (runQuerySessionsRelations) Fetch(

	params ...SessionWhereParam,

) runToSessionsFindMany {
	var v runToSessionsFindMany

	v.query.Operation = "query"
	v.query.Method = "sessions"
	v.query.Outputs = sessionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r runQuerySessionsRelations) Link(
	params ...SessionWhereParam,
) runSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return runSetParam{
		data: builder.Field{
			Name: "sessions",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r runQuerySessionsRelations) Unlink(
	params ...SessionWhereParam,
) runSetParam {
	var v runSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = runSetParam{
		data: builder.Field{
			Name: "sessions",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type runQueryStepsStep struct{}

type runQueryStepsRelations struct{}

// Run -> Steps
//
// @relation
// @required
func (runQueryStepsRelations) Some(
	params ...StepWhereParam,
) runDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return runDefaultParam{
		data: builder.Field{
			Name: "steps",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Run -> Steps
//
// @relation
// @required
func (runQueryStepsRelations) Every(
	params ...StepWhereParam,
) runDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return runDefaultParam{
		data: builder.Field{
			Name: "steps",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (runQueryStepsRelations) Fetch(

	params ...StepWhereParam,

) runToStepsFindMany {
	var v runToStepsFindMany

	v.query.Operation = "query"
	v.query.Method = "steps"
	v.query.Outputs = stepOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r runQueryStepsRelations) Link(
	params ...StepWhereParam,
) runSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return runSetParam{
		data: builder.Field{
			Name: "steps",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r runQueryStepsRelations) Unlink(
	params ...StepWhereParam,
) runSetParam {
	var v runSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = runSetParam{
		data: builder.Field{
			Name: "steps",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// Datum acts as a namespaces to access query methods for the Datum model
var Datum = datumQuery{}

// datumQuery exposes query functions for the datum model
type datumQuery struct {

	// ID
	//
	// @required
	ID datumQueryIDString

	Instance datumQueryInstanceRelations

	// InstanceID
	//
	// @required
	InstanceID datumQueryInstanceIDString

	Session datumQuerySessionRelations

	// SessionID
	//
	// @required
	SessionID datumQuerySessionIDString

	// Value
	//
	// @optional
	Value datumQueryValueJson

	// CreatedAt
	//
	// @required
	CreatedAt datumQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt datumQueryUpdatedAtDateTime

	Event datumQueryEventRelations

	// EventID
	//
	// @required
	EventID datumQueryEventIDString
}

func (datumQuery) Not(params ...DatumWhereParam) datumDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return datumDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (datumQuery) Or(params ...DatumWhereParam) datumDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return datumDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (datumQuery) And(params ...DatumWhereParam) datumDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return datumDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type datumQueryIDString struct{}

// Set the required value of ID
func (r datumQueryIDString) Set(value string) datumSetParam {

	return datumSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r datumQueryIDString) SetIfPresent(value *string) datumSetParam {
	if value == nil {
		return datumSetParam{}
	}

	return r.Set(*value)
}

func (r datumQueryIDString) Equals(value string) datumWithPrismaIDEqualsUniqueParam {

	return datumWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r datumQueryIDString) EqualsIfPresent(value *string) datumWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return datumWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r datumQueryIDString) Order(direction SortOrder) datumDefaultParam {
	return datumDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r datumQueryIDString) Cursor(cursor string) datumCursorParam {
	return datumCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r datumQueryIDString) In(value []string) datumParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return datumParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r datumQueryIDString) InIfPresent(value []string) datumParamUnique {
	if value == nil {
		return datumParamUnique{}
	}
	return r.In(value)
}

func (r datumQueryIDString) NotIn(value []string) datumParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return datumParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r datumQueryIDString) NotInIfPresent(value []string) datumParamUnique {
	if value == nil {
		return datumParamUnique{}
	}
	return r.NotIn(value)
}

func (r datumQueryIDString) Lt(value string) datumParamUnique {

	return datumParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryIDString) LtIfPresent(value *string) datumParamUnique {
	if value == nil {
		return datumParamUnique{}
	}
	return r.Lt(*value)
}

func (r datumQueryIDString) Lte(value string) datumParamUnique {

	return datumParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryIDString) LteIfPresent(value *string) datumParamUnique {
	if value == nil {
		return datumParamUnique{}
	}
	return r.Lte(*value)
}

func (r datumQueryIDString) Gt(value string) datumParamUnique {

	return datumParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryIDString) GtIfPresent(value *string) datumParamUnique {
	if value == nil {
		return datumParamUnique{}
	}
	return r.Gt(*value)
}

func (r datumQueryIDString) Gte(value string) datumParamUnique {

	return datumParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryIDString) GteIfPresent(value *string) datumParamUnique {
	if value == nil {
		return datumParamUnique{}
	}
	return r.Gte(*value)
}

func (r datumQueryIDString) Contains(value string) datumParamUnique {

	return datumParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryIDString) ContainsIfPresent(value *string) datumParamUnique {
	if value == nil {
		return datumParamUnique{}
	}
	return r.Contains(*value)
}

func (r datumQueryIDString) StartsWith(value string) datumParamUnique {

	return datumParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryIDString) StartsWithIfPresent(value *string) datumParamUnique {
	if value == nil {
		return datumParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r datumQueryIDString) EndsWith(value string) datumParamUnique {

	return datumParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryIDString) EndsWithIfPresent(value *string) datumParamUnique {
	if value == nil {
		return datumParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r datumQueryIDString) Mode(value QueryMode) datumParamUnique {

	return datumParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryIDString) ModeIfPresent(value *QueryMode) datumParamUnique {
	if value == nil {
		return datumParamUnique{}
	}
	return r.Mode(*value)
}

func (r datumQueryIDString) Not(value string) datumParamUnique {

	return datumParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryIDString) NotIfPresent(value *string) datumParamUnique {
	if value == nil {
		return datumParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r datumQueryIDString) HasPrefix(value string) datumParamUnique {

	return datumParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r datumQueryIDString) HasPrefixIfPresent(value *string) datumParamUnique {
	if value == nil {
		return datumParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r datumQueryIDString) HasSuffix(value string) datumParamUnique {

	return datumParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r datumQueryIDString) HasSuffixIfPresent(value *string) datumParamUnique {
	if value == nil {
		return datumParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type datumQueryInstanceInstance struct{}

type datumQueryInstanceRelations struct{}

// Datum -> Instance
//
// @relation
// @required
func (datumQueryInstanceRelations) Where(
	params ...InstanceWhereParam,
) datumDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return datumDefaultParam{
		data: builder.Field{
			Name: "instance",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (datumQueryInstanceRelations) Fetch() datumToInstanceFindUnique {
	var v datumToInstanceFindUnique

	v.query.Operation = "query"
	v.query.Method = "instance"
	v.query.Outputs = instanceOutput

	return v
}

func (r datumQueryInstanceRelations) Link(
	params InstanceWhereParam,
) datumWithPrismaInstanceSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return datumWithPrismaInstanceSetParam{}
	}

	fields = append(fields, f)

	return datumWithPrismaInstanceSetParam{
		data: builder.Field{
			Name: "instance",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r datumQueryInstanceRelations) Unlink() datumWithPrismaInstanceSetParam {
	var v datumWithPrismaInstanceSetParam

	v = datumWithPrismaInstanceSetParam{
		data: builder.Field{
			Name: "instance",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type datumQueryInstanceIDString struct{}

// Set the required value of InstanceID
func (r datumQueryInstanceIDString) Set(value string) datumSetParam {

	return datumSetParam{
		data: builder.Field{
			Name:  "instanceID",
			Value: value,
		},
	}

}

// Set the optional value of InstanceID dynamically
func (r datumQueryInstanceIDString) SetIfPresent(value *string) datumSetParam {
	if value == nil {
		return datumSetParam{}
	}

	return r.Set(*value)
}

func (r datumQueryInstanceIDString) Equals(value string) datumWithPrismaInstanceIDEqualsParam {

	return datumWithPrismaInstanceIDEqualsParam{
		data: builder.Field{
			Name: "instanceID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r datumQueryInstanceIDString) EqualsIfPresent(value *string) datumWithPrismaInstanceIDEqualsParam {
	if value == nil {
		return datumWithPrismaInstanceIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r datumQueryInstanceIDString) Order(direction SortOrder) datumDefaultParam {
	return datumDefaultParam{
		data: builder.Field{
			Name:  "instanceID",
			Value: direction,
		},
	}
}

func (r datumQueryInstanceIDString) Cursor(cursor string) datumCursorParam {
	return datumCursorParam{
		data: builder.Field{
			Name:  "instanceID",
			Value: cursor,
		},
	}
}

func (r datumQueryInstanceIDString) In(value []string) datumDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return datumDefaultParam{
		data: builder.Field{
			Name: "instanceID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r datumQueryInstanceIDString) InIfPresent(value []string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.In(value)
}

func (r datumQueryInstanceIDString) NotIn(value []string) datumDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return datumDefaultParam{
		data: builder.Field{
			Name: "instanceID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r datumQueryInstanceIDString) NotInIfPresent(value []string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.NotIn(value)
}

func (r datumQueryInstanceIDString) Lt(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "instanceID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryInstanceIDString) LtIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Lt(*value)
}

func (r datumQueryInstanceIDString) Lte(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "instanceID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryInstanceIDString) LteIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Lte(*value)
}

func (r datumQueryInstanceIDString) Gt(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "instanceID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryInstanceIDString) GtIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Gt(*value)
}

func (r datumQueryInstanceIDString) Gte(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "instanceID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryInstanceIDString) GteIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Gte(*value)
}

func (r datumQueryInstanceIDString) Contains(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "instanceID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryInstanceIDString) ContainsIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Contains(*value)
}

func (r datumQueryInstanceIDString) StartsWith(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "instanceID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryInstanceIDString) StartsWithIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r datumQueryInstanceIDString) EndsWith(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "instanceID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryInstanceIDString) EndsWithIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r datumQueryInstanceIDString) Mode(value QueryMode) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "instanceID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryInstanceIDString) ModeIfPresent(value *QueryMode) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Mode(*value)
}

func (r datumQueryInstanceIDString) Not(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "instanceID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryInstanceIDString) NotIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r datumQueryInstanceIDString) HasPrefix(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "instanceID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r datumQueryInstanceIDString) HasPrefixIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r datumQueryInstanceIDString) HasSuffix(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "instanceID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r datumQueryInstanceIDString) HasSuffixIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type datumQuerySessionSession struct{}

type datumQuerySessionRelations struct{}

// Datum -> Session
//
// @relation
// @required
func (datumQuerySessionRelations) Where(
	params ...SessionWhereParam,
) datumDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return datumDefaultParam{
		data: builder.Field{
			Name: "session",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (datumQuerySessionRelations) Fetch() datumToSessionFindUnique {
	var v datumToSessionFindUnique

	v.query.Operation = "query"
	v.query.Method = "session"
	v.query.Outputs = sessionOutput

	return v
}

func (r datumQuerySessionRelations) Link(
	params SessionWhereParam,
) datumWithPrismaSessionSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return datumWithPrismaSessionSetParam{}
	}

	fields = append(fields, f)

	return datumWithPrismaSessionSetParam{
		data: builder.Field{
			Name: "session",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r datumQuerySessionRelations) Unlink() datumWithPrismaSessionSetParam {
	var v datumWithPrismaSessionSetParam

	v = datumWithPrismaSessionSetParam{
		data: builder.Field{
			Name: "session",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type datumQuerySessionIDString struct{}

// Set the required value of SessionID
func (r datumQuerySessionIDString) Set(value string) datumSetParam {

	return datumSetParam{
		data: builder.Field{
			Name:  "sessionID",
			Value: value,
		},
	}

}

// Set the optional value of SessionID dynamically
func (r datumQuerySessionIDString) SetIfPresent(value *string) datumSetParam {
	if value == nil {
		return datumSetParam{}
	}

	return r.Set(*value)
}

func (r datumQuerySessionIDString) Equals(value string) datumWithPrismaSessionIDEqualsParam {

	return datumWithPrismaSessionIDEqualsParam{
		data: builder.Field{
			Name: "sessionID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r datumQuerySessionIDString) EqualsIfPresent(value *string) datumWithPrismaSessionIDEqualsParam {
	if value == nil {
		return datumWithPrismaSessionIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r datumQuerySessionIDString) Order(direction SortOrder) datumDefaultParam {
	return datumDefaultParam{
		data: builder.Field{
			Name:  "sessionID",
			Value: direction,
		},
	}
}

func (r datumQuerySessionIDString) Cursor(cursor string) datumCursorParam {
	return datumCursorParam{
		data: builder.Field{
			Name:  "sessionID",
			Value: cursor,
		},
	}
}

func (r datumQuerySessionIDString) In(value []string) datumDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return datumDefaultParam{
		data: builder.Field{
			Name: "sessionID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r datumQuerySessionIDString) InIfPresent(value []string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.In(value)
}

func (r datumQuerySessionIDString) NotIn(value []string) datumDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return datumDefaultParam{
		data: builder.Field{
			Name: "sessionID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r datumQuerySessionIDString) NotInIfPresent(value []string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.NotIn(value)
}

func (r datumQuerySessionIDString) Lt(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "sessionID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r datumQuerySessionIDString) LtIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Lt(*value)
}

func (r datumQuerySessionIDString) Lte(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "sessionID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r datumQuerySessionIDString) LteIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Lte(*value)
}

func (r datumQuerySessionIDString) Gt(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "sessionID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r datumQuerySessionIDString) GtIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Gt(*value)
}

func (r datumQuerySessionIDString) Gte(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "sessionID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r datumQuerySessionIDString) GteIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Gte(*value)
}

func (r datumQuerySessionIDString) Contains(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "sessionID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r datumQuerySessionIDString) ContainsIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Contains(*value)
}

func (r datumQuerySessionIDString) StartsWith(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "sessionID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r datumQuerySessionIDString) StartsWithIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r datumQuerySessionIDString) EndsWith(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "sessionID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r datumQuerySessionIDString) EndsWithIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r datumQuerySessionIDString) Mode(value QueryMode) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "sessionID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r datumQuerySessionIDString) ModeIfPresent(value *QueryMode) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Mode(*value)
}

func (r datumQuerySessionIDString) Not(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "sessionID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r datumQuerySessionIDString) NotIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r datumQuerySessionIDString) HasPrefix(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "sessionID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r datumQuerySessionIDString) HasPrefixIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r datumQuerySessionIDString) HasSuffix(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "sessionID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r datumQuerySessionIDString) HasSuffixIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type datumQueryValueJson struct{}

// Set the optional value of Value
func (r datumQueryValueJson) Set(value JSON) datumSetParam {

	return datumSetParam{
		data: builder.Field{
			Name:  "value",
			Value: value,
		},
	}

}

// Set the optional value of Value dynamically
func (r datumQueryValueJson) SetIfPresent(value *JSON) datumSetParam {
	if value == nil {
		return datumSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Value dynamically
func (r datumQueryValueJson) SetOptional(value *JSON) datumSetParam {
	if value == nil {

		var v *JSON
		return datumSetParam{
			data: builder.Field{
				Name:  "value",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r datumQueryValueJson) Equals(value JSON) datumWithPrismaValueEqualsParam {

	return datumWithPrismaValueEqualsParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r datumQueryValueJson) EqualsIfPresent(value *JSON) datumWithPrismaValueEqualsParam {
	if value == nil {
		return datumWithPrismaValueEqualsParam{}
	}
	return r.Equals(*value)
}

func (r datumQueryValueJson) EqualsOptional(value *JSON) datumDefaultParam {
	return datumDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r datumQueryValueJson) IsNull() datumDefaultParam {
	var str *string = nil
	return datumDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r datumQueryValueJson) Order(direction SortOrder) datumDefaultParam {
	return datumDefaultParam{
		data: builder.Field{
			Name:  "value",
			Value: direction,
		},
	}
}

func (r datumQueryValueJson) Cursor(cursor JSON) datumCursorParam {
	return datumCursorParam{
		data: builder.Field{
			Name:  "value",
			Value: cursor,
		},
	}
}

func (r datumQueryValueJson) Path(value []string) datumDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return datumDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "path",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r datumQueryValueJson) PathIfPresent(value []string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Path(value)
}

func (r datumQueryValueJson) StringContains(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "string_contains",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryValueJson) StringContainsIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.StringContains(*value)
}

func (r datumQueryValueJson) StringStartsWith(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "string_starts_with",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryValueJson) StringStartsWithIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.StringStartsWith(*value)
}

func (r datumQueryValueJson) StringEndsWith(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "string_ends_with",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryValueJson) StringEndsWithIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.StringEndsWith(*value)
}

func (r datumQueryValueJson) ArrayContains(value JSON) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "array_contains",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryValueJson) ArrayContainsIfPresent(value *JSON) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.ArrayContains(*value)
}

func (r datumQueryValueJson) ArrayStartsWith(value JSON) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "array_starts_with",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryValueJson) ArrayStartsWithIfPresent(value *JSON) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.ArrayStartsWith(*value)
}

func (r datumQueryValueJson) ArrayEndsWith(value JSON) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "array_ends_with",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryValueJson) ArrayEndsWithIfPresent(value *JSON) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.ArrayEndsWith(*value)
}

func (r datumQueryValueJson) Lt(value JSON) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryValueJson) LtIfPresent(value *JSON) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Lt(*value)
}

func (r datumQueryValueJson) Lte(value JSON) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryValueJson) LteIfPresent(value *JSON) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Lte(*value)
}

func (r datumQueryValueJson) Gt(value JSON) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryValueJson) GtIfPresent(value *JSON) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Gt(*value)
}

func (r datumQueryValueJson) Gte(value JSON) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryValueJson) GteIfPresent(value *JSON) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Gte(*value)
}

func (r datumQueryValueJson) Not(value JSONNullValueFilter) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryValueJson) NotIfPresent(value *JSONNullValueFilter) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Not(*value)
}

// base struct
type datumQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r datumQueryCreatedAtDateTime) Set(value DateTime) datumSetParam {

	return datumSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r datumQueryCreatedAtDateTime) SetIfPresent(value *DateTime) datumSetParam {
	if value == nil {
		return datumSetParam{}
	}

	return r.Set(*value)
}

func (r datumQueryCreatedAtDateTime) Equals(value DateTime) datumWithPrismaCreatedAtEqualsParam {

	return datumWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r datumQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) datumWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return datumWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r datumQueryCreatedAtDateTime) Order(direction SortOrder) datumDefaultParam {
	return datumDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r datumQueryCreatedAtDateTime) Cursor(cursor DateTime) datumCursorParam {
	return datumCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r datumQueryCreatedAtDateTime) In(value []DateTime) datumDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return datumDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r datumQueryCreatedAtDateTime) InIfPresent(value []DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.In(value)
}

func (r datumQueryCreatedAtDateTime) NotIn(value []DateTime) datumDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return datumDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r datumQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.NotIn(value)
}

func (r datumQueryCreatedAtDateTime) Lt(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryCreatedAtDateTime) LtIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Lt(*value)
}

func (r datumQueryCreatedAtDateTime) Lte(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryCreatedAtDateTime) LteIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Lte(*value)
}

func (r datumQueryCreatedAtDateTime) Gt(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryCreatedAtDateTime) GtIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Gt(*value)
}

func (r datumQueryCreatedAtDateTime) Gte(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryCreatedAtDateTime) GteIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Gte(*value)
}

func (r datumQueryCreatedAtDateTime) Not(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryCreatedAtDateTime) NotIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r datumQueryCreatedAtDateTime) Before(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r datumQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r datumQueryCreatedAtDateTime) After(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r datumQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r datumQueryCreatedAtDateTime) BeforeEquals(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r datumQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r datumQueryCreatedAtDateTime) AfterEquals(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r datumQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type datumQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r datumQueryUpdatedAtDateTime) Set(value DateTime) datumSetParam {

	return datumSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r datumQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) datumSetParam {
	if value == nil {
		return datumSetParam{}
	}

	return r.Set(*value)
}

func (r datumQueryUpdatedAtDateTime) Equals(value DateTime) datumWithPrismaUpdatedAtEqualsParam {

	return datumWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r datumQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) datumWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return datumWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r datumQueryUpdatedAtDateTime) Order(direction SortOrder) datumDefaultParam {
	return datumDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r datumQueryUpdatedAtDateTime) Cursor(cursor DateTime) datumCursorParam {
	return datumCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r datumQueryUpdatedAtDateTime) In(value []DateTime) datumDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return datumDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r datumQueryUpdatedAtDateTime) InIfPresent(value []DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.In(value)
}

func (r datumQueryUpdatedAtDateTime) NotIn(value []DateTime) datumDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return datumDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r datumQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.NotIn(value)
}

func (r datumQueryUpdatedAtDateTime) Lt(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Lt(*value)
}

func (r datumQueryUpdatedAtDateTime) Lte(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Lte(*value)
}

func (r datumQueryUpdatedAtDateTime) Gt(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Gt(*value)
}

func (r datumQueryUpdatedAtDateTime) Gte(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Gte(*value)
}

func (r datumQueryUpdatedAtDateTime) Not(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r datumQueryUpdatedAtDateTime) Before(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r datumQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r datumQueryUpdatedAtDateTime) After(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r datumQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r datumQueryUpdatedAtDateTime) BeforeEquals(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r datumQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r datumQueryUpdatedAtDateTime) AfterEquals(value DateTime) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r datumQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type datumQueryEventEvent struct{}

type datumQueryEventRelations struct{}

// Datum -> Event
//
// @relation
// @required
func (datumQueryEventRelations) Where(
	params ...EventWhereParam,
) datumDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return datumDefaultParam{
		data: builder.Field{
			Name: "event",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (datumQueryEventRelations) Fetch() datumToEventFindUnique {
	var v datumToEventFindUnique

	v.query.Operation = "query"
	v.query.Method = "event"
	v.query.Outputs = eventOutput

	return v
}

func (r datumQueryEventRelations) Link(
	params EventWhereParam,
) datumWithPrismaEventSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return datumWithPrismaEventSetParam{}
	}

	fields = append(fields, f)

	return datumWithPrismaEventSetParam{
		data: builder.Field{
			Name: "event",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r datumQueryEventRelations) Unlink() datumWithPrismaEventSetParam {
	var v datumWithPrismaEventSetParam

	v = datumWithPrismaEventSetParam{
		data: builder.Field{
			Name: "event",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type datumQueryEventIDString struct{}

// Set the required value of EventID
func (r datumQueryEventIDString) Set(value string) datumSetParam {

	return datumSetParam{
		data: builder.Field{
			Name:  "eventId",
			Value: value,
		},
	}

}

// Set the optional value of EventID dynamically
func (r datumQueryEventIDString) SetIfPresent(value *string) datumSetParam {
	if value == nil {
		return datumSetParam{}
	}

	return r.Set(*value)
}

func (r datumQueryEventIDString) Equals(value string) datumWithPrismaEventIDEqualsParam {

	return datumWithPrismaEventIDEqualsParam{
		data: builder.Field{
			Name: "eventId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r datumQueryEventIDString) EqualsIfPresent(value *string) datumWithPrismaEventIDEqualsParam {
	if value == nil {
		return datumWithPrismaEventIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r datumQueryEventIDString) Order(direction SortOrder) datumDefaultParam {
	return datumDefaultParam{
		data: builder.Field{
			Name:  "eventId",
			Value: direction,
		},
	}
}

func (r datumQueryEventIDString) Cursor(cursor string) datumCursorParam {
	return datumCursorParam{
		data: builder.Field{
			Name:  "eventId",
			Value: cursor,
		},
	}
}

func (r datumQueryEventIDString) In(value []string) datumDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return datumDefaultParam{
		data: builder.Field{
			Name: "eventId",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r datumQueryEventIDString) InIfPresent(value []string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.In(value)
}

func (r datumQueryEventIDString) NotIn(value []string) datumDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return datumDefaultParam{
		data: builder.Field{
			Name: "eventId",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r datumQueryEventIDString) NotInIfPresent(value []string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.NotIn(value)
}

func (r datumQueryEventIDString) Lt(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "eventId",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryEventIDString) LtIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Lt(*value)
}

func (r datumQueryEventIDString) Lte(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "eventId",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryEventIDString) LteIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Lte(*value)
}

func (r datumQueryEventIDString) Gt(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "eventId",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryEventIDString) GtIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Gt(*value)
}

func (r datumQueryEventIDString) Gte(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "eventId",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryEventIDString) GteIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Gte(*value)
}

func (r datumQueryEventIDString) Contains(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "eventId",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryEventIDString) ContainsIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Contains(*value)
}

func (r datumQueryEventIDString) StartsWith(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "eventId",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryEventIDString) StartsWithIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r datumQueryEventIDString) EndsWith(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "eventId",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryEventIDString) EndsWithIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r datumQueryEventIDString) Mode(value QueryMode) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "eventId",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryEventIDString) ModeIfPresent(value *QueryMode) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Mode(*value)
}

func (r datumQueryEventIDString) Not(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "eventId",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r datumQueryEventIDString) NotIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r datumQueryEventIDString) HasPrefix(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "eventId",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r datumQueryEventIDString) HasPrefixIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r datumQueryEventIDString) HasSuffix(value string) datumDefaultParam {

	return datumDefaultParam{
		data: builder.Field{
			Name: "eventId",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r datumQueryEventIDString) HasSuffixIfPresent(value *string) datumDefaultParam {
	if value == nil {
		return datumDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// Session acts as a namespaces to access query methods for the Session model
var Session = sessionQuery{}

// sessionQuery exposes query functions for the session model
type sessionQuery struct {

	// ID
	//
	// @required
	ID sessionQueryIDString

	User sessionQueryUserRelations

	// UserID
	//
	// @required
	UserID sessionQueryUserIDString

	// CreatedAt
	//
	// @required
	CreatedAt sessionQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt sessionQueryUpdatedAtDateTime

	// StartedAt
	//
	// @optional
	StartedAt sessionQueryStartedAtDateTime

	// StoppedAt
	//
	// @optional
	StoppedAt sessionQueryStoppedAtDateTime

	// PausedAt
	//
	// @required
	PausedAt sessionQueryPausedAtDateTime

	// ResumedAt
	//
	// @required
	ResumedAt sessionQueryResumedAtDateTime

	Run sessionQueryRunRelations

	Instances sessionQueryInstancesRelations

	// State
	//
	// @required
	State sessionQueryStateSessionState

	// Deleted
	//
	// @required
	Deleted sessionQueryDeletedBoolean

	// RunID
	//
	// @required
	RunID sessionQueryRunIDString

	Data sessionQueryDataRelations
}

func (sessionQuery) Not(params ...SessionWhereParam) sessionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (sessionQuery) Or(params ...SessionWhereParam) sessionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (sessionQuery) And(params ...SessionWhereParam) sessionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type sessionQueryIDString struct{}

// Set the required value of ID
func (r sessionQueryIDString) Set(value string) sessionSetParam {

	return sessionSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r sessionQueryIDString) SetIfPresent(value *string) sessionSetParam {
	if value == nil {
		return sessionSetParam{}
	}

	return r.Set(*value)
}

func (r sessionQueryIDString) Equals(value string) sessionWithPrismaIDEqualsUniqueParam {

	return sessionWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryIDString) EqualsIfPresent(value *string) sessionWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return sessionWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r sessionQueryIDString) Order(direction SortOrder) sessionDefaultParam {
	return sessionDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r sessionQueryIDString) Cursor(cursor string) sessionCursorParam {
	return sessionCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r sessionQueryIDString) In(value []string) sessionParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryIDString) InIfPresent(value []string) sessionParamUnique {
	if value == nil {
		return sessionParamUnique{}
	}
	return r.In(value)
}

func (r sessionQueryIDString) NotIn(value []string) sessionParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryIDString) NotInIfPresent(value []string) sessionParamUnique {
	if value == nil {
		return sessionParamUnique{}
	}
	return r.NotIn(value)
}

func (r sessionQueryIDString) Lt(value string) sessionParamUnique {

	return sessionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryIDString) LtIfPresent(value *string) sessionParamUnique {
	if value == nil {
		return sessionParamUnique{}
	}
	return r.Lt(*value)
}

func (r sessionQueryIDString) Lte(value string) sessionParamUnique {

	return sessionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryIDString) LteIfPresent(value *string) sessionParamUnique {
	if value == nil {
		return sessionParamUnique{}
	}
	return r.Lte(*value)
}

func (r sessionQueryIDString) Gt(value string) sessionParamUnique {

	return sessionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryIDString) GtIfPresent(value *string) sessionParamUnique {
	if value == nil {
		return sessionParamUnique{}
	}
	return r.Gt(*value)
}

func (r sessionQueryIDString) Gte(value string) sessionParamUnique {

	return sessionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryIDString) GteIfPresent(value *string) sessionParamUnique {
	if value == nil {
		return sessionParamUnique{}
	}
	return r.Gte(*value)
}

func (r sessionQueryIDString) Contains(value string) sessionParamUnique {

	return sessionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryIDString) ContainsIfPresent(value *string) sessionParamUnique {
	if value == nil {
		return sessionParamUnique{}
	}
	return r.Contains(*value)
}

func (r sessionQueryIDString) StartsWith(value string) sessionParamUnique {

	return sessionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryIDString) StartsWithIfPresent(value *string) sessionParamUnique {
	if value == nil {
		return sessionParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r sessionQueryIDString) EndsWith(value string) sessionParamUnique {

	return sessionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryIDString) EndsWithIfPresent(value *string) sessionParamUnique {
	if value == nil {
		return sessionParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r sessionQueryIDString) Mode(value QueryMode) sessionParamUnique {

	return sessionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryIDString) ModeIfPresent(value *QueryMode) sessionParamUnique {
	if value == nil {
		return sessionParamUnique{}
	}
	return r.Mode(*value)
}

func (r sessionQueryIDString) Not(value string) sessionParamUnique {

	return sessionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryIDString) NotIfPresent(value *string) sessionParamUnique {
	if value == nil {
		return sessionParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r sessionQueryIDString) HasPrefix(value string) sessionParamUnique {

	return sessionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r sessionQueryIDString) HasPrefixIfPresent(value *string) sessionParamUnique {
	if value == nil {
		return sessionParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r sessionQueryIDString) HasSuffix(value string) sessionParamUnique {

	return sessionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r sessionQueryIDString) HasSuffixIfPresent(value *string) sessionParamUnique {
	if value == nil {
		return sessionParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type sessionQueryUserUser struct{}

type sessionQueryUserRelations struct{}

// Session -> User
//
// @relation
// @required
func (sessionQueryUserRelations) Where(
	params ...UserWhereParam,
) sessionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (sessionQueryUserRelations) Fetch() sessionToUserFindUnique {
	var v sessionToUserFindUnique

	v.query.Operation = "query"
	v.query.Method = "user"
	v.query.Outputs = userOutput

	return v
}

func (r sessionQueryUserRelations) Link(
	params UserWhereParam,
) sessionWithPrismaUserSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return sessionWithPrismaUserSetParam{}
	}

	fields = append(fields, f)

	return sessionWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r sessionQueryUserRelations) Unlink() sessionWithPrismaUserSetParam {
	var v sessionWithPrismaUserSetParam

	v = sessionWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type sessionQueryUserIDString struct{}

// Set the required value of UserID
func (r sessionQueryUserIDString) Set(value string) sessionSetParam {

	return sessionSetParam{
		data: builder.Field{
			Name:  "userID",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r sessionQueryUserIDString) SetIfPresent(value *string) sessionSetParam {
	if value == nil {
		return sessionSetParam{}
	}

	return r.Set(*value)
}

func (r sessionQueryUserIDString) Equals(value string) sessionWithPrismaUserIDEqualsParam {

	return sessionWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryUserIDString) EqualsIfPresent(value *string) sessionWithPrismaUserIDEqualsParam {
	if value == nil {
		return sessionWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r sessionQueryUserIDString) Order(direction SortOrder) sessionDefaultParam {
	return sessionDefaultParam{
		data: builder.Field{
			Name:  "userID",
			Value: direction,
		},
	}
}

func (r sessionQueryUserIDString) Cursor(cursor string) sessionCursorParam {
	return sessionCursorParam{
		data: builder.Field{
			Name:  "userID",
			Value: cursor,
		},
	}
}

func (r sessionQueryUserIDString) In(value []string) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryUserIDString) InIfPresent(value []string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.In(value)
}

func (r sessionQueryUserIDString) NotIn(value []string) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryUserIDString) NotInIfPresent(value []string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r sessionQueryUserIDString) Lt(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryUserIDString) LtIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r sessionQueryUserIDString) Lte(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryUserIDString) LteIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r sessionQueryUserIDString) Gt(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryUserIDString) GtIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r sessionQueryUserIDString) Gte(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryUserIDString) GteIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r sessionQueryUserIDString) Contains(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryUserIDString) ContainsIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Contains(*value)
}

func (r sessionQueryUserIDString) StartsWith(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryUserIDString) StartsWithIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r sessionQueryUserIDString) EndsWith(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryUserIDString) EndsWithIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r sessionQueryUserIDString) Mode(value QueryMode) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryUserIDString) ModeIfPresent(value *QueryMode) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Mode(*value)
}

func (r sessionQueryUserIDString) Not(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryUserIDString) NotIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r sessionQueryUserIDString) HasPrefix(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r sessionQueryUserIDString) HasPrefixIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r sessionQueryUserIDString) HasSuffix(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "userID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r sessionQueryUserIDString) HasSuffixIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type sessionQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r sessionQueryCreatedAtDateTime) Set(value DateTime) sessionSetParam {

	return sessionSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r sessionQueryCreatedAtDateTime) SetIfPresent(value *DateTime) sessionSetParam {
	if value == nil {
		return sessionSetParam{}
	}

	return r.Set(*value)
}

func (r sessionQueryCreatedAtDateTime) Equals(value DateTime) sessionWithPrismaCreatedAtEqualsParam {

	return sessionWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) sessionWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return sessionWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r sessionQueryCreatedAtDateTime) Order(direction SortOrder) sessionDefaultParam {
	return sessionDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r sessionQueryCreatedAtDateTime) Cursor(cursor DateTime) sessionCursorParam {
	return sessionCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r sessionQueryCreatedAtDateTime) In(value []DateTime) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryCreatedAtDateTime) InIfPresent(value []DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.In(value)
}

func (r sessionQueryCreatedAtDateTime) NotIn(value []DateTime) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r sessionQueryCreatedAtDateTime) Lt(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryCreatedAtDateTime) LtIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r sessionQueryCreatedAtDateTime) Lte(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryCreatedAtDateTime) LteIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r sessionQueryCreatedAtDateTime) Gt(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryCreatedAtDateTime) GtIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r sessionQueryCreatedAtDateTime) Gte(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryCreatedAtDateTime) GteIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r sessionQueryCreatedAtDateTime) Not(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryCreatedAtDateTime) NotIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r sessionQueryCreatedAtDateTime) Before(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r sessionQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r sessionQueryCreatedAtDateTime) After(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r sessionQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r sessionQueryCreatedAtDateTime) BeforeEquals(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r sessionQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r sessionQueryCreatedAtDateTime) AfterEquals(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r sessionQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type sessionQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r sessionQueryUpdatedAtDateTime) Set(value DateTime) sessionSetParam {

	return sessionSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r sessionQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) sessionSetParam {
	if value == nil {
		return sessionSetParam{}
	}

	return r.Set(*value)
}

func (r sessionQueryUpdatedAtDateTime) Equals(value DateTime) sessionWithPrismaUpdatedAtEqualsParam {

	return sessionWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) sessionWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return sessionWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r sessionQueryUpdatedAtDateTime) Order(direction SortOrder) sessionDefaultParam {
	return sessionDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r sessionQueryUpdatedAtDateTime) Cursor(cursor DateTime) sessionCursorParam {
	return sessionCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r sessionQueryUpdatedAtDateTime) In(value []DateTime) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryUpdatedAtDateTime) InIfPresent(value []DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.In(value)
}

func (r sessionQueryUpdatedAtDateTime) NotIn(value []DateTime) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r sessionQueryUpdatedAtDateTime) Lt(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r sessionQueryUpdatedAtDateTime) Lte(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r sessionQueryUpdatedAtDateTime) Gt(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r sessionQueryUpdatedAtDateTime) Gte(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r sessionQueryUpdatedAtDateTime) Not(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r sessionQueryUpdatedAtDateTime) Before(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r sessionQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r sessionQueryUpdatedAtDateTime) After(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r sessionQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r sessionQueryUpdatedAtDateTime) BeforeEquals(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r sessionQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r sessionQueryUpdatedAtDateTime) AfterEquals(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r sessionQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type sessionQueryStartedAtDateTime struct{}

// Set the optional value of StartedAt
func (r sessionQueryStartedAtDateTime) Set(value DateTime) sessionSetParam {

	return sessionSetParam{
		data: builder.Field{
			Name:  "startedAt",
			Value: value,
		},
	}

}

// Set the optional value of StartedAt dynamically
func (r sessionQueryStartedAtDateTime) SetIfPresent(value *DateTime) sessionSetParam {
	if value == nil {
		return sessionSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of StartedAt dynamically
func (r sessionQueryStartedAtDateTime) SetOptional(value *DateTime) sessionSetParam {
	if value == nil {

		var v *DateTime
		return sessionSetParam{
			data: builder.Field{
				Name:  "startedAt",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r sessionQueryStartedAtDateTime) Equals(value DateTime) sessionWithPrismaStartedAtEqualsParam {

	return sessionWithPrismaStartedAtEqualsParam{
		data: builder.Field{
			Name: "startedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryStartedAtDateTime) EqualsIfPresent(value *DateTime) sessionWithPrismaStartedAtEqualsParam {
	if value == nil {
		return sessionWithPrismaStartedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r sessionQueryStartedAtDateTime) EqualsOptional(value *DateTime) sessionDefaultParam {
	return sessionDefaultParam{
		data: builder.Field{
			Name: "startedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryStartedAtDateTime) IsNull() sessionDefaultParam {
	var str *string = nil
	return sessionDefaultParam{
		data: builder.Field{
			Name: "startedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r sessionQueryStartedAtDateTime) Order(direction SortOrder) sessionDefaultParam {
	return sessionDefaultParam{
		data: builder.Field{
			Name:  "startedAt",
			Value: direction,
		},
	}
}

func (r sessionQueryStartedAtDateTime) Cursor(cursor DateTime) sessionCursorParam {
	return sessionCursorParam{
		data: builder.Field{
			Name:  "startedAt",
			Value: cursor,
		},
	}
}

func (r sessionQueryStartedAtDateTime) In(value []DateTime) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "startedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryStartedAtDateTime) InIfPresent(value []DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.In(value)
}

func (r sessionQueryStartedAtDateTime) NotIn(value []DateTime) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "startedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryStartedAtDateTime) NotInIfPresent(value []DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r sessionQueryStartedAtDateTime) Lt(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "startedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryStartedAtDateTime) LtIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r sessionQueryStartedAtDateTime) Lte(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "startedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryStartedAtDateTime) LteIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r sessionQueryStartedAtDateTime) Gt(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "startedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryStartedAtDateTime) GtIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r sessionQueryStartedAtDateTime) Gte(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "startedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryStartedAtDateTime) GteIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r sessionQueryStartedAtDateTime) Not(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "startedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryStartedAtDateTime) NotIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r sessionQueryStartedAtDateTime) Before(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "startedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r sessionQueryStartedAtDateTime) BeforeIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r sessionQueryStartedAtDateTime) After(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "startedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r sessionQueryStartedAtDateTime) AfterIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r sessionQueryStartedAtDateTime) BeforeEquals(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "startedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r sessionQueryStartedAtDateTime) BeforeEqualsIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r sessionQueryStartedAtDateTime) AfterEquals(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "startedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r sessionQueryStartedAtDateTime) AfterEqualsIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type sessionQueryStoppedAtDateTime struct{}

// Set the optional value of StoppedAt
func (r sessionQueryStoppedAtDateTime) Set(value DateTime) sessionSetParam {

	return sessionSetParam{
		data: builder.Field{
			Name:  "stoppedAt",
			Value: value,
		},
	}

}

// Set the optional value of StoppedAt dynamically
func (r sessionQueryStoppedAtDateTime) SetIfPresent(value *DateTime) sessionSetParam {
	if value == nil {
		return sessionSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of StoppedAt dynamically
func (r sessionQueryStoppedAtDateTime) SetOptional(value *DateTime) sessionSetParam {
	if value == nil {

		var v *DateTime
		return sessionSetParam{
			data: builder.Field{
				Name:  "stoppedAt",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r sessionQueryStoppedAtDateTime) Equals(value DateTime) sessionWithPrismaStoppedAtEqualsParam {

	return sessionWithPrismaStoppedAtEqualsParam{
		data: builder.Field{
			Name: "stoppedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryStoppedAtDateTime) EqualsIfPresent(value *DateTime) sessionWithPrismaStoppedAtEqualsParam {
	if value == nil {
		return sessionWithPrismaStoppedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r sessionQueryStoppedAtDateTime) EqualsOptional(value *DateTime) sessionDefaultParam {
	return sessionDefaultParam{
		data: builder.Field{
			Name: "stoppedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryStoppedAtDateTime) IsNull() sessionDefaultParam {
	var str *string = nil
	return sessionDefaultParam{
		data: builder.Field{
			Name: "stoppedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r sessionQueryStoppedAtDateTime) Order(direction SortOrder) sessionDefaultParam {
	return sessionDefaultParam{
		data: builder.Field{
			Name:  "stoppedAt",
			Value: direction,
		},
	}
}

func (r sessionQueryStoppedAtDateTime) Cursor(cursor DateTime) sessionCursorParam {
	return sessionCursorParam{
		data: builder.Field{
			Name:  "stoppedAt",
			Value: cursor,
		},
	}
}

func (r sessionQueryStoppedAtDateTime) In(value []DateTime) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "stoppedAt",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryStoppedAtDateTime) InIfPresent(value []DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.In(value)
}

func (r sessionQueryStoppedAtDateTime) NotIn(value []DateTime) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "stoppedAt",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryStoppedAtDateTime) NotInIfPresent(value []DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r sessionQueryStoppedAtDateTime) Lt(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "stoppedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryStoppedAtDateTime) LtIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r sessionQueryStoppedAtDateTime) Lte(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "stoppedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryStoppedAtDateTime) LteIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r sessionQueryStoppedAtDateTime) Gt(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "stoppedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryStoppedAtDateTime) GtIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r sessionQueryStoppedAtDateTime) Gte(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "stoppedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryStoppedAtDateTime) GteIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r sessionQueryStoppedAtDateTime) Not(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "stoppedAt",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryStoppedAtDateTime) NotIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r sessionQueryStoppedAtDateTime) Before(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "stoppedAt",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r sessionQueryStoppedAtDateTime) BeforeIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r sessionQueryStoppedAtDateTime) After(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "stoppedAt",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r sessionQueryStoppedAtDateTime) AfterIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r sessionQueryStoppedAtDateTime) BeforeEquals(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "stoppedAt",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r sessionQueryStoppedAtDateTime) BeforeEqualsIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r sessionQueryStoppedAtDateTime) AfterEquals(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "stoppedAt",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r sessionQueryStoppedAtDateTime) AfterEqualsIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type sessionQueryPausedAtDateTime struct{}

// Set the required value of PausedAt
func (r sessionQueryPausedAtDateTime) Set(value []DateTime) sessionSetParam {

	if value == nil {
		value = []DateTime{}
	}

	return sessionSetParam{
		data: builder.Field{
			Name: "pausedAt",
			Fields: []builder.Field{
				builder.Field{
					Name:  "set",
					Value: value,
				},
			},
		},
	}

}

// Set the optional value of PausedAt dynamically
func (r sessionQueryPausedAtDateTime) SetIfPresent(value *[]DateTime) sessionSetParam {
	if value == nil {
		return sessionSetParam{}
	}

	return r.Set(*value)
}

// Push the required value of PausedAt
func (r sessionQueryPausedAtDateTime) Push(value []DateTime) sessionSetParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionSetParam{
		data: builder.Field{
			Name: "pausedAt",
			Fields: []builder.Field{
				builder.Field{
					Name: "push",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryPausedAtDateTime) PushIfPresent(value []DateTime) sessionSetParam {
	if value == nil {
		return sessionSetParam{}
	}
	return r.Push(value)
}

func (r sessionQueryPausedAtDateTime) Equals(value []DateTime) sessionWithPrismaPausedAtEqualsParam {

	if value == nil {
		value = []DateTime{}
	}

	return sessionWithPrismaPausedAtEqualsParam{
		data: builder.Field{
			Name: "pausedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryPausedAtDateTime) EqualsIfPresent(value []DateTime) sessionWithPrismaPausedAtEqualsParam {
	if value == nil {
		return sessionWithPrismaPausedAtEqualsParam{}
	}
	return r.Equals(value)
}

func (r sessionQueryPausedAtDateTime) Order(direction SortOrder) sessionDefaultParam {
	return sessionDefaultParam{
		data: builder.Field{
			Name:  "pausedAt",
			Value: direction,
		},
	}
}

func (r sessionQueryPausedAtDateTime) Cursor(cursor DateTime) sessionCursorParam {
	return sessionCursorParam{
		data: builder.Field{
			Name:  "pausedAt",
			Value: cursor,
		},
	}
}

func (r sessionQueryPausedAtDateTime) Has(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "pausedAt",
			Fields: []builder.Field{
				{
					Name: "has",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryPausedAtDateTime) HasIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Has(*value)
}

func (r sessionQueryPausedAtDateTime) HasEvery(value []DateTime) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "pausedAt",
			Fields: []builder.Field{
				{
					Name: "hasEvery",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryPausedAtDateTime) HasEveryIfPresent(value []DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.HasEvery(value)
}

func (r sessionQueryPausedAtDateTime) HasSome(value []DateTime) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "pausedAt",
			Fields: []builder.Field{
				{
					Name: "hasSome",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryPausedAtDateTime) HasSomeIfPresent(value []DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.HasSome(value)
}

func (r sessionQueryPausedAtDateTime) IsEmpty(value bool) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "pausedAt",
			Fields: []builder.Field{
				{
					Name: "isEmpty",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryPausedAtDateTime) IsEmptyIfPresent(value *bool) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.IsEmpty(*value)
}

// base struct
type sessionQueryResumedAtDateTime struct{}

// Set the required value of ResumedAt
func (r sessionQueryResumedAtDateTime) Set(value []DateTime) sessionSetParam {

	if value == nil {
		value = []DateTime{}
	}

	return sessionSetParam{
		data: builder.Field{
			Name: "resumedAt",
			Fields: []builder.Field{
				builder.Field{
					Name:  "set",
					Value: value,
				},
			},
		},
	}

}

// Set the optional value of ResumedAt dynamically
func (r sessionQueryResumedAtDateTime) SetIfPresent(value *[]DateTime) sessionSetParam {
	if value == nil {
		return sessionSetParam{}
	}

	return r.Set(*value)
}

// Push the required value of ResumedAt
func (r sessionQueryResumedAtDateTime) Push(value []DateTime) sessionSetParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionSetParam{
		data: builder.Field{
			Name: "resumedAt",
			Fields: []builder.Field{
				builder.Field{
					Name: "push",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryResumedAtDateTime) PushIfPresent(value []DateTime) sessionSetParam {
	if value == nil {
		return sessionSetParam{}
	}
	return r.Push(value)
}

func (r sessionQueryResumedAtDateTime) Equals(value []DateTime) sessionWithPrismaResumedAtEqualsParam {

	if value == nil {
		value = []DateTime{}
	}

	return sessionWithPrismaResumedAtEqualsParam{
		data: builder.Field{
			Name: "resumedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryResumedAtDateTime) EqualsIfPresent(value []DateTime) sessionWithPrismaResumedAtEqualsParam {
	if value == nil {
		return sessionWithPrismaResumedAtEqualsParam{}
	}
	return r.Equals(value)
}

func (r sessionQueryResumedAtDateTime) Order(direction SortOrder) sessionDefaultParam {
	return sessionDefaultParam{
		data: builder.Field{
			Name:  "resumedAt",
			Value: direction,
		},
	}
}

func (r sessionQueryResumedAtDateTime) Cursor(cursor DateTime) sessionCursorParam {
	return sessionCursorParam{
		data: builder.Field{
			Name:  "resumedAt",
			Value: cursor,
		},
	}
}

func (r sessionQueryResumedAtDateTime) Has(value DateTime) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "resumedAt",
			Fields: []builder.Field{
				{
					Name: "has",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryResumedAtDateTime) HasIfPresent(value *DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Has(*value)
}

func (r sessionQueryResumedAtDateTime) HasEvery(value []DateTime) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "resumedAt",
			Fields: []builder.Field{
				{
					Name: "hasEvery",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryResumedAtDateTime) HasEveryIfPresent(value []DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.HasEvery(value)
}

func (r sessionQueryResumedAtDateTime) HasSome(value []DateTime) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "resumedAt",
			Fields: []builder.Field{
				{
					Name: "hasSome",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryResumedAtDateTime) HasSomeIfPresent(value []DateTime) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.HasSome(value)
}

func (r sessionQueryResumedAtDateTime) IsEmpty(value bool) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "resumedAt",
			Fields: []builder.Field{
				{
					Name: "isEmpty",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryResumedAtDateTime) IsEmptyIfPresent(value *bool) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.IsEmpty(*value)
}

// base struct
type sessionQueryRunRun struct{}

type sessionQueryRunRelations struct{}

// Session -> Run
//
// @relation
// @required
func (sessionQueryRunRelations) Where(
	params ...RunWhereParam,
) sessionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "run",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (sessionQueryRunRelations) Fetch() sessionToRunFindUnique {
	var v sessionToRunFindUnique

	v.query.Operation = "query"
	v.query.Method = "run"
	v.query.Outputs = runOutput

	return v
}

func (r sessionQueryRunRelations) Link(
	params RunWhereParam,
) sessionWithPrismaRunSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return sessionWithPrismaRunSetParam{}
	}

	fields = append(fields, f)

	return sessionWithPrismaRunSetParam{
		data: builder.Field{
			Name: "run",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r sessionQueryRunRelations) Unlink() sessionWithPrismaRunSetParam {
	var v sessionWithPrismaRunSetParam

	v = sessionWithPrismaRunSetParam{
		data: builder.Field{
			Name: "run",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type sessionQueryInstancesInstance struct{}

type sessionQueryInstancesRelations struct{}

// Session -> Instances
//
// @relation
// @required
func (sessionQueryInstancesRelations) Some(
	params ...InstanceWhereParam,
) sessionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "instances",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Session -> Instances
//
// @relation
// @required
func (sessionQueryInstancesRelations) Every(
	params ...InstanceWhereParam,
) sessionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "instances",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (sessionQueryInstancesRelations) Fetch(

	params ...InstanceWhereParam,

) sessionToInstancesFindMany {
	var v sessionToInstancesFindMany

	v.query.Operation = "query"
	v.query.Method = "instances"
	v.query.Outputs = instanceOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r sessionQueryInstancesRelations) Link(
	params ...InstanceWhereParam,
) sessionSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return sessionSetParam{
		data: builder.Field{
			Name: "instances",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r sessionQueryInstancesRelations) Unlink(
	params ...InstanceWhereParam,
) sessionSetParam {
	var v sessionSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = sessionSetParam{
		data: builder.Field{
			Name: "instances",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type sessionQueryStateSessionState struct{}

// Set the required value of State
func (r sessionQueryStateSessionState) Set(value SessionState) sessionSetParam {

	return sessionSetParam{
		data: builder.Field{
			Name:  "state",
			Value: value,
		},
	}

}

// Set the optional value of State dynamically
func (r sessionQueryStateSessionState) SetIfPresent(value *SessionState) sessionSetParam {
	if value == nil {
		return sessionSetParam{}
	}

	return r.Set(*value)
}

func (r sessionQueryStateSessionState) Equals(value SessionState) sessionWithPrismaStateEqualsParam {

	return sessionWithPrismaStateEqualsParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryStateSessionState) EqualsIfPresent(value *SessionState) sessionWithPrismaStateEqualsParam {
	if value == nil {
		return sessionWithPrismaStateEqualsParam{}
	}
	return r.Equals(*value)
}

func (r sessionQueryStateSessionState) Order(direction SortOrder) sessionDefaultParam {
	return sessionDefaultParam{
		data: builder.Field{
			Name:  "state",
			Value: direction,
		},
	}
}

func (r sessionQueryStateSessionState) Cursor(cursor SessionState) sessionCursorParam {
	return sessionCursorParam{
		data: builder.Field{
			Name:  "state",
			Value: cursor,
		},
	}
}

func (r sessionQueryStateSessionState) In(value []SessionState) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryStateSessionState) InIfPresent(value []SessionState) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.In(value)
}

func (r sessionQueryStateSessionState) NotIn(value []SessionState) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryStateSessionState) NotInIfPresent(value []SessionState) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r sessionQueryStateSessionState) Not(value SessionState) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryStateSessionState) NotIfPresent(value *SessionState) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Not(*value)
}

// base struct
type sessionQueryDeletedBoolean struct{}

// Set the required value of Deleted
func (r sessionQueryDeletedBoolean) Set(value bool) sessionSetParam {

	return sessionSetParam{
		data: builder.Field{
			Name:  "deleted",
			Value: value,
		},
	}

}

// Set the optional value of Deleted dynamically
func (r sessionQueryDeletedBoolean) SetIfPresent(value *bool) sessionSetParam {
	if value == nil {
		return sessionSetParam{}
	}

	return r.Set(*value)
}

func (r sessionQueryDeletedBoolean) Equals(value bool) sessionWithPrismaDeletedEqualsParam {

	return sessionWithPrismaDeletedEqualsParam{
		data: builder.Field{
			Name: "deleted",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryDeletedBoolean) EqualsIfPresent(value *bool) sessionWithPrismaDeletedEqualsParam {
	if value == nil {
		return sessionWithPrismaDeletedEqualsParam{}
	}
	return r.Equals(*value)
}

func (r sessionQueryDeletedBoolean) Order(direction SortOrder) sessionDefaultParam {
	return sessionDefaultParam{
		data: builder.Field{
			Name:  "deleted",
			Value: direction,
		},
	}
}

func (r sessionQueryDeletedBoolean) Cursor(cursor bool) sessionCursorParam {
	return sessionCursorParam{
		data: builder.Field{
			Name:  "deleted",
			Value: cursor,
		},
	}
}

// base struct
type sessionQueryRunIDString struct{}

// Set the required value of RunID
func (r sessionQueryRunIDString) Set(value string) sessionSetParam {

	return sessionSetParam{
		data: builder.Field{
			Name:  "runID",
			Value: value,
		},
	}

}

// Set the optional value of RunID dynamically
func (r sessionQueryRunIDString) SetIfPresent(value *string) sessionSetParam {
	if value == nil {
		return sessionSetParam{}
	}

	return r.Set(*value)
}

func (r sessionQueryRunIDString) Equals(value string) sessionWithPrismaRunIDEqualsParam {

	return sessionWithPrismaRunIDEqualsParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryRunIDString) EqualsIfPresent(value *string) sessionWithPrismaRunIDEqualsParam {
	if value == nil {
		return sessionWithPrismaRunIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r sessionQueryRunIDString) Order(direction SortOrder) sessionDefaultParam {
	return sessionDefaultParam{
		data: builder.Field{
			Name:  "runID",
			Value: direction,
		},
	}
}

func (r sessionQueryRunIDString) Cursor(cursor string) sessionCursorParam {
	return sessionCursorParam{
		data: builder.Field{
			Name:  "runID",
			Value: cursor,
		},
	}
}

func (r sessionQueryRunIDString) In(value []string) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryRunIDString) InIfPresent(value []string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.In(value)
}

func (r sessionQueryRunIDString) NotIn(value []string) sessionDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r sessionQueryRunIDString) NotInIfPresent(value []string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r sessionQueryRunIDString) Lt(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryRunIDString) LtIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r sessionQueryRunIDString) Lte(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryRunIDString) LteIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r sessionQueryRunIDString) Gt(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryRunIDString) GtIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r sessionQueryRunIDString) Gte(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryRunIDString) GteIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r sessionQueryRunIDString) Contains(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryRunIDString) ContainsIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Contains(*value)
}

func (r sessionQueryRunIDString) StartsWith(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryRunIDString) StartsWithIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r sessionQueryRunIDString) EndsWith(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryRunIDString) EndsWithIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r sessionQueryRunIDString) Mode(value QueryMode) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryRunIDString) ModeIfPresent(value *QueryMode) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Mode(*value)
}

func (r sessionQueryRunIDString) Not(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r sessionQueryRunIDString) NotIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r sessionQueryRunIDString) HasPrefix(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r sessionQueryRunIDString) HasPrefixIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r sessionQueryRunIDString) HasSuffix(value string) sessionDefaultParam {

	return sessionDefaultParam{
		data: builder.Field{
			Name: "runID",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r sessionQueryRunIDString) HasSuffixIfPresent(value *string) sessionDefaultParam {
	if value == nil {
		return sessionDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type sessionQueryDataDatum struct{}

type sessionQueryDataRelations struct{}

// Session -> Data
//
// @relation
// @required
func (sessionQueryDataRelations) Some(
	params ...DatumWhereParam,
) sessionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "data",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Session -> Data
//
// @relation
// @required
func (sessionQueryDataRelations) Every(
	params ...DatumWhereParam,
) sessionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return sessionDefaultParam{
		data: builder.Field{
			Name: "data",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

func (sessionQueryDataRelations) Fetch(

	params ...DatumWhereParam,

) sessionToDataFindMany {
	var v sessionToDataFindMany

	v.query.Operation = "query"
	v.query.Method = "data"
	v.query.Outputs = datumOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r sessionQueryDataRelations) Link(
	params ...DatumWhereParam,
) sessionSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return sessionSetParam{
		data: builder.Field{
			Name: "data",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r sessionQueryDataRelations) Unlink(
	params ...DatumWhereParam,
) sessionSetParam {
	var v sessionSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = sessionSetParam{
		data: builder.Field{
			Name: "data",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// --- template upsert.gotpl ---

type userUpsertOne struct {
	query builder.Query
}

func (r userUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) with()         {}
func (r userUpsertOne) userModel()    {}
func (r userUpsertOne) userRelation() {}

func (r userActions) UpsertOne(
	params UserEqualsUniqueWhereParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userUpsertOne) Create(

	_email UserWithPrismaEmailSetParam,
	_role UserWithPrismaRoleSetParam,

	optional ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _email.field())
	fields = append(fields, _role.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Update(
	params ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpsertOne) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type passwordUpsertOne struct {
	query builder.Query
}

func (r passwordUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r passwordUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r passwordUpsertOne) with()             {}
func (r passwordUpsertOne) passwordModel()    {}
func (r passwordUpsertOne) passwordRelation() {}

func (r passwordActions) UpsertOne(
	params PasswordEqualsUniqueWhereParam,
) passwordUpsertOne {
	var v passwordUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Password"
	v.query.Outputs = passwordOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r passwordUpsertOne) Create(

	_hash PasswordWithPrismaHashSetParam,
	_user PasswordWithPrismaUserSetParam,

	optional ...PasswordSetParam,
) passwordUpsertOne {
	var v passwordUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _hash.field())
	fields = append(fields, _user.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r passwordUpsertOne) Update(
	params ...PasswordSetParam,
) passwordUpsertOne {
	var v passwordUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r passwordUpsertOne) Exec(ctx context.Context) (*PasswordModel, error) {
	var v PasswordModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r passwordUpsertOne) Tx() passwordUniqueTxResult {
	v := NewpasswordUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type netUpsertOne struct {
	query builder.Query
}

func (r netUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r netUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r netUpsertOne) with()        {}
func (r netUpsertOne) netModel()    {}
func (r netUpsertOne) netRelation() {}

func (r netActions) UpsertOne(
	params NetEqualsUniqueWhereParam,
) netUpsertOne {
	var v netUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Net"
	v.query.Outputs = netOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r netUpsertOne) Create(

	_name NetWithPrismaNameSetParam,
	_description NetWithPrismaDescriptionSetParam,
	_author NetWithPrismaAuthorSetParam,

	optional ...NetSetParam,
) netUpsertOne {
	var v netUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _description.field())
	fields = append(fields, _author.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r netUpsertOne) Update(
	params ...NetSetParam,
) netUpsertOne {
	var v netUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r netUpsertOne) Exec(ctx context.Context) (*NetModel, error) {
	var v NetModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r netUpsertOne) Tx() netUniqueTxResult {
	v := NewnetUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type placeInterfaceUpsertOne struct {
	query builder.Query
}

func (r placeInterfaceUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r placeInterfaceUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r placeInterfaceUpsertOne) with()                   {}
func (r placeInterfaceUpsertOne) placeInterfaceModel()    {}
func (r placeInterfaceUpsertOne) placeInterfaceRelation() {}

func (r placeInterfaceActions) UpsertOne(
	params PlaceInterfaceEqualsUniqueWhereParam,
) placeInterfaceUpsertOne {
	var v placeInterfaceUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "PlaceInterface"
	v.query.Outputs = placeInterfaceOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r placeInterfaceUpsertOne) Create(

	_name PlaceInterfaceWithPrismaNameSetParam,
	_net PlaceInterfaceWithPrismaNetSetParam,
	_bound PlaceInterfaceWithPrismaBoundSetParam,

	optional ...PlaceInterfaceSetParam,
) placeInterfaceUpsertOne {
	var v placeInterfaceUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _net.field())
	fields = append(fields, _bound.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r placeInterfaceUpsertOne) Update(
	params ...PlaceInterfaceSetParam,
) placeInterfaceUpsertOne {
	var v placeInterfaceUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r placeInterfaceUpsertOne) Exec(ctx context.Context) (*PlaceInterfaceModel, error) {
	var v PlaceInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeInterfaceUpsertOne) Tx() placeInterfaceUniqueTxResult {
	v := NewplaceInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionInterfaceUpsertOne struct {
	query builder.Query
}

func (r transitionInterfaceUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionInterfaceUpsertOne) with()                        {}
func (r transitionInterfaceUpsertOne) transitionInterfaceModel()    {}
func (r transitionInterfaceUpsertOne) transitionInterfaceRelation() {}

func (r transitionInterfaceActions) UpsertOne(
	params TransitionInterfaceEqualsUniqueWhereParam,
) transitionInterfaceUpsertOne {
	var v transitionInterfaceUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "TransitionInterface"
	v.query.Outputs = transitionInterfaceOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r transitionInterfaceUpsertOne) Create(

	_name TransitionInterfaceWithPrismaNameSetParam,
	_net TransitionInterfaceWithPrismaNetSetParam,

	optional ...TransitionInterfaceSetParam,
) transitionInterfaceUpsertOne {
	var v transitionInterfaceUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _net.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r transitionInterfaceUpsertOne) Update(
	params ...TransitionInterfaceSetParam,
) transitionInterfaceUpsertOne {
	var v transitionInterfaceUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r transitionInterfaceUpsertOne) Exec(ctx context.Context) (*TransitionInterfaceModel, error) {
	var v TransitionInterfaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionInterfaceUpsertOne) Tx() transitionInterfaceUniqueTxResult {
	v := NewtransitionInterfaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type placeUpsertOne struct {
	query builder.Query
}

func (r placeUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r placeUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r placeUpsertOne) with()          {}
func (r placeUpsertOne) placeModel()    {}
func (r placeUpsertOne) placeRelation() {}

func (r placeActions) UpsertOne(
	params PlaceEqualsUniqueWhereParam,
) placeUpsertOne {
	var v placeUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Place"
	v.query.Outputs = placeOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r placeUpsertOne) Create(

	_name PlaceWithPrismaNameSetParam,
	_bound PlaceWithPrismaBoundSetParam,

	optional ...PlaceSetParam,
) placeUpsertOne {
	var v placeUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _bound.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r placeUpsertOne) Update(
	params ...PlaceSetParam,
) placeUpsertOne {
	var v placeUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r placeUpsertOne) Exec(ctx context.Context) (*PlaceModel, error) {
	var v PlaceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r placeUpsertOne) Tx() placeUniqueTxResult {
	v := NewplaceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transitionUpsertOne struct {
	query builder.Query
}

func (r transitionUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r transitionUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r transitionUpsertOne) with()               {}
func (r transitionUpsertOne) transitionModel()    {}
func (r transitionUpsertOne) transitionRelation() {}

func (r transitionActions) UpsertOne(
	params TransitionEqualsUniqueWhereParam,
) transitionUpsertOne {
	var v transitionUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Transition"
	v.query.Outputs = transitionOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r transitionUpsertOne) Create(

	_name TransitionWithPrismaNameSetParam,

	optional ...TransitionSetParam,
) transitionUpsertOne {
	var v transitionUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r transitionUpsertOne) Update(
	params ...TransitionSetParam,
) transitionUpsertOne {
	var v transitionUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r transitionUpsertOne) Exec(ctx context.Context) (*TransitionModel, error) {
	var v TransitionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transitionUpsertOne) Tx() transitionUniqueTxResult {
	v := NewtransitionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type arcUpsertOne struct {
	query builder.Query
}

func (r arcUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r arcUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r arcUpsertOne) with()        {}
func (r arcUpsertOne) arcModel()    {}
func (r arcUpsertOne) arcRelation() {}

func (r arcActions) UpsertOne(
	params ArcEqualsUniqueWhereParam,
) arcUpsertOne {
	var v arcUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Arc"
	v.query.Outputs = arcOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r arcUpsertOne) Create(

	_net ArcWithPrismaNetSetParam,
	_fromPlace ArcWithPrismaFromPlaceSetParam,
	_place ArcWithPrismaPlaceSetParam,
	_transition ArcWithPrismaTransitionSetParam,

	optional ...ArcSetParam,
) arcUpsertOne {
	var v arcUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _net.field())
	fields = append(fields, _fromPlace.field())
	fields = append(fields, _place.field())
	fields = append(fields, _transition.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r arcUpsertOne) Update(
	params ...ArcSetParam,
) arcUpsertOne {
	var v arcUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r arcUpsertOne) Exec(ctx context.Context) (*ArcModel, error) {
	var v ArcModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r arcUpsertOne) Tx() arcUniqueTxResult {
	v := NewarcUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type devicesOnNetsUpsertOne struct {
	query builder.Query
}

func (r devicesOnNetsUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesOnNetsUpsertOne) with()                  {}
func (r devicesOnNetsUpsertOne) devicesOnNetsModel()    {}
func (r devicesOnNetsUpsertOne) devicesOnNetsRelation() {}

func (r devicesOnNetsActions) UpsertOne(
	params DevicesOnNetsEqualsUniqueWhereParam,
) devicesOnNetsUpsertOne {
	var v devicesOnNetsUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "DevicesOnNets"
	v.query.Outputs = devicesOnNetsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r devicesOnNetsUpsertOne) Create(

	_device DevicesOnNetsWithPrismaDeviceSetParam,
	_net DevicesOnNetsWithPrismaNetSetParam,

	optional ...DevicesOnNetsSetParam,
) devicesOnNetsUpsertOne {
	var v devicesOnNetsUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _device.field())
	fields = append(fields, _net.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r devicesOnNetsUpsertOne) Update(
	params ...DevicesOnNetsSetParam,
) devicesOnNetsUpsertOne {
	var v devicesOnNetsUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r devicesOnNetsUpsertOne) Exec(ctx context.Context) (*DevicesOnNetsModel, error) {
	var v DevicesOnNetsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesOnNetsUpsertOne) Tx() devicesOnNetsUniqueTxResult {
	v := NewdevicesOnNetsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fieldUpsertOne struct {
	query builder.Query
}

func (r fieldUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r fieldUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r fieldUpsertOne) with()          {}
func (r fieldUpsertOne) fieldModel()    {}
func (r fieldUpsertOne) fieldRelation() {}

func (r fieldActions) UpsertOne(
	params FieldEqualsUniqueWhereParam,
) fieldUpsertOne {
	var v fieldUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Field"
	v.query.Outputs = fieldOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r fieldUpsertOne) Create(

	_name FieldWithPrismaNameSetParam,
	_type FieldWithPrismaTypeSetParam,
	_event FieldWithPrismaEventSetParam,

	optional ...FieldSetParam,
) fieldUpsertOne {
	var v fieldUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _type.field())
	fields = append(fields, _event.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r fieldUpsertOne) Update(
	params ...FieldSetParam,
) fieldUpsertOne {
	var v fieldUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r fieldUpsertOne) Exec(ctx context.Context) (*FieldModel, error) {
	var v FieldModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fieldUpsertOne) Tx() fieldUniqueTxResult {
	v := NewfieldUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type eventUpsertOne struct {
	query builder.Query
}

func (r eventUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r eventUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r eventUpsertOne) with()          {}
func (r eventUpsertOne) eventModel()    {}
func (r eventUpsertOne) eventRelation() {}

func (r eventActions) UpsertOne(
	params EventEqualsUniqueWhereParam,
) eventUpsertOne {
	var v eventUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Event"
	v.query.Outputs = eventOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r eventUpsertOne) Create(

	_name EventWithPrismaNameSetParam,

	optional ...EventSetParam,
) eventUpsertOne {
	var v eventUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r eventUpsertOne) Update(
	params ...EventSetParam,
) eventUpsertOne {
	var v eventUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r eventUpsertOne) Exec(ctx context.Context) (*EventModel, error) {
	var v EventModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r eventUpsertOne) Tx() eventUniqueTxResult {
	v := NeweventUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type instanceUpsertOne struct {
	query builder.Query
}

func (r instanceUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r instanceUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r instanceUpsertOne) with()             {}
func (r instanceUpsertOne) instanceModel()    {}
func (r instanceUpsertOne) instanceRelation() {}

func (r instanceActions) UpsertOne(
	params InstanceEqualsUniqueWhereParam,
) instanceUpsertOne {
	var v instanceUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Instance"
	v.query.Outputs = instanceOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r instanceUpsertOne) Create(

	_author InstanceWithPrismaAuthorSetParam,
	_language InstanceWithPrismaLanguageSetParam,
	_name InstanceWithPrismaNameSetParam,
	_device InstanceWithPrismaDeviceSetParam,
	_addr InstanceWithPrismaAddrSetParam,

	optional ...InstanceSetParam,
) instanceUpsertOne {
	var v instanceUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _author.field())
	fields = append(fields, _language.field())
	fields = append(fields, _name.field())
	fields = append(fields, _device.field())
	fields = append(fields, _addr.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r instanceUpsertOne) Update(
	params ...InstanceSetParam,
) instanceUpsertOne {
	var v instanceUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r instanceUpsertOne) Exec(ctx context.Context) (*InstanceModel, error) {
	var v InstanceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r instanceUpsertOne) Tx() instanceUniqueTxResult {
	v := NewinstanceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type deviceUpsertOne struct {
	query builder.Query
}

func (r deviceUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r deviceUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r deviceUpsertOne) with()           {}
func (r deviceUpsertOne) deviceModel()    {}
func (r deviceUpsertOne) deviceRelation() {}

func (r deviceActions) UpsertOne(
	params DeviceEqualsUniqueWhereParam,
) deviceUpsertOne {
	var v deviceUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Device"
	v.query.Outputs = deviceOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r deviceUpsertOne) Create(

	_author DeviceWithPrismaAuthorSetParam,
	_name DeviceWithPrismaNameSetParam,
	_description DeviceWithPrismaDescriptionSetParam,

	optional ...DeviceSetParam,
) deviceUpsertOne {
	var v deviceUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _author.field())
	fields = append(fields, _name.field())
	fields = append(fields, _description.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r deviceUpsertOne) Update(
	params ...DeviceSetParam,
) deviceUpsertOne {
	var v deviceUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r deviceUpsertOne) Exec(ctx context.Context) (*DeviceModel, error) {
	var v DeviceModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r deviceUpsertOne) Tx() deviceUniqueTxResult {
	v := NewdeviceUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type constantUpsertOne struct {
	query builder.Query
}

func (r constantUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r constantUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r constantUpsertOne) with()             {}
func (r constantUpsertOne) constantModel()    {}
func (r constantUpsertOne) constantRelation() {}

func (r constantActions) UpsertOne(
	params ConstantEqualsUniqueWhereParam,
) constantUpsertOne {
	var v constantUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Constant"
	v.query.Outputs = constantOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r constantUpsertOne) Create(

	_action ConstantWithPrismaActionSetParam,
	_field ConstantWithPrismaFieldSetParam,
	_value ConstantWithPrismaValueSetParam,

	optional ...ConstantSetParam,
) constantUpsertOne {
	var v constantUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _action.field())
	fields = append(fields, _field.field())
	fields = append(fields, _value.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r constantUpsertOne) Update(
	params ...ConstantSetParam,
) constantUpsertOne {
	var v constantUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r constantUpsertOne) Exec(ctx context.Context) (*ConstantModel, error) {
	var v ConstantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r constantUpsertOne) Tx() constantUniqueTxResult {
	v := NewconstantUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type actionUpsertOne struct {
	query builder.Query
}

func (r actionUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r actionUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r actionUpsertOne) with()           {}
func (r actionUpsertOne) actionModel()    {}
func (r actionUpsertOne) actionRelation() {}

func (r actionActions) UpsertOne(
	params ActionEqualsUniqueWhereParam,
) actionUpsertOne {
	var v actionUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Action"
	v.query.Outputs = actionOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r actionUpsertOne) Create(

	_input ActionWithPrismaInputSetParam,
	_output ActionWithPrismaOutputSetParam,
	_device ActionWithPrismaDeviceSetParam,
	_event ActionWithPrismaEventSetParam,

	optional ...ActionSetParam,
) actionUpsertOne {
	var v actionUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _input.field())
	fields = append(fields, _output.field())
	fields = append(fields, _device.field())
	fields = append(fields, _event.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r actionUpsertOne) Update(
	params ...ActionSetParam,
) actionUpsertOne {
	var v actionUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r actionUpsertOne) Exec(ctx context.Context) (*ActionModel, error) {
	var v ActionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r actionUpsertOne) Tx() actionUniqueTxResult {
	v := NewactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type stepUpsertOne struct {
	query builder.Query
}

func (r stepUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r stepUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r stepUpsertOne) with()         {}
func (r stepUpsertOne) stepModel()    {}
func (r stepUpsertOne) stepRelation() {}

func (r stepActions) UpsertOne(
	params StepEqualsUniqueWhereParam,
) stepUpsertOne {
	var v stepUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Step"
	v.query.Outputs = stepOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r stepUpsertOne) Create(

	_order StepWithPrismaOrderSetParam,
	_run StepWithPrismaRunSetParam,
	_action StepWithPrismaActionSetParam,

	optional ...StepSetParam,
) stepUpsertOne {
	var v stepUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _order.field())
	fields = append(fields, _run.field())
	fields = append(fields, _action.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r stepUpsertOne) Update(
	params ...StepSetParam,
) stepUpsertOne {
	var v stepUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r stepUpsertOne) Exec(ctx context.Context) (*StepModel, error) {
	var v StepModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r stepUpsertOne) Tx() stepUniqueTxResult {
	v := NewstepUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type runUpsertOne struct {
	query builder.Query
}

func (r runUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r runUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r runUpsertOne) with()        {}
func (r runUpsertOne) runModel()    {}
func (r runUpsertOne) runRelation() {}

func (r runActions) UpsertOne(
	params RunEqualsUniqueWhereParam,
) runUpsertOne {
	var v runUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Run"
	v.query.Outputs = runOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r runUpsertOne) Create(

	_name RunWithPrismaNameSetParam,
	_description RunWithPrismaDescriptionSetParam,
	_net RunWithPrismaNetSetParam,

	optional ...RunSetParam,
) runUpsertOne {
	var v runUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _description.field())
	fields = append(fields, _net.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r runUpsertOne) Update(
	params ...RunSetParam,
) runUpsertOne {
	var v runUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r runUpsertOne) Exec(ctx context.Context) (*RunModel, error) {
	var v RunModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r runUpsertOne) Tx() runUniqueTxResult {
	v := NewrunUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type datumUpsertOne struct {
	query builder.Query
}

func (r datumUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r datumUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r datumUpsertOne) with()          {}
func (r datumUpsertOne) datumModel()    {}
func (r datumUpsertOne) datumRelation() {}

func (r datumActions) UpsertOne(
	params DatumEqualsUniqueWhereParam,
) datumUpsertOne {
	var v datumUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Datum"
	v.query.Outputs = datumOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r datumUpsertOne) Create(

	_instance DatumWithPrismaInstanceSetParam,
	_session DatumWithPrismaSessionSetParam,
	_event DatumWithPrismaEventSetParam,

	optional ...DatumSetParam,
) datumUpsertOne {
	var v datumUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _instance.field())
	fields = append(fields, _session.field())
	fields = append(fields, _event.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r datumUpsertOne) Update(
	params ...DatumSetParam,
) datumUpsertOne {
	var v datumUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r datumUpsertOne) Exec(ctx context.Context) (*DatumModel, error) {
	var v DatumModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r datumUpsertOne) Tx() datumUniqueTxResult {
	v := NewdatumUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type sessionUpsertOne struct {
	query builder.Query
}

func (r sessionUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r sessionUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r sessionUpsertOne) with()            {}
func (r sessionUpsertOne) sessionModel()    {}
func (r sessionUpsertOne) sessionRelation() {}

func (r sessionActions) UpsertOne(
	params SessionEqualsUniqueWhereParam,
) sessionUpsertOne {
	var v sessionUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Session"
	v.query.Outputs = sessionOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r sessionUpsertOne) Create(

	_user SessionWithPrismaUserSetParam,
	_run SessionWithPrismaRunSetParam,

	optional ...SessionSetParam,
) sessionUpsertOne {
	var v sessionUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _user.field())
	fields = append(fields, _run.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r sessionUpsertOne) Update(
	params ...SessionSetParam,
) sessionUpsertOne {
	var v sessionUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r sessionUpsertOne) Exec(ctx context.Context) (*SessionModel, error) {
	var v SessionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r sessionUpsertOne) Tx() sessionUniqueTxResult {
	v := NewsessionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template enums.gotpl ---

type UserRole string

const (
	UserRoleNONE      UserRole = "NONE"
	UserRoleADMIN     UserRole = "ADMIN"
	UserRoleDEVELOPER UserRole = "DEVELOPER"
	UserRoleREVIERWER UserRole = "REVIERWER"
	UserRoleUSER      UserRole = "USER"
)

type RawUserRole UserRole
type Language string

const (
	LanguageNONE   Language = "NONE"
	LanguageCPP    Language = "CPP"
	LanguageGO     Language = "GO"
	LanguageJS     Language = "JS"
	LanguagePYTHON Language = "PYTHON"
)

type RawLanguage Language
type SessionState string

const (
	SessionStateNONE    SessionState = "NONE"
	SessionStateRUNNING SessionState = "RUNNING"
	SessionStatePAUSED  SessionState = "PAUSED"
	SessionStateSTOPPED SessionState = "STOPPED"
)

type RawSessionState SessionState

type TransactionIsolationLevel string

const (
	TransactionIsolationLevelReadUncommitted TransactionIsolationLevel = "ReadUncommitted"
	TransactionIsolationLevelReadCommitted   TransactionIsolationLevel = "ReadCommitted"
	TransactionIsolationLevelRepeatableRead  TransactionIsolationLevel = "RepeatableRead"
	TransactionIsolationLevelSerializable    TransactionIsolationLevel = "Serializable"
)

type UserScalarFieldEnum string

const (
	UserScalarFieldEnumID        UserScalarFieldEnum = "id"
	UserScalarFieldEnumEmail     UserScalarFieldEnum = "email"
	UserScalarFieldEnumRole      UserScalarFieldEnum = "role"
	UserScalarFieldEnumCreatedAt UserScalarFieldEnum = "createdAt"
	UserScalarFieldEnumUpdatedAt UserScalarFieldEnum = "updatedAt"
)

type PasswordScalarFieldEnum string

const (
	PasswordScalarFieldEnumHash   PasswordScalarFieldEnum = "hash"
	PasswordScalarFieldEnumUserID PasswordScalarFieldEnum = "userId"
)

type NetScalarFieldEnum string

const (
	NetScalarFieldEnumID             NetScalarFieldEnum = "id"
	NetScalarFieldEnumName           NetScalarFieldEnum = "name"
	NetScalarFieldEnumDescription    NetScalarFieldEnum = "description"
	NetScalarFieldEnumInitialMarking NetScalarFieldEnum = "initialMarking"
	NetScalarFieldEnumCreatedAt      NetScalarFieldEnum = "createdAt"
	NetScalarFieldEnumUpdatedAt      NetScalarFieldEnum = "updatedAt"
	NetScalarFieldEnumAuthorID       NetScalarFieldEnum = "authorID"
	NetScalarFieldEnumParentID       NetScalarFieldEnum = "parentID"
)

type PlaceInterfaceScalarFieldEnum string

const (
	PlaceInterfaceScalarFieldEnumID        PlaceInterfaceScalarFieldEnum = "id"
	PlaceInterfaceScalarFieldEnumName      PlaceInterfaceScalarFieldEnum = "name"
	PlaceInterfaceScalarFieldEnumBound     PlaceInterfaceScalarFieldEnum = "bound"
	PlaceInterfaceScalarFieldEnumNetID     PlaceInterfaceScalarFieldEnum = "netID"
	PlaceInterfaceScalarFieldEnumCreatedAt PlaceInterfaceScalarFieldEnum = "createdAt"
	PlaceInterfaceScalarFieldEnumUpdatedAt PlaceInterfaceScalarFieldEnum = "updatedAt"
)

type TransitionInterfaceScalarFieldEnum string

const (
	TransitionInterfaceScalarFieldEnumID        TransitionInterfaceScalarFieldEnum = "id"
	TransitionInterfaceScalarFieldEnumName      TransitionInterfaceScalarFieldEnum = "name"
	TransitionInterfaceScalarFieldEnumNetID     TransitionInterfaceScalarFieldEnum = "netID"
	TransitionInterfaceScalarFieldEnumCreatedAt TransitionInterfaceScalarFieldEnum = "createdAt"
	TransitionInterfaceScalarFieldEnumUpdatedAt TransitionInterfaceScalarFieldEnum = "updatedAt"
)

type PlaceScalarFieldEnum string

const (
	PlaceScalarFieldEnumID          PlaceScalarFieldEnum = "id"
	PlaceScalarFieldEnumName        PlaceScalarFieldEnum = "name"
	PlaceScalarFieldEnumDescription PlaceScalarFieldEnum = "description"
	PlaceScalarFieldEnumCreatedAt   PlaceScalarFieldEnum = "createdAt"
	PlaceScalarFieldEnumUpdatedAt   PlaceScalarFieldEnum = "updatedAt"
	PlaceScalarFieldEnumBound       PlaceScalarFieldEnum = "bound"
)

type TransitionScalarFieldEnum string

const (
	TransitionScalarFieldEnumID          TransitionScalarFieldEnum = "id"
	TransitionScalarFieldEnumCondition   TransitionScalarFieldEnum = "condition"
	TransitionScalarFieldEnumDescription TransitionScalarFieldEnum = "description"
	TransitionScalarFieldEnumName        TransitionScalarFieldEnum = "name"
	TransitionScalarFieldEnumCreatedAt   TransitionScalarFieldEnum = "createdAt"
	TransitionScalarFieldEnumUpdatedAt   TransitionScalarFieldEnum = "updatedAt"
)

type ArcScalarFieldEnum string

const (
	ArcScalarFieldEnumID           ArcScalarFieldEnum = "id"
	ArcScalarFieldEnumNetID        ArcScalarFieldEnum = "netID"
	ArcScalarFieldEnumFromPlace    ArcScalarFieldEnum = "fromPlace"
	ArcScalarFieldEnumPlaceID      ArcScalarFieldEnum = "placeID"
	ArcScalarFieldEnumTransitionID ArcScalarFieldEnum = "transitionID"
	ArcScalarFieldEnumCreatedAt    ArcScalarFieldEnum = "createdAt"
	ArcScalarFieldEnumUpdatedAt    ArcScalarFieldEnum = "updatedAt"
)

type DevicesOnNetsScalarFieldEnum string

const (
	DevicesOnNetsScalarFieldEnumDeviceID DevicesOnNetsScalarFieldEnum = "deviceID"
	DevicesOnNetsScalarFieldEnumNetID    DevicesOnNetsScalarFieldEnum = "netID"
)

type FieldScalarFieldEnum string

const (
	FieldScalarFieldEnumID        FieldScalarFieldEnum = "id"
	FieldScalarFieldEnumName      FieldScalarFieldEnum = "name"
	FieldScalarFieldEnumType      FieldScalarFieldEnum = "type"
	FieldScalarFieldEnumCondition FieldScalarFieldEnum = "condition"
	FieldScalarFieldEnumEventID   FieldScalarFieldEnum = "eventID"
	FieldScalarFieldEnumCreatedAt FieldScalarFieldEnum = "createdAt"
	FieldScalarFieldEnumUpdatedAt FieldScalarFieldEnum = "updatedAt"
)

type EventScalarFieldEnum string

const (
	EventScalarFieldEnumID                    EventScalarFieldEnum = "id"
	EventScalarFieldEnumName                  EventScalarFieldEnum = "name"
	EventScalarFieldEnumDescription           EventScalarFieldEnum = "description"
	EventScalarFieldEnumCreatedAt             EventScalarFieldEnum = "createdAt"
	EventScalarFieldEnumUpdatedAt             EventScalarFieldEnum = "updatedAt"
	EventScalarFieldEnumPlaceInterfaceID      EventScalarFieldEnum = "placeInterfaceId"
	EventScalarFieldEnumTransitionInterfaceID EventScalarFieldEnum = "transitionInterfaceId"
)

type InstanceScalarFieldEnum string

const (
	InstanceScalarFieldEnumID        InstanceScalarFieldEnum = "id"
	InstanceScalarFieldEnumCreatedAt InstanceScalarFieldEnum = "createdAt"
	InstanceScalarFieldEnumUpdatedAt InstanceScalarFieldEnum = "updatedAt"
	InstanceScalarFieldEnumAuthorID  InstanceScalarFieldEnum = "authorID"
	InstanceScalarFieldEnumLanguage  InstanceScalarFieldEnum = "language"
	InstanceScalarFieldEnumName      InstanceScalarFieldEnum = "name"
	InstanceScalarFieldEnumDeviceID  InstanceScalarFieldEnum = "deviceId"
	InstanceScalarFieldEnumAddr      InstanceScalarFieldEnum = "addr"
)

type DeviceScalarFieldEnum string

const (
	DeviceScalarFieldEnumID          DeviceScalarFieldEnum = "id"
	DeviceScalarFieldEnumAuthorID    DeviceScalarFieldEnum = "authorID"
	DeviceScalarFieldEnumName        DeviceScalarFieldEnum = "name"
	DeviceScalarFieldEnumDescription DeviceScalarFieldEnum = "description"
	DeviceScalarFieldEnumCreatedAt   DeviceScalarFieldEnum = "createdAt"
	DeviceScalarFieldEnumUpdatedAt   DeviceScalarFieldEnum = "updatedAt"
	DeviceScalarFieldEnumNetIDs      DeviceScalarFieldEnum = "netIDs"
)

type ConstantScalarFieldEnum string

const (
	ConstantScalarFieldEnumID       ConstantScalarFieldEnum = "id"
	ConstantScalarFieldEnumActionID ConstantScalarFieldEnum = "actionID"
	ConstantScalarFieldEnumFieldID  ConstantScalarFieldEnum = "fieldID"
	ConstantScalarFieldEnumValue    ConstantScalarFieldEnum = "value"
)

type ActionScalarFieldEnum string

const (
	ActionScalarFieldEnumID        ActionScalarFieldEnum = "id"
	ActionScalarFieldEnumInput     ActionScalarFieldEnum = "input"
	ActionScalarFieldEnumOutput    ActionScalarFieldEnum = "output"
	ActionScalarFieldEnumDeviceID  ActionScalarFieldEnum = "deviceId"
	ActionScalarFieldEnumEventID   ActionScalarFieldEnum = "eventID"
	ActionScalarFieldEnumCreatedAt ActionScalarFieldEnum = "createdAt"
	ActionScalarFieldEnumUpdatedAt ActionScalarFieldEnum = "updatedAt"
)

type StepScalarFieldEnum string

const (
	StepScalarFieldEnumID       StepScalarFieldEnum = "id"
	StepScalarFieldEnumOrder    StepScalarFieldEnum = "order"
	StepScalarFieldEnumRunID    StepScalarFieldEnum = "runID"
	StepScalarFieldEnumActionID StepScalarFieldEnum = "actionID"
)

type RunScalarFieldEnum string

const (
	RunScalarFieldEnumID          RunScalarFieldEnum = "id"
	RunScalarFieldEnumName        RunScalarFieldEnum = "name"
	RunScalarFieldEnumDescription RunScalarFieldEnum = "description"
	RunScalarFieldEnumCreatedAt   RunScalarFieldEnum = "createdAt"
	RunScalarFieldEnumUpdatedAt   RunScalarFieldEnum = "updatedAt"
	RunScalarFieldEnumNetID       RunScalarFieldEnum = "netID"
)

type DatumScalarFieldEnum string

const (
	DatumScalarFieldEnumID         DatumScalarFieldEnum = "id"
	DatumScalarFieldEnumInstanceID DatumScalarFieldEnum = "instanceID"
	DatumScalarFieldEnumSessionID  DatumScalarFieldEnum = "sessionID"
	DatumScalarFieldEnumValue      DatumScalarFieldEnum = "value"
	DatumScalarFieldEnumCreatedAt  DatumScalarFieldEnum = "createdAt"
	DatumScalarFieldEnumUpdatedAt  DatumScalarFieldEnum = "updatedAt"
	DatumScalarFieldEnumEventID    DatumScalarFieldEnum = "eventId"
)

type SessionScalarFieldEnum string

const (
	SessionScalarFieldEnumID        SessionScalarFieldEnum = "id"
	SessionScalarFieldEnumUserID    SessionScalarFieldEnum = "userID"
	SessionScalarFieldEnumCreatedAt SessionScalarFieldEnum = "createdAt"
	SessionScalarFieldEnumUpdatedAt SessionScalarFieldEnum = "updatedAt"
	SessionScalarFieldEnumStartedAt SessionScalarFieldEnum = "startedAt"
	SessionScalarFieldEnumStoppedAt SessionScalarFieldEnum = "stoppedAt"
	SessionScalarFieldEnumPausedAt  SessionScalarFieldEnum = "pausedAt"
	SessionScalarFieldEnumResumedAt SessionScalarFieldEnum = "resumedAt"
	SessionScalarFieldEnumState     SessionScalarFieldEnum = "state"
	SessionScalarFieldEnumDeleted   SessionScalarFieldEnum = "deleted"
	SessionScalarFieldEnumRunID     SessionScalarFieldEnum = "runID"
)

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

type JSONNullValueInput string

const (
	JSONNullValueInputJSONNull JSONNullValueInput = "JsonNull"
)

type NullableJSONNullValueInput string

const (
	NullableJSONNullValueInputDbNull   NullableJSONNullValueInput = "DbNull"
	NullableJSONNullValueInputJSONNull NullableJSONNullValueInput = "JsonNull"
)

type QueryMode string

const (
	QueryModeDefault     QueryMode = "default"
	QueryModeInsensitive QueryMode = "insensitive"
)

type NullsOrder string

const (
	NullsOrderFirst NullsOrder = "first"
	NullsOrderLast  NullsOrder = "last"
)

type JSONNullValueFilter string

const (
	JSONNullValueFilterDbNull   JSONNullValueFilter = "DbNull"
	JSONNullValueFilterJSONNull JSONNullValueFilter = "JsonNull"
	JSONNullValueFilterAnyNull  JSONNullValueFilter = "AnyNull"
)

// --- template mock.gotpl ---
func NewMock() (*PrismaClient, *Mock, func(t *testing.T)) {
	expectations := new([]mock.Expectation)
	pc := newMockClient(expectations)
	m := &Mock{
		Mock: &mock.Mock{
			Expectations: expectations,
		},
	}

	m.User = userMock{
		mock: m,
	}

	m.Password = passwordMock{
		mock: m,
	}

	m.Net = netMock{
		mock: m,
	}

	m.PlaceInterface = placeInterfaceMock{
		mock: m,
	}

	m.TransitionInterface = transitionInterfaceMock{
		mock: m,
	}

	m.Place = placeMock{
		mock: m,
	}

	m.Transition = transitionMock{
		mock: m,
	}

	m.Arc = arcMock{
		mock: m,
	}

	m.DevicesOnNets = devicesOnNetsMock{
		mock: m,
	}

	m.Field = fieldMock{
		mock: m,
	}

	m.Event = eventMock{
		mock: m,
	}

	m.Instance = instanceMock{
		mock: m,
	}

	m.Device = deviceMock{
		mock: m,
	}

	m.Constant = constantMock{
		mock: m,
	}

	m.Action = actionMock{
		mock: m,
	}

	m.Step = stepMock{
		mock: m,
	}

	m.Run = runMock{
		mock: m,
	}

	m.Datum = datumMock{
		mock: m,
	}

	m.Session = sessionMock{
		mock: m,
	}

	return pc, m, m.Ensure
}

type Mock struct {
	*mock.Mock

	User userMock

	Password passwordMock

	Net netMock

	PlaceInterface placeInterfaceMock

	TransitionInterface transitionInterfaceMock

	Place placeMock

	Transition transitionMock

	Arc arcMock

	DevicesOnNets devicesOnNetsMock

	Field fieldMock

	Event eventMock

	Instance instanceMock

	Device deviceMock

	Constant constantMock

	Action actionMock

	Step stepMock

	Run runMock

	Datum datumMock

	Session sessionMock
}

type userMock struct {
	mock *Mock
}

type UserMockExpectParam interface {
	ExtractQuery() builder.Query
	userModel()
}

func (m *userMock) Expect(query UserMockExpectParam) *userMockExec {
	return &userMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type userMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *userMockExec) Returns(v UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) ReturnsMany(v []UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type passwordMock struct {
	mock *Mock
}

type PasswordMockExpectParam interface {
	ExtractQuery() builder.Query
	passwordModel()
}

func (m *passwordMock) Expect(query PasswordMockExpectParam) *passwordMockExec {
	return &passwordMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type passwordMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *passwordMockExec) Returns(v PasswordModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *passwordMockExec) ReturnsMany(v []PasswordModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *passwordMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type netMock struct {
	mock *Mock
}

type NetMockExpectParam interface {
	ExtractQuery() builder.Query
	netModel()
}

func (m *netMock) Expect(query NetMockExpectParam) *netMockExec {
	return &netMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type netMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *netMockExec) Returns(v NetModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *netMockExec) ReturnsMany(v []NetModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *netMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type placeInterfaceMock struct {
	mock *Mock
}

type PlaceInterfaceMockExpectParam interface {
	ExtractQuery() builder.Query
	placeInterfaceModel()
}

func (m *placeInterfaceMock) Expect(query PlaceInterfaceMockExpectParam) *placeInterfaceMockExec {
	return &placeInterfaceMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type placeInterfaceMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *placeInterfaceMockExec) Returns(v PlaceInterfaceModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *placeInterfaceMockExec) ReturnsMany(v []PlaceInterfaceModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *placeInterfaceMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type transitionInterfaceMock struct {
	mock *Mock
}

type TransitionInterfaceMockExpectParam interface {
	ExtractQuery() builder.Query
	transitionInterfaceModel()
}

func (m *transitionInterfaceMock) Expect(query TransitionInterfaceMockExpectParam) *transitionInterfaceMockExec {
	return &transitionInterfaceMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type transitionInterfaceMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *transitionInterfaceMockExec) Returns(v TransitionInterfaceModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *transitionInterfaceMockExec) ReturnsMany(v []TransitionInterfaceModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *transitionInterfaceMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type placeMock struct {
	mock *Mock
}

type PlaceMockExpectParam interface {
	ExtractQuery() builder.Query
	placeModel()
}

func (m *placeMock) Expect(query PlaceMockExpectParam) *placeMockExec {
	return &placeMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type placeMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *placeMockExec) Returns(v PlaceModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *placeMockExec) ReturnsMany(v []PlaceModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *placeMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type transitionMock struct {
	mock *Mock
}

type TransitionMockExpectParam interface {
	ExtractQuery() builder.Query
	transitionModel()
}

func (m *transitionMock) Expect(query TransitionMockExpectParam) *transitionMockExec {
	return &transitionMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type transitionMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *transitionMockExec) Returns(v TransitionModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *transitionMockExec) ReturnsMany(v []TransitionModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *transitionMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type arcMock struct {
	mock *Mock
}

type ArcMockExpectParam interface {
	ExtractQuery() builder.Query
	arcModel()
}

func (m *arcMock) Expect(query ArcMockExpectParam) *arcMockExec {
	return &arcMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type arcMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *arcMockExec) Returns(v ArcModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *arcMockExec) ReturnsMany(v []ArcModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *arcMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type devicesOnNetsMock struct {
	mock *Mock
}

type DevicesOnNetsMockExpectParam interface {
	ExtractQuery() builder.Query
	devicesOnNetsModel()
}

func (m *devicesOnNetsMock) Expect(query DevicesOnNetsMockExpectParam) *devicesOnNetsMockExec {
	return &devicesOnNetsMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type devicesOnNetsMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *devicesOnNetsMockExec) Returns(v DevicesOnNetsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *devicesOnNetsMockExec) ReturnsMany(v []DevicesOnNetsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *devicesOnNetsMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type fieldMock struct {
	mock *Mock
}

type FieldMockExpectParam interface {
	ExtractQuery() builder.Query
	fieldModel()
}

func (m *fieldMock) Expect(query FieldMockExpectParam) *fieldMockExec {
	return &fieldMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type fieldMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *fieldMockExec) Returns(v FieldModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *fieldMockExec) ReturnsMany(v []FieldModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *fieldMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type eventMock struct {
	mock *Mock
}

type EventMockExpectParam interface {
	ExtractQuery() builder.Query
	eventModel()
}

func (m *eventMock) Expect(query EventMockExpectParam) *eventMockExec {
	return &eventMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type eventMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *eventMockExec) Returns(v EventModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *eventMockExec) ReturnsMany(v []EventModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *eventMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type instanceMock struct {
	mock *Mock
}

type InstanceMockExpectParam interface {
	ExtractQuery() builder.Query
	instanceModel()
}

func (m *instanceMock) Expect(query InstanceMockExpectParam) *instanceMockExec {
	return &instanceMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type instanceMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *instanceMockExec) Returns(v InstanceModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *instanceMockExec) ReturnsMany(v []InstanceModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *instanceMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type deviceMock struct {
	mock *Mock
}

type DeviceMockExpectParam interface {
	ExtractQuery() builder.Query
	deviceModel()
}

func (m *deviceMock) Expect(query DeviceMockExpectParam) *deviceMockExec {
	return &deviceMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type deviceMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *deviceMockExec) Returns(v DeviceModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *deviceMockExec) ReturnsMany(v []DeviceModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *deviceMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type constantMock struct {
	mock *Mock
}

type ConstantMockExpectParam interface {
	ExtractQuery() builder.Query
	constantModel()
}

func (m *constantMock) Expect(query ConstantMockExpectParam) *constantMockExec {
	return &constantMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type constantMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *constantMockExec) Returns(v ConstantModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *constantMockExec) ReturnsMany(v []ConstantModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *constantMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type actionMock struct {
	mock *Mock
}

type ActionMockExpectParam interface {
	ExtractQuery() builder.Query
	actionModel()
}

func (m *actionMock) Expect(query ActionMockExpectParam) *actionMockExec {
	return &actionMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type actionMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *actionMockExec) Returns(v ActionModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *actionMockExec) ReturnsMany(v []ActionModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *actionMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type stepMock struct {
	mock *Mock
}

type StepMockExpectParam interface {
	ExtractQuery() builder.Query
	stepModel()
}

func (m *stepMock) Expect(query StepMockExpectParam) *stepMockExec {
	return &stepMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type stepMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *stepMockExec) Returns(v StepModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *stepMockExec) ReturnsMany(v []StepModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *stepMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type runMock struct {
	mock *Mock
}

type RunMockExpectParam interface {
	ExtractQuery() builder.Query
	runModel()
}

func (m *runMock) Expect(query RunMockExpectParam) *runMockExec {
	return &runMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type runMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *runMockExec) Returns(v RunModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *runMockExec) ReturnsMany(v []RunModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *runMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type datumMock struct {
	mock *Mock
}

type DatumMockExpectParam interface {
	ExtractQuery() builder.Query
	datumModel()
}

func (m *datumMock) Expect(query DatumMockExpectParam) *datumMockExec {
	return &datumMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type datumMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *datumMockExec) Returns(v DatumModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *datumMockExec) ReturnsMany(v []DatumModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *datumMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type sessionMock struct {
	mock *Mock
}

type SessionMockExpectParam interface {
	ExtractQuery() builder.Query
	sessionModel()
}

func (m *sessionMock) Expect(query SessionMockExpectParam) *sessionMockExec {
	return &sessionMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type sessionMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *sessionMockExec) Returns(v SessionModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *sessionMockExec) ReturnsMany(v []SessionModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *sessionMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type userActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var userOutput = []builder.Output{
	{Name: "id"},
	{Name: "email"},
	{Name: "role"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type UserRelationWith interface {
	getQuery() builder.Query
	with()
	userRelation()
}

type UserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p userDefaultParam) field() builder.Field {
	return p.data
}

func (p userDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p userDefaultParam) userModel() {}

type UserOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p userOrderByParam) field() builder.Field {
	return p.data
}

func (p userOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p userOrderByParam) userModel() {}

type UserCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	isCursor()
}

type userCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p userCursorParam) field() builder.Field {
	return p.data
}

func (p userCursorParam) isCursor() {}

func (p userCursorParam) getQuery() builder.Query {
	return p.query
}

func (p userCursorParam) userModel() {}

type UserParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	userModel()
}

type userParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p userParamUnique) userModel() {}

func (userParamUnique) unique() {}

func (p userParamUnique) field() builder.Field {
	return p.data
}

func (p userParamUnique) getQuery() builder.Query {
	return p.query
}

type UserEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
}

type userEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsParam) userModel() {}

func (userEqualsParam) equals() {}

func (p userEqualsParam) field() builder.Field {
	return p.data
}

func (p userEqualsParam) getQuery() builder.Query {
	return p.query
}

type UserEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	userModel()
}

type userEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsUniqueParam) userModel() {}

func (userEqualsUniqueParam) unique() {}
func (userEqualsUniqueParam) equals() {}

func (p userEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type UserSetParam interface {
	field() builder.Field
	settable()
	userModel()
}

type userSetParam struct {
	data builder.Field
}

func (userSetParam) settable() {}

func (p userSetParam) field() builder.Field {
	return p.data
}

func (p userSetParam) userModel() {}

type UserWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	idField()
}

type UserWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	idField()
}

type userWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDSetParam) userModel() {}

func (p userWithPrismaIDSetParam) idField() {}

type UserWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	idField()
}

type userWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDEqualsParam) userModel() {}

func (p userWithPrismaIDEqualsParam) idField() {}

func (userWithPrismaIDSetParam) settable()  {}
func (userWithPrismaIDEqualsParam) equals() {}

type userWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDEqualsUniqueParam) userModel() {}
func (p userWithPrismaIDEqualsUniqueParam) idField()   {}

func (userWithPrismaIDEqualsUniqueParam) unique() {}
func (userWithPrismaIDEqualsUniqueParam) equals() {}

type UserWithPrismaEmailEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	emailField()
}

type UserWithPrismaEmailSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	emailField()
}

type userWithPrismaEmailSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailSetParam) userModel() {}

func (p userWithPrismaEmailSetParam) emailField() {}

type UserWithPrismaEmailWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	emailField()
}

type userWithPrismaEmailEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailEqualsParam) userModel() {}

func (p userWithPrismaEmailEqualsParam) emailField() {}

func (userWithPrismaEmailSetParam) settable()  {}
func (userWithPrismaEmailEqualsParam) equals() {}

type userWithPrismaEmailEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailEqualsUniqueParam) userModel()  {}
func (p userWithPrismaEmailEqualsUniqueParam) emailField() {}

func (userWithPrismaEmailEqualsUniqueParam) unique() {}
func (userWithPrismaEmailEqualsUniqueParam) equals() {}

type UserWithPrismaRoleEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	roleField()
}

type UserWithPrismaRoleSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	roleField()
}

type userWithPrismaRoleSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaRoleSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaRoleSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaRoleSetParam) userModel() {}

func (p userWithPrismaRoleSetParam) roleField() {}

type UserWithPrismaRoleWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	roleField()
}

type userWithPrismaRoleEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaRoleEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaRoleEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaRoleEqualsParam) userModel() {}

func (p userWithPrismaRoleEqualsParam) roleField() {}

func (userWithPrismaRoleSetParam) settable()  {}
func (userWithPrismaRoleEqualsParam) equals() {}

type userWithPrismaRoleEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaRoleEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaRoleEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaRoleEqualsUniqueParam) userModel() {}
func (p userWithPrismaRoleEqualsUniqueParam) roleField() {}

func (userWithPrismaRoleEqualsUniqueParam) unique() {}
func (userWithPrismaRoleEqualsUniqueParam) equals() {}

type UserWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	createdAtField()
}

type UserWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	createdAtField()
}

type userWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtSetParam) userModel() {}

func (p userWithPrismaCreatedAtSetParam) createdAtField() {}

type UserWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	createdAtField()
}

type userWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtEqualsParam) userModel() {}

func (p userWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (userWithPrismaCreatedAtSetParam) settable()  {}
func (userWithPrismaCreatedAtEqualsParam) equals() {}

type userWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) userModel()      {}
func (p userWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (userWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (userWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type UserWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	updatedAtField()
}

type UserWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	updatedAtField()
}

type userWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtSetParam) userModel() {}

func (p userWithPrismaUpdatedAtSetParam) updatedAtField() {}

type UserWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	updatedAtField()
}

type userWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtEqualsParam) userModel() {}

func (p userWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (userWithPrismaUpdatedAtSetParam) settable()  {}
func (userWithPrismaUpdatedAtEqualsParam) equals() {}

type userWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) userModel()      {}
func (p userWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (userWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (userWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type UserWithPrismaPasswordEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	passwordField()
}

type UserWithPrismaPasswordSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	passwordField()
}

type userWithPrismaPasswordSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPasswordSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPasswordSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPasswordSetParam) userModel() {}

func (p userWithPrismaPasswordSetParam) passwordField() {}

type UserWithPrismaPasswordWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	passwordField()
}

type userWithPrismaPasswordEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPasswordEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPasswordEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPasswordEqualsParam) userModel() {}

func (p userWithPrismaPasswordEqualsParam) passwordField() {}

func (userWithPrismaPasswordSetParam) settable()  {}
func (userWithPrismaPasswordEqualsParam) equals() {}

type userWithPrismaPasswordEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPasswordEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPasswordEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPasswordEqualsUniqueParam) userModel()     {}
func (p userWithPrismaPasswordEqualsUniqueParam) passwordField() {}

func (userWithPrismaPasswordEqualsUniqueParam) unique() {}
func (userWithPrismaPasswordEqualsUniqueParam) equals() {}

type UserWithPrismaNetsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	netsField()
}

type UserWithPrismaNetsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	netsField()
}

type userWithPrismaNetsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaNetsSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaNetsSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaNetsSetParam) userModel() {}

func (p userWithPrismaNetsSetParam) netsField() {}

type UserWithPrismaNetsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	netsField()
}

type userWithPrismaNetsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaNetsEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaNetsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaNetsEqualsParam) userModel() {}

func (p userWithPrismaNetsEqualsParam) netsField() {}

func (userWithPrismaNetsSetParam) settable()  {}
func (userWithPrismaNetsEqualsParam) equals() {}

type userWithPrismaNetsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaNetsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaNetsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaNetsEqualsUniqueParam) userModel() {}
func (p userWithPrismaNetsEqualsUniqueParam) netsField() {}

func (userWithPrismaNetsEqualsUniqueParam) unique() {}
func (userWithPrismaNetsEqualsUniqueParam) equals() {}

type UserWithPrismaDevicesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	devicesField()
}

type UserWithPrismaDevicesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	devicesField()
}

type userWithPrismaDevicesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaDevicesSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaDevicesSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaDevicesSetParam) userModel() {}

func (p userWithPrismaDevicesSetParam) devicesField() {}

type UserWithPrismaDevicesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	devicesField()
}

type userWithPrismaDevicesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaDevicesEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaDevicesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaDevicesEqualsParam) userModel() {}

func (p userWithPrismaDevicesEqualsParam) devicesField() {}

func (userWithPrismaDevicesSetParam) settable()  {}
func (userWithPrismaDevicesEqualsParam) equals() {}

type userWithPrismaDevicesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaDevicesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaDevicesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaDevicesEqualsUniqueParam) userModel()    {}
func (p userWithPrismaDevicesEqualsUniqueParam) devicesField() {}

func (userWithPrismaDevicesEqualsUniqueParam) unique() {}
func (userWithPrismaDevicesEqualsUniqueParam) equals() {}

type UserWithPrismaInstancesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	instancesField()
}

type UserWithPrismaInstancesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	instancesField()
}

type userWithPrismaInstancesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaInstancesSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaInstancesSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaInstancesSetParam) userModel() {}

func (p userWithPrismaInstancesSetParam) instancesField() {}

type UserWithPrismaInstancesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	instancesField()
}

type userWithPrismaInstancesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaInstancesEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaInstancesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaInstancesEqualsParam) userModel() {}

func (p userWithPrismaInstancesEqualsParam) instancesField() {}

func (userWithPrismaInstancesSetParam) settable()  {}
func (userWithPrismaInstancesEqualsParam) equals() {}

type userWithPrismaInstancesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaInstancesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaInstancesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaInstancesEqualsUniqueParam) userModel()      {}
func (p userWithPrismaInstancesEqualsUniqueParam) instancesField() {}

func (userWithPrismaInstancesEqualsUniqueParam) unique() {}
func (userWithPrismaInstancesEqualsUniqueParam) equals() {}

type UserWithPrismaSessionsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	sessionsField()
}

type UserWithPrismaSessionsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	sessionsField()
}

type userWithPrismaSessionsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSessionsSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSessionsSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSessionsSetParam) userModel() {}

func (p userWithPrismaSessionsSetParam) sessionsField() {}

type UserWithPrismaSessionsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	sessionsField()
}

type userWithPrismaSessionsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSessionsEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSessionsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSessionsEqualsParam) userModel() {}

func (p userWithPrismaSessionsEqualsParam) sessionsField() {}

func (userWithPrismaSessionsSetParam) settable()  {}
func (userWithPrismaSessionsEqualsParam) equals() {}

type userWithPrismaSessionsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSessionsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSessionsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSessionsEqualsUniqueParam) userModel()     {}
func (p userWithPrismaSessionsEqualsUniqueParam) sessionsField() {}

func (userWithPrismaSessionsEqualsUniqueParam) unique() {}
func (userWithPrismaSessionsEqualsUniqueParam) equals() {}

type passwordActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var passwordOutput = []builder.Output{
	{Name: "hash"},
	{Name: "userId"},
}

type PasswordRelationWith interface {
	getQuery() builder.Query
	with()
	passwordRelation()
}

type PasswordWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	passwordModel()
}

type passwordDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p passwordDefaultParam) field() builder.Field {
	return p.data
}

func (p passwordDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p passwordDefaultParam) passwordModel() {}

type PasswordOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	passwordModel()
}

type passwordOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p passwordOrderByParam) field() builder.Field {
	return p.data
}

func (p passwordOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p passwordOrderByParam) passwordModel() {}

type PasswordCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	passwordModel()
	isCursor()
}

type passwordCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p passwordCursorParam) field() builder.Field {
	return p.data
}

func (p passwordCursorParam) isCursor() {}

func (p passwordCursorParam) getQuery() builder.Query {
	return p.query
}

func (p passwordCursorParam) passwordModel() {}

type PasswordParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	passwordModel()
}

type passwordParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p passwordParamUnique) passwordModel() {}

func (passwordParamUnique) unique() {}

func (p passwordParamUnique) field() builder.Field {
	return p.data
}

func (p passwordParamUnique) getQuery() builder.Query {
	return p.query
}

type PasswordEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	passwordModel()
}

type passwordEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p passwordEqualsParam) passwordModel() {}

func (passwordEqualsParam) equals() {}

func (p passwordEqualsParam) field() builder.Field {
	return p.data
}

func (p passwordEqualsParam) getQuery() builder.Query {
	return p.query
}

type PasswordEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	passwordModel()
}

type passwordEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p passwordEqualsUniqueParam) passwordModel() {}

func (passwordEqualsUniqueParam) unique() {}
func (passwordEqualsUniqueParam) equals() {}

func (p passwordEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p passwordEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type PasswordSetParam interface {
	field() builder.Field
	settable()
	passwordModel()
}

type passwordSetParam struct {
	data builder.Field
}

func (passwordSetParam) settable() {}

func (p passwordSetParam) field() builder.Field {
	return p.data
}

func (p passwordSetParam) passwordModel() {}

type PasswordWithPrismaHashEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	passwordModel()
	hashField()
}

type PasswordWithPrismaHashSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	passwordModel()
	hashField()
}

type passwordWithPrismaHashSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p passwordWithPrismaHashSetParam) field() builder.Field {
	return p.data
}

func (p passwordWithPrismaHashSetParam) getQuery() builder.Query {
	return p.query
}

func (p passwordWithPrismaHashSetParam) passwordModel() {}

func (p passwordWithPrismaHashSetParam) hashField() {}

type PasswordWithPrismaHashWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	passwordModel()
	hashField()
}

type passwordWithPrismaHashEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p passwordWithPrismaHashEqualsParam) field() builder.Field {
	return p.data
}

func (p passwordWithPrismaHashEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p passwordWithPrismaHashEqualsParam) passwordModel() {}

func (p passwordWithPrismaHashEqualsParam) hashField() {}

func (passwordWithPrismaHashSetParam) settable()  {}
func (passwordWithPrismaHashEqualsParam) equals() {}

type passwordWithPrismaHashEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p passwordWithPrismaHashEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p passwordWithPrismaHashEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p passwordWithPrismaHashEqualsUniqueParam) passwordModel() {}
func (p passwordWithPrismaHashEqualsUniqueParam) hashField()     {}

func (passwordWithPrismaHashEqualsUniqueParam) unique() {}
func (passwordWithPrismaHashEqualsUniqueParam) equals() {}

type PasswordWithPrismaUserEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	passwordModel()
	userField()
}

type PasswordWithPrismaUserSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	passwordModel()
	userField()
}

type passwordWithPrismaUserSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p passwordWithPrismaUserSetParam) field() builder.Field {
	return p.data
}

func (p passwordWithPrismaUserSetParam) getQuery() builder.Query {
	return p.query
}

func (p passwordWithPrismaUserSetParam) passwordModel() {}

func (p passwordWithPrismaUserSetParam) userField() {}

type PasswordWithPrismaUserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	passwordModel()
	userField()
}

type passwordWithPrismaUserEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p passwordWithPrismaUserEqualsParam) field() builder.Field {
	return p.data
}

func (p passwordWithPrismaUserEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p passwordWithPrismaUserEqualsParam) passwordModel() {}

func (p passwordWithPrismaUserEqualsParam) userField() {}

func (passwordWithPrismaUserSetParam) settable()  {}
func (passwordWithPrismaUserEqualsParam) equals() {}

type passwordWithPrismaUserEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p passwordWithPrismaUserEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p passwordWithPrismaUserEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p passwordWithPrismaUserEqualsUniqueParam) passwordModel() {}
func (p passwordWithPrismaUserEqualsUniqueParam) userField()     {}

func (passwordWithPrismaUserEqualsUniqueParam) unique() {}
func (passwordWithPrismaUserEqualsUniqueParam) equals() {}

type PasswordWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	passwordModel()
	userIDField()
}

type PasswordWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	passwordModel()
	userIDField()
}

type passwordWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p passwordWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p passwordWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p passwordWithPrismaUserIDSetParam) passwordModel() {}

func (p passwordWithPrismaUserIDSetParam) userIDField() {}

type PasswordWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	passwordModel()
	userIDField()
}

type passwordWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p passwordWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p passwordWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p passwordWithPrismaUserIDEqualsParam) passwordModel() {}

func (p passwordWithPrismaUserIDEqualsParam) userIDField() {}

func (passwordWithPrismaUserIDSetParam) settable()  {}
func (passwordWithPrismaUserIDEqualsParam) equals() {}

type passwordWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p passwordWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p passwordWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p passwordWithPrismaUserIDEqualsUniqueParam) passwordModel() {}
func (p passwordWithPrismaUserIDEqualsUniqueParam) userIDField()   {}

func (passwordWithPrismaUserIDEqualsUniqueParam) unique() {}
func (passwordWithPrismaUserIDEqualsUniqueParam) equals() {}

type netActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var netOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
	{Name: "description"},
	{Name: "initialMarking"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "authorID"},
	{Name: "parentID"},
}

type NetRelationWith interface {
	getQuery() builder.Query
	with()
	netRelation()
}

type NetWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
}

type netDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p netDefaultParam) field() builder.Field {
	return p.data
}

func (p netDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p netDefaultParam) netModel() {}

type NetOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
}

type netOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p netOrderByParam) field() builder.Field {
	return p.data
}

func (p netOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p netOrderByParam) netModel() {}

type NetCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	isCursor()
}

type netCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p netCursorParam) field() builder.Field {
	return p.data
}

func (p netCursorParam) isCursor() {}

func (p netCursorParam) getQuery() builder.Query {
	return p.query
}

func (p netCursorParam) netModel() {}

type NetParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	netModel()
}

type netParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p netParamUnique) netModel() {}

func (netParamUnique) unique() {}

func (p netParamUnique) field() builder.Field {
	return p.data
}

func (p netParamUnique) getQuery() builder.Query {
	return p.query
}

type NetEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
}

type netEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netEqualsParam) netModel() {}

func (netEqualsParam) equals() {}

func (p netEqualsParam) field() builder.Field {
	return p.data
}

func (p netEqualsParam) getQuery() builder.Query {
	return p.query
}

type NetEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	netModel()
}

type netEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netEqualsUniqueParam) netModel() {}

func (netEqualsUniqueParam) unique() {}
func (netEqualsUniqueParam) equals() {}

func (p netEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type NetSetParam interface {
	field() builder.Field
	settable()
	netModel()
}

type netSetParam struct {
	data builder.Field
}

func (netSetParam) settable() {}

func (p netSetParam) field() builder.Field {
	return p.data
}

func (p netSetParam) netModel() {}

type NetWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	idField()
}

type NetWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	idField()
}

type netWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaIDSetParam) netModel() {}

func (p netWithPrismaIDSetParam) idField() {}

type NetWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	idField()
}

type netWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaIDEqualsParam) netModel() {}

func (p netWithPrismaIDEqualsParam) idField() {}

func (netWithPrismaIDSetParam) settable()  {}
func (netWithPrismaIDEqualsParam) equals() {}

type netWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaIDEqualsUniqueParam) netModel() {}
func (p netWithPrismaIDEqualsUniqueParam) idField()  {}

func (netWithPrismaIDEqualsUniqueParam) unique() {}
func (netWithPrismaIDEqualsUniqueParam) equals() {}

type NetWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	nameField()
}

type NetWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	nameField()
}

type netWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaNameSetParam) netModel() {}

func (p netWithPrismaNameSetParam) nameField() {}

type NetWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	nameField()
}

type netWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaNameEqualsParam) netModel() {}

func (p netWithPrismaNameEqualsParam) nameField() {}

func (netWithPrismaNameSetParam) settable()  {}
func (netWithPrismaNameEqualsParam) equals() {}

type netWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaNameEqualsUniqueParam) netModel()  {}
func (p netWithPrismaNameEqualsUniqueParam) nameField() {}

func (netWithPrismaNameEqualsUniqueParam) unique() {}
func (netWithPrismaNameEqualsUniqueParam) equals() {}

type NetWithPrismaDescriptionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	descriptionField()
}

type NetWithPrismaDescriptionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	descriptionField()
}

type netWithPrismaDescriptionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaDescriptionSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaDescriptionSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaDescriptionSetParam) netModel() {}

func (p netWithPrismaDescriptionSetParam) descriptionField() {}

type NetWithPrismaDescriptionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	descriptionField()
}

type netWithPrismaDescriptionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaDescriptionEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaDescriptionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaDescriptionEqualsParam) netModel() {}

func (p netWithPrismaDescriptionEqualsParam) descriptionField() {}

func (netWithPrismaDescriptionSetParam) settable()  {}
func (netWithPrismaDescriptionEqualsParam) equals() {}

type netWithPrismaDescriptionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaDescriptionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaDescriptionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaDescriptionEqualsUniqueParam) netModel()         {}
func (p netWithPrismaDescriptionEqualsUniqueParam) descriptionField() {}

func (netWithPrismaDescriptionEqualsUniqueParam) unique() {}
func (netWithPrismaDescriptionEqualsUniqueParam) equals() {}

type NetWithPrismaInitialMarkingEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	initialMarkingField()
}

type NetWithPrismaInitialMarkingSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	initialMarkingField()
}

type netWithPrismaInitialMarkingSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaInitialMarkingSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaInitialMarkingSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaInitialMarkingSetParam) netModel() {}

func (p netWithPrismaInitialMarkingSetParam) initialMarkingField() {}

type NetWithPrismaInitialMarkingWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	initialMarkingField()
}

type netWithPrismaInitialMarkingEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaInitialMarkingEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaInitialMarkingEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaInitialMarkingEqualsParam) netModel() {}

func (p netWithPrismaInitialMarkingEqualsParam) initialMarkingField() {}

func (netWithPrismaInitialMarkingSetParam) settable()  {}
func (netWithPrismaInitialMarkingEqualsParam) equals() {}

type netWithPrismaInitialMarkingEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaInitialMarkingEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaInitialMarkingEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaInitialMarkingEqualsUniqueParam) netModel()            {}
func (p netWithPrismaInitialMarkingEqualsUniqueParam) initialMarkingField() {}

func (netWithPrismaInitialMarkingEqualsUniqueParam) unique() {}
func (netWithPrismaInitialMarkingEqualsUniqueParam) equals() {}

type NetWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	createdAtField()
}

type NetWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	createdAtField()
}

type netWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaCreatedAtSetParam) netModel() {}

func (p netWithPrismaCreatedAtSetParam) createdAtField() {}

type NetWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	createdAtField()
}

type netWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaCreatedAtEqualsParam) netModel() {}

func (p netWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (netWithPrismaCreatedAtSetParam) settable()  {}
func (netWithPrismaCreatedAtEqualsParam) equals() {}

type netWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaCreatedAtEqualsUniqueParam) netModel()       {}
func (p netWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (netWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (netWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type NetWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	updatedAtField()
}

type NetWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	updatedAtField()
}

type netWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaUpdatedAtSetParam) netModel() {}

func (p netWithPrismaUpdatedAtSetParam) updatedAtField() {}

type NetWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	updatedAtField()
}

type netWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaUpdatedAtEqualsParam) netModel() {}

func (p netWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (netWithPrismaUpdatedAtSetParam) settable()  {}
func (netWithPrismaUpdatedAtEqualsParam) equals() {}

type netWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaUpdatedAtEqualsUniqueParam) netModel()       {}
func (p netWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (netWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (netWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type NetWithPrismaAuthorEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	authorField()
}

type NetWithPrismaAuthorSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	authorField()
}

type netWithPrismaAuthorSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaAuthorSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaAuthorSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaAuthorSetParam) netModel() {}

func (p netWithPrismaAuthorSetParam) authorField() {}

type NetWithPrismaAuthorWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	authorField()
}

type netWithPrismaAuthorEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaAuthorEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaAuthorEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaAuthorEqualsParam) netModel() {}

func (p netWithPrismaAuthorEqualsParam) authorField() {}

func (netWithPrismaAuthorSetParam) settable()  {}
func (netWithPrismaAuthorEqualsParam) equals() {}

type netWithPrismaAuthorEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaAuthorEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaAuthorEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaAuthorEqualsUniqueParam) netModel()    {}
func (p netWithPrismaAuthorEqualsUniqueParam) authorField() {}

func (netWithPrismaAuthorEqualsUniqueParam) unique() {}
func (netWithPrismaAuthorEqualsUniqueParam) equals() {}

type NetWithPrismaAuthorIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	authorIDField()
}

type NetWithPrismaAuthorIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	authorIDField()
}

type netWithPrismaAuthorIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaAuthorIDSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaAuthorIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaAuthorIDSetParam) netModel() {}

func (p netWithPrismaAuthorIDSetParam) authorIDField() {}

type NetWithPrismaAuthorIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	authorIDField()
}

type netWithPrismaAuthorIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaAuthorIDEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaAuthorIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaAuthorIDEqualsParam) netModel() {}

func (p netWithPrismaAuthorIDEqualsParam) authorIDField() {}

func (netWithPrismaAuthorIDSetParam) settable()  {}
func (netWithPrismaAuthorIDEqualsParam) equals() {}

type netWithPrismaAuthorIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaAuthorIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaAuthorIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaAuthorIDEqualsUniqueParam) netModel()      {}
func (p netWithPrismaAuthorIDEqualsUniqueParam) authorIDField() {}

func (netWithPrismaAuthorIDEqualsUniqueParam) unique() {}
func (netWithPrismaAuthorIDEqualsUniqueParam) equals() {}

type NetWithPrismaArcsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	arcsField()
}

type NetWithPrismaArcsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	arcsField()
}

type netWithPrismaArcsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaArcsSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaArcsSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaArcsSetParam) netModel() {}

func (p netWithPrismaArcsSetParam) arcsField() {}

type NetWithPrismaArcsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	arcsField()
}

type netWithPrismaArcsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaArcsEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaArcsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaArcsEqualsParam) netModel() {}

func (p netWithPrismaArcsEqualsParam) arcsField() {}

func (netWithPrismaArcsSetParam) settable()  {}
func (netWithPrismaArcsEqualsParam) equals() {}

type netWithPrismaArcsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaArcsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaArcsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaArcsEqualsUniqueParam) netModel()  {}
func (p netWithPrismaArcsEqualsUniqueParam) arcsField() {}

func (netWithPrismaArcsEqualsUniqueParam) unique() {}
func (netWithPrismaArcsEqualsUniqueParam) equals() {}

type NetWithPrismaPlacesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	placesField()
}

type NetWithPrismaPlacesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	placesField()
}

type netWithPrismaPlacesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaPlacesSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaPlacesSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaPlacesSetParam) netModel() {}

func (p netWithPrismaPlacesSetParam) placesField() {}

type NetWithPrismaPlacesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	placesField()
}

type netWithPrismaPlacesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaPlacesEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaPlacesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaPlacesEqualsParam) netModel() {}

func (p netWithPrismaPlacesEqualsParam) placesField() {}

func (netWithPrismaPlacesSetParam) settable()  {}
func (netWithPrismaPlacesEqualsParam) equals() {}

type netWithPrismaPlacesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaPlacesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaPlacesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaPlacesEqualsUniqueParam) netModel()    {}
func (p netWithPrismaPlacesEqualsUniqueParam) placesField() {}

func (netWithPrismaPlacesEqualsUniqueParam) unique() {}
func (netWithPrismaPlacesEqualsUniqueParam) equals() {}

type NetWithPrismaTransitionsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	transitionsField()
}

type NetWithPrismaTransitionsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	transitionsField()
}

type netWithPrismaTransitionsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaTransitionsSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaTransitionsSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaTransitionsSetParam) netModel() {}

func (p netWithPrismaTransitionsSetParam) transitionsField() {}

type NetWithPrismaTransitionsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	transitionsField()
}

type netWithPrismaTransitionsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaTransitionsEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaTransitionsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaTransitionsEqualsParam) netModel() {}

func (p netWithPrismaTransitionsEqualsParam) transitionsField() {}

func (netWithPrismaTransitionsSetParam) settable()  {}
func (netWithPrismaTransitionsEqualsParam) equals() {}

type netWithPrismaTransitionsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaTransitionsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaTransitionsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaTransitionsEqualsUniqueParam) netModel()         {}
func (p netWithPrismaTransitionsEqualsUniqueParam) transitionsField() {}

func (netWithPrismaTransitionsEqualsUniqueParam) unique() {}
func (netWithPrismaTransitionsEqualsUniqueParam) equals() {}

type NetWithPrismaParentEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	parentField()
}

type NetWithPrismaParentSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	parentField()
}

type netWithPrismaParentSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaParentSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaParentSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaParentSetParam) netModel() {}

func (p netWithPrismaParentSetParam) parentField() {}

type NetWithPrismaParentWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	parentField()
}

type netWithPrismaParentEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaParentEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaParentEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaParentEqualsParam) netModel() {}

func (p netWithPrismaParentEqualsParam) parentField() {}

func (netWithPrismaParentSetParam) settable()  {}
func (netWithPrismaParentEqualsParam) equals() {}

type netWithPrismaParentEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaParentEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaParentEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaParentEqualsUniqueParam) netModel()    {}
func (p netWithPrismaParentEqualsUniqueParam) parentField() {}

func (netWithPrismaParentEqualsUniqueParam) unique() {}
func (netWithPrismaParentEqualsUniqueParam) equals() {}

type NetWithPrismaParentIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	parentIDField()
}

type NetWithPrismaParentIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	parentIDField()
}

type netWithPrismaParentIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaParentIDSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaParentIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaParentIDSetParam) netModel() {}

func (p netWithPrismaParentIDSetParam) parentIDField() {}

type NetWithPrismaParentIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	parentIDField()
}

type netWithPrismaParentIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaParentIDEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaParentIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaParentIDEqualsParam) netModel() {}

func (p netWithPrismaParentIDEqualsParam) parentIDField() {}

func (netWithPrismaParentIDSetParam) settable()  {}
func (netWithPrismaParentIDEqualsParam) equals() {}

type netWithPrismaParentIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaParentIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaParentIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaParentIDEqualsUniqueParam) netModel()      {}
func (p netWithPrismaParentIDEqualsUniqueParam) parentIDField() {}

func (netWithPrismaParentIDEqualsUniqueParam) unique() {}
func (netWithPrismaParentIDEqualsUniqueParam) equals() {}

type NetWithPrismaChildrenEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	childrenField()
}

type NetWithPrismaChildrenSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	childrenField()
}

type netWithPrismaChildrenSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaChildrenSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaChildrenSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaChildrenSetParam) netModel() {}

func (p netWithPrismaChildrenSetParam) childrenField() {}

type NetWithPrismaChildrenWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	childrenField()
}

type netWithPrismaChildrenEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaChildrenEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaChildrenEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaChildrenEqualsParam) netModel() {}

func (p netWithPrismaChildrenEqualsParam) childrenField() {}

func (netWithPrismaChildrenSetParam) settable()  {}
func (netWithPrismaChildrenEqualsParam) equals() {}

type netWithPrismaChildrenEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaChildrenEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaChildrenEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaChildrenEqualsUniqueParam) netModel()      {}
func (p netWithPrismaChildrenEqualsUniqueParam) childrenField() {}

func (netWithPrismaChildrenEqualsUniqueParam) unique() {}
func (netWithPrismaChildrenEqualsUniqueParam) equals() {}

type NetWithPrismaDevicesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	devicesField()
}

type NetWithPrismaDevicesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	devicesField()
}

type netWithPrismaDevicesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaDevicesSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaDevicesSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaDevicesSetParam) netModel() {}

func (p netWithPrismaDevicesSetParam) devicesField() {}

type NetWithPrismaDevicesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	devicesField()
}

type netWithPrismaDevicesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaDevicesEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaDevicesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaDevicesEqualsParam) netModel() {}

func (p netWithPrismaDevicesEqualsParam) devicesField() {}

func (netWithPrismaDevicesSetParam) settable()  {}
func (netWithPrismaDevicesEqualsParam) equals() {}

type netWithPrismaDevicesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaDevicesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaDevicesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaDevicesEqualsUniqueParam) netModel()     {}
func (p netWithPrismaDevicesEqualsUniqueParam) devicesField() {}

func (netWithPrismaDevicesEqualsUniqueParam) unique() {}
func (netWithPrismaDevicesEqualsUniqueParam) equals() {}

type NetWithPrismaPlaceInterfacesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	placeInterfacesField()
}

type NetWithPrismaPlaceInterfacesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	placeInterfacesField()
}

type netWithPrismaPlaceInterfacesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaPlaceInterfacesSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaPlaceInterfacesSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaPlaceInterfacesSetParam) netModel() {}

func (p netWithPrismaPlaceInterfacesSetParam) placeInterfacesField() {}

type NetWithPrismaPlaceInterfacesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	placeInterfacesField()
}

type netWithPrismaPlaceInterfacesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaPlaceInterfacesEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaPlaceInterfacesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaPlaceInterfacesEqualsParam) netModel() {}

func (p netWithPrismaPlaceInterfacesEqualsParam) placeInterfacesField() {}

func (netWithPrismaPlaceInterfacesSetParam) settable()  {}
func (netWithPrismaPlaceInterfacesEqualsParam) equals() {}

type netWithPrismaPlaceInterfacesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaPlaceInterfacesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaPlaceInterfacesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaPlaceInterfacesEqualsUniqueParam) netModel()             {}
func (p netWithPrismaPlaceInterfacesEqualsUniqueParam) placeInterfacesField() {}

func (netWithPrismaPlaceInterfacesEqualsUniqueParam) unique() {}
func (netWithPrismaPlaceInterfacesEqualsUniqueParam) equals() {}

type NetWithPrismaTransitionInterfacesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	transitionInterfacesField()
}

type NetWithPrismaTransitionInterfacesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	transitionInterfacesField()
}

type netWithPrismaTransitionInterfacesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaTransitionInterfacesSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaTransitionInterfacesSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaTransitionInterfacesSetParam) netModel() {}

func (p netWithPrismaTransitionInterfacesSetParam) transitionInterfacesField() {}

type NetWithPrismaTransitionInterfacesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	transitionInterfacesField()
}

type netWithPrismaTransitionInterfacesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaTransitionInterfacesEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaTransitionInterfacesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaTransitionInterfacesEqualsParam) netModel() {}

func (p netWithPrismaTransitionInterfacesEqualsParam) transitionInterfacesField() {}

func (netWithPrismaTransitionInterfacesSetParam) settable()  {}
func (netWithPrismaTransitionInterfacesEqualsParam) equals() {}

type netWithPrismaTransitionInterfacesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaTransitionInterfacesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaTransitionInterfacesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaTransitionInterfacesEqualsUniqueParam) netModel()                  {}
func (p netWithPrismaTransitionInterfacesEqualsUniqueParam) transitionInterfacesField() {}

func (netWithPrismaTransitionInterfacesEqualsUniqueParam) unique() {}
func (netWithPrismaTransitionInterfacesEqualsUniqueParam) equals() {}

type NetWithPrismaRunsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	netModel()
	runsField()
}

type NetWithPrismaRunsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	runsField()
}

type netWithPrismaRunsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaRunsSetParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaRunsSetParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaRunsSetParam) netModel() {}

func (p netWithPrismaRunsSetParam) runsField() {}

type NetWithPrismaRunsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	netModel()
	runsField()
}

type netWithPrismaRunsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaRunsEqualsParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaRunsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaRunsEqualsParam) netModel() {}

func (p netWithPrismaRunsEqualsParam) runsField() {}

func (netWithPrismaRunsSetParam) settable()  {}
func (netWithPrismaRunsEqualsParam) equals() {}

type netWithPrismaRunsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p netWithPrismaRunsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p netWithPrismaRunsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p netWithPrismaRunsEqualsUniqueParam) netModel()  {}
func (p netWithPrismaRunsEqualsUniqueParam) runsField() {}

func (netWithPrismaRunsEqualsUniqueParam) unique() {}
func (netWithPrismaRunsEqualsUniqueParam) equals() {}

type placeInterfaceActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var placeInterfaceOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
	{Name: "bound"},
	{Name: "netID"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type PlaceInterfaceRelationWith interface {
	getQuery() builder.Query
	with()
	placeInterfaceRelation()
}

type PlaceInterfaceWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
}

type placeInterfaceDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceDefaultParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceDefaultParam) placeInterfaceModel() {}

type PlaceInterfaceOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
}

type placeInterfaceOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceOrderByParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceOrderByParam) placeInterfaceModel() {}

type PlaceInterfaceCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	isCursor()
}

type placeInterfaceCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceCursorParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceCursorParam) isCursor() {}

func (p placeInterfaceCursorParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceCursorParam) placeInterfaceModel() {}

type PlaceInterfaceParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	placeInterfaceModel()
}

type placeInterfaceParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceParamUnique) placeInterfaceModel() {}

func (placeInterfaceParamUnique) unique() {}

func (p placeInterfaceParamUnique) field() builder.Field {
	return p.data
}

func (p placeInterfaceParamUnique) getQuery() builder.Query {
	return p.query
}

type PlaceInterfaceEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeInterfaceModel()
}

type placeInterfaceEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceEqualsParam) placeInterfaceModel() {}

func (placeInterfaceEqualsParam) equals() {}

func (p placeInterfaceEqualsParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceEqualsParam) getQuery() builder.Query {
	return p.query
}

type PlaceInterfaceEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	placeInterfaceModel()
}

type placeInterfaceEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceEqualsUniqueParam) placeInterfaceModel() {}

func (placeInterfaceEqualsUniqueParam) unique() {}
func (placeInterfaceEqualsUniqueParam) equals() {}

func (p placeInterfaceEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type PlaceInterfaceSetParam interface {
	field() builder.Field
	settable()
	placeInterfaceModel()
}

type placeInterfaceSetParam struct {
	data builder.Field
}

func (placeInterfaceSetParam) settable() {}

func (p placeInterfaceSetParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceSetParam) placeInterfaceModel() {}

type PlaceInterfaceWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeInterfaceModel()
	idField()
}

type PlaceInterfaceWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	idField()
}

type placeInterfaceWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaIDSetParam) placeInterfaceModel() {}

func (p placeInterfaceWithPrismaIDSetParam) idField() {}

type PlaceInterfaceWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	idField()
}

type placeInterfaceWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaIDEqualsParam) placeInterfaceModel() {}

func (p placeInterfaceWithPrismaIDEqualsParam) idField() {}

func (placeInterfaceWithPrismaIDSetParam) settable()  {}
func (placeInterfaceWithPrismaIDEqualsParam) equals() {}

type placeInterfaceWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaIDEqualsUniqueParam) placeInterfaceModel() {}
func (p placeInterfaceWithPrismaIDEqualsUniqueParam) idField()             {}

func (placeInterfaceWithPrismaIDEqualsUniqueParam) unique() {}
func (placeInterfaceWithPrismaIDEqualsUniqueParam) equals() {}

type PlaceInterfaceWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeInterfaceModel()
	nameField()
}

type PlaceInterfaceWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	nameField()
}

type placeInterfaceWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaNameSetParam) placeInterfaceModel() {}

func (p placeInterfaceWithPrismaNameSetParam) nameField() {}

type PlaceInterfaceWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	nameField()
}

type placeInterfaceWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaNameEqualsParam) placeInterfaceModel() {}

func (p placeInterfaceWithPrismaNameEqualsParam) nameField() {}

func (placeInterfaceWithPrismaNameSetParam) settable()  {}
func (placeInterfaceWithPrismaNameEqualsParam) equals() {}

type placeInterfaceWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaNameEqualsUniqueParam) placeInterfaceModel() {}
func (p placeInterfaceWithPrismaNameEqualsUniqueParam) nameField()           {}

func (placeInterfaceWithPrismaNameEqualsUniqueParam) unique() {}
func (placeInterfaceWithPrismaNameEqualsUniqueParam) equals() {}

type PlaceInterfaceWithPrismaNetEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeInterfaceModel()
	netField()
}

type PlaceInterfaceWithPrismaNetSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	netField()
}

type placeInterfaceWithPrismaNetSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaNetSetParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaNetSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaNetSetParam) placeInterfaceModel() {}

func (p placeInterfaceWithPrismaNetSetParam) netField() {}

type PlaceInterfaceWithPrismaNetWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	netField()
}

type placeInterfaceWithPrismaNetEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaNetEqualsParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaNetEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaNetEqualsParam) placeInterfaceModel() {}

func (p placeInterfaceWithPrismaNetEqualsParam) netField() {}

func (placeInterfaceWithPrismaNetSetParam) settable()  {}
func (placeInterfaceWithPrismaNetEqualsParam) equals() {}

type placeInterfaceWithPrismaNetEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaNetEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaNetEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaNetEqualsUniqueParam) placeInterfaceModel() {}
func (p placeInterfaceWithPrismaNetEqualsUniqueParam) netField()            {}

func (placeInterfaceWithPrismaNetEqualsUniqueParam) unique() {}
func (placeInterfaceWithPrismaNetEqualsUniqueParam) equals() {}

type PlaceInterfaceWithPrismaBoundEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeInterfaceModel()
	boundField()
}

type PlaceInterfaceWithPrismaBoundSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	boundField()
}

type placeInterfaceWithPrismaBoundSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaBoundSetParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaBoundSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaBoundSetParam) placeInterfaceModel() {}

func (p placeInterfaceWithPrismaBoundSetParam) boundField() {}

type PlaceInterfaceWithPrismaBoundWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	boundField()
}

type placeInterfaceWithPrismaBoundEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaBoundEqualsParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaBoundEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaBoundEqualsParam) placeInterfaceModel() {}

func (p placeInterfaceWithPrismaBoundEqualsParam) boundField() {}

func (placeInterfaceWithPrismaBoundSetParam) settable()  {}
func (placeInterfaceWithPrismaBoundEqualsParam) equals() {}

type placeInterfaceWithPrismaBoundEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaBoundEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaBoundEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaBoundEqualsUniqueParam) placeInterfaceModel() {}
func (p placeInterfaceWithPrismaBoundEqualsUniqueParam) boundField()          {}

func (placeInterfaceWithPrismaBoundEqualsUniqueParam) unique() {}
func (placeInterfaceWithPrismaBoundEqualsUniqueParam) equals() {}

type PlaceInterfaceWithPrismaNetIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeInterfaceModel()
	netIDField()
}

type PlaceInterfaceWithPrismaNetIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	netIDField()
}

type placeInterfaceWithPrismaNetIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaNetIDSetParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaNetIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaNetIDSetParam) placeInterfaceModel() {}

func (p placeInterfaceWithPrismaNetIDSetParam) netIDField() {}

type PlaceInterfaceWithPrismaNetIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	netIDField()
}

type placeInterfaceWithPrismaNetIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaNetIDEqualsParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaNetIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaNetIDEqualsParam) placeInterfaceModel() {}

func (p placeInterfaceWithPrismaNetIDEqualsParam) netIDField() {}

func (placeInterfaceWithPrismaNetIDSetParam) settable()  {}
func (placeInterfaceWithPrismaNetIDEqualsParam) equals() {}

type placeInterfaceWithPrismaNetIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaNetIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaNetIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaNetIDEqualsUniqueParam) placeInterfaceModel() {}
func (p placeInterfaceWithPrismaNetIDEqualsUniqueParam) netIDField()          {}

func (placeInterfaceWithPrismaNetIDEqualsUniqueParam) unique() {}
func (placeInterfaceWithPrismaNetIDEqualsUniqueParam) equals() {}

type PlaceInterfaceWithPrismaPlacesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeInterfaceModel()
	placesField()
}

type PlaceInterfaceWithPrismaPlacesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	placesField()
}

type placeInterfaceWithPrismaPlacesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaPlacesSetParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaPlacesSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaPlacesSetParam) placeInterfaceModel() {}

func (p placeInterfaceWithPrismaPlacesSetParam) placesField() {}

type PlaceInterfaceWithPrismaPlacesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	placesField()
}

type placeInterfaceWithPrismaPlacesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaPlacesEqualsParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaPlacesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaPlacesEqualsParam) placeInterfaceModel() {}

func (p placeInterfaceWithPrismaPlacesEqualsParam) placesField() {}

func (placeInterfaceWithPrismaPlacesSetParam) settable()  {}
func (placeInterfaceWithPrismaPlacesEqualsParam) equals() {}

type placeInterfaceWithPrismaPlacesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaPlacesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaPlacesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaPlacesEqualsUniqueParam) placeInterfaceModel() {}
func (p placeInterfaceWithPrismaPlacesEqualsUniqueParam) placesField()         {}

func (placeInterfaceWithPrismaPlacesEqualsUniqueParam) unique() {}
func (placeInterfaceWithPrismaPlacesEqualsUniqueParam) equals() {}

type PlaceInterfaceWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeInterfaceModel()
	createdAtField()
}

type PlaceInterfaceWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	createdAtField()
}

type placeInterfaceWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaCreatedAtSetParam) placeInterfaceModel() {}

func (p placeInterfaceWithPrismaCreatedAtSetParam) createdAtField() {}

type PlaceInterfaceWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	createdAtField()
}

type placeInterfaceWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaCreatedAtEqualsParam) placeInterfaceModel() {}

func (p placeInterfaceWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (placeInterfaceWithPrismaCreatedAtSetParam) settable()  {}
func (placeInterfaceWithPrismaCreatedAtEqualsParam) equals() {}

type placeInterfaceWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaCreatedAtEqualsUniqueParam) placeInterfaceModel() {}
func (p placeInterfaceWithPrismaCreatedAtEqualsUniqueParam) createdAtField()      {}

func (placeInterfaceWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (placeInterfaceWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type PlaceInterfaceWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeInterfaceModel()
	updatedAtField()
}

type PlaceInterfaceWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	updatedAtField()
}

type placeInterfaceWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaUpdatedAtSetParam) placeInterfaceModel() {}

func (p placeInterfaceWithPrismaUpdatedAtSetParam) updatedAtField() {}

type PlaceInterfaceWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeInterfaceModel()
	updatedAtField()
}

type placeInterfaceWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaUpdatedAtEqualsParam) placeInterfaceModel() {}

func (p placeInterfaceWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (placeInterfaceWithPrismaUpdatedAtSetParam) settable()  {}
func (placeInterfaceWithPrismaUpdatedAtEqualsParam) equals() {}

type placeInterfaceWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeInterfaceWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeInterfaceWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeInterfaceWithPrismaUpdatedAtEqualsUniqueParam) placeInterfaceModel() {}
func (p placeInterfaceWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField()      {}

func (placeInterfaceWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (placeInterfaceWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type transitionInterfaceActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var transitionInterfaceOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
	{Name: "netID"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type TransitionInterfaceRelationWith interface {
	getQuery() builder.Query
	with()
	transitionInterfaceRelation()
}

type TransitionInterfaceWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
}

type transitionInterfaceDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceDefaultParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceDefaultParam) transitionInterfaceModel() {}

type TransitionInterfaceOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
}

type transitionInterfaceOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceOrderByParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceOrderByParam) transitionInterfaceModel() {}

type TransitionInterfaceCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	isCursor()
}

type transitionInterfaceCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceCursorParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceCursorParam) isCursor() {}

func (p transitionInterfaceCursorParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceCursorParam) transitionInterfaceModel() {}

type TransitionInterfaceParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	transitionInterfaceModel()
}

type transitionInterfaceParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceParamUnique) transitionInterfaceModel() {}

func (transitionInterfaceParamUnique) unique() {}

func (p transitionInterfaceParamUnique) field() builder.Field {
	return p.data
}

func (p transitionInterfaceParamUnique) getQuery() builder.Query {
	return p.query
}

type TransitionInterfaceEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionInterfaceModel()
}

type transitionInterfaceEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceEqualsParam) transitionInterfaceModel() {}

func (transitionInterfaceEqualsParam) equals() {}

func (p transitionInterfaceEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceEqualsParam) getQuery() builder.Query {
	return p.query
}

type TransitionInterfaceEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	transitionInterfaceModel()
}

type transitionInterfaceEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceEqualsUniqueParam) transitionInterfaceModel() {}

func (transitionInterfaceEqualsUniqueParam) unique() {}
func (transitionInterfaceEqualsUniqueParam) equals() {}

func (p transitionInterfaceEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type TransitionInterfaceSetParam interface {
	field() builder.Field
	settable()
	transitionInterfaceModel()
}

type transitionInterfaceSetParam struct {
	data builder.Field
}

func (transitionInterfaceSetParam) settable() {}

func (p transitionInterfaceSetParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceSetParam) transitionInterfaceModel() {}

type TransitionInterfaceWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionInterfaceModel()
	idField()
}

type TransitionInterfaceWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	idField()
}

type transitionInterfaceWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaIDSetParam) transitionInterfaceModel() {}

func (p transitionInterfaceWithPrismaIDSetParam) idField() {}

type TransitionInterfaceWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	idField()
}

type transitionInterfaceWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaIDEqualsParam) transitionInterfaceModel() {}

func (p transitionInterfaceWithPrismaIDEqualsParam) idField() {}

func (transitionInterfaceWithPrismaIDSetParam) settable()  {}
func (transitionInterfaceWithPrismaIDEqualsParam) equals() {}

type transitionInterfaceWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaIDEqualsUniqueParam) transitionInterfaceModel() {}
func (p transitionInterfaceWithPrismaIDEqualsUniqueParam) idField()                  {}

func (transitionInterfaceWithPrismaIDEqualsUniqueParam) unique() {}
func (transitionInterfaceWithPrismaIDEqualsUniqueParam) equals() {}

type TransitionInterfaceWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionInterfaceModel()
	nameField()
}

type TransitionInterfaceWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	nameField()
}

type transitionInterfaceWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaNameSetParam) transitionInterfaceModel() {}

func (p transitionInterfaceWithPrismaNameSetParam) nameField() {}

type TransitionInterfaceWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	nameField()
}

type transitionInterfaceWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaNameEqualsParam) transitionInterfaceModel() {}

func (p transitionInterfaceWithPrismaNameEqualsParam) nameField() {}

func (transitionInterfaceWithPrismaNameSetParam) settable()  {}
func (transitionInterfaceWithPrismaNameEqualsParam) equals() {}

type transitionInterfaceWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaNameEqualsUniqueParam) transitionInterfaceModel() {}
func (p transitionInterfaceWithPrismaNameEqualsUniqueParam) nameField()                {}

func (transitionInterfaceWithPrismaNameEqualsUniqueParam) unique() {}
func (transitionInterfaceWithPrismaNameEqualsUniqueParam) equals() {}

type TransitionInterfaceWithPrismaNetEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionInterfaceModel()
	netField()
}

type TransitionInterfaceWithPrismaNetSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	netField()
}

type transitionInterfaceWithPrismaNetSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaNetSetParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaNetSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaNetSetParam) transitionInterfaceModel() {}

func (p transitionInterfaceWithPrismaNetSetParam) netField() {}

type TransitionInterfaceWithPrismaNetWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	netField()
}

type transitionInterfaceWithPrismaNetEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaNetEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaNetEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaNetEqualsParam) transitionInterfaceModel() {}

func (p transitionInterfaceWithPrismaNetEqualsParam) netField() {}

func (transitionInterfaceWithPrismaNetSetParam) settable()  {}
func (transitionInterfaceWithPrismaNetEqualsParam) equals() {}

type transitionInterfaceWithPrismaNetEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaNetEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaNetEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaNetEqualsUniqueParam) transitionInterfaceModel() {}
func (p transitionInterfaceWithPrismaNetEqualsUniqueParam) netField()                 {}

func (transitionInterfaceWithPrismaNetEqualsUniqueParam) unique() {}
func (transitionInterfaceWithPrismaNetEqualsUniqueParam) equals() {}

type TransitionInterfaceWithPrismaEventsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionInterfaceModel()
	eventsField()
}

type TransitionInterfaceWithPrismaEventsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	eventsField()
}

type transitionInterfaceWithPrismaEventsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaEventsSetParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaEventsSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaEventsSetParam) transitionInterfaceModel() {}

func (p transitionInterfaceWithPrismaEventsSetParam) eventsField() {}

type TransitionInterfaceWithPrismaEventsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	eventsField()
}

type transitionInterfaceWithPrismaEventsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaEventsEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaEventsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaEventsEqualsParam) transitionInterfaceModel() {}

func (p transitionInterfaceWithPrismaEventsEqualsParam) eventsField() {}

func (transitionInterfaceWithPrismaEventsSetParam) settable()  {}
func (transitionInterfaceWithPrismaEventsEqualsParam) equals() {}

type transitionInterfaceWithPrismaEventsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaEventsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaEventsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaEventsEqualsUniqueParam) transitionInterfaceModel() {}
func (p transitionInterfaceWithPrismaEventsEqualsUniqueParam) eventsField()              {}

func (transitionInterfaceWithPrismaEventsEqualsUniqueParam) unique() {}
func (transitionInterfaceWithPrismaEventsEqualsUniqueParam) equals() {}

type TransitionInterfaceWithPrismaNetIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionInterfaceModel()
	netIDField()
}

type TransitionInterfaceWithPrismaNetIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	netIDField()
}

type transitionInterfaceWithPrismaNetIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaNetIDSetParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaNetIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaNetIDSetParam) transitionInterfaceModel() {}

func (p transitionInterfaceWithPrismaNetIDSetParam) netIDField() {}

type TransitionInterfaceWithPrismaNetIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	netIDField()
}

type transitionInterfaceWithPrismaNetIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaNetIDEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaNetIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaNetIDEqualsParam) transitionInterfaceModel() {}

func (p transitionInterfaceWithPrismaNetIDEqualsParam) netIDField() {}

func (transitionInterfaceWithPrismaNetIDSetParam) settable()  {}
func (transitionInterfaceWithPrismaNetIDEqualsParam) equals() {}

type transitionInterfaceWithPrismaNetIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaNetIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaNetIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaNetIDEqualsUniqueParam) transitionInterfaceModel() {}
func (p transitionInterfaceWithPrismaNetIDEqualsUniqueParam) netIDField()               {}

func (transitionInterfaceWithPrismaNetIDEqualsUniqueParam) unique() {}
func (transitionInterfaceWithPrismaNetIDEqualsUniqueParam) equals() {}

type TransitionInterfaceWithPrismaTransitionsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionInterfaceModel()
	transitionsField()
}

type TransitionInterfaceWithPrismaTransitionsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	transitionsField()
}

type transitionInterfaceWithPrismaTransitionsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaTransitionsSetParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaTransitionsSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaTransitionsSetParam) transitionInterfaceModel() {}

func (p transitionInterfaceWithPrismaTransitionsSetParam) transitionsField() {}

type TransitionInterfaceWithPrismaTransitionsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	transitionsField()
}

type transitionInterfaceWithPrismaTransitionsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaTransitionsEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaTransitionsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaTransitionsEqualsParam) transitionInterfaceModel() {}

func (p transitionInterfaceWithPrismaTransitionsEqualsParam) transitionsField() {}

func (transitionInterfaceWithPrismaTransitionsSetParam) settable()  {}
func (transitionInterfaceWithPrismaTransitionsEqualsParam) equals() {}

type transitionInterfaceWithPrismaTransitionsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaTransitionsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaTransitionsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaTransitionsEqualsUniqueParam) transitionInterfaceModel() {}
func (p transitionInterfaceWithPrismaTransitionsEqualsUniqueParam) transitionsField()         {}

func (transitionInterfaceWithPrismaTransitionsEqualsUniqueParam) unique() {}
func (transitionInterfaceWithPrismaTransitionsEqualsUniqueParam) equals() {}

type TransitionInterfaceWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionInterfaceModel()
	createdAtField()
}

type TransitionInterfaceWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	createdAtField()
}

type transitionInterfaceWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaCreatedAtSetParam) transitionInterfaceModel() {}

func (p transitionInterfaceWithPrismaCreatedAtSetParam) createdAtField() {}

type TransitionInterfaceWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	createdAtField()
}

type transitionInterfaceWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaCreatedAtEqualsParam) transitionInterfaceModel() {}

func (p transitionInterfaceWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (transitionInterfaceWithPrismaCreatedAtSetParam) settable()  {}
func (transitionInterfaceWithPrismaCreatedAtEqualsParam) equals() {}

type transitionInterfaceWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaCreatedAtEqualsUniqueParam) transitionInterfaceModel() {}
func (p transitionInterfaceWithPrismaCreatedAtEqualsUniqueParam) createdAtField()           {}

func (transitionInterfaceWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (transitionInterfaceWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type TransitionInterfaceWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionInterfaceModel()
	updatedAtField()
}

type TransitionInterfaceWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	updatedAtField()
}

type transitionInterfaceWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaUpdatedAtSetParam) transitionInterfaceModel() {}

func (p transitionInterfaceWithPrismaUpdatedAtSetParam) updatedAtField() {}

type TransitionInterfaceWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionInterfaceModel()
	updatedAtField()
}

type transitionInterfaceWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaUpdatedAtEqualsParam) transitionInterfaceModel() {}

func (p transitionInterfaceWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (transitionInterfaceWithPrismaUpdatedAtSetParam) settable()  {}
func (transitionInterfaceWithPrismaUpdatedAtEqualsParam) equals() {}

type transitionInterfaceWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionInterfaceWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionInterfaceWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionInterfaceWithPrismaUpdatedAtEqualsUniqueParam) transitionInterfaceModel() {}
func (p transitionInterfaceWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField()           {}

func (transitionInterfaceWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (transitionInterfaceWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type placeActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var placeOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
	{Name: "description"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "bound"},
}

type PlaceRelationWith interface {
	getQuery() builder.Query
	with()
	placeRelation()
}

type PlaceWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
}

type placeDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeDefaultParam) field() builder.Field {
	return p.data
}

func (p placeDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p placeDefaultParam) placeModel() {}

type PlaceOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
}

type placeOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeOrderByParam) field() builder.Field {
	return p.data
}

func (p placeOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p placeOrderByParam) placeModel() {}

type PlaceCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	isCursor()
}

type placeCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeCursorParam) field() builder.Field {
	return p.data
}

func (p placeCursorParam) isCursor() {}

func (p placeCursorParam) getQuery() builder.Query {
	return p.query
}

func (p placeCursorParam) placeModel() {}

type PlaceParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	placeModel()
}

type placeParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p placeParamUnique) placeModel() {}

func (placeParamUnique) unique() {}

func (p placeParamUnique) field() builder.Field {
	return p.data
}

func (p placeParamUnique) getQuery() builder.Query {
	return p.query
}

type PlaceEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeModel()
}

type placeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeEqualsParam) placeModel() {}

func (placeEqualsParam) equals() {}

func (p placeEqualsParam) field() builder.Field {
	return p.data
}

func (p placeEqualsParam) getQuery() builder.Query {
	return p.query
}

type PlaceEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	placeModel()
}

type placeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeEqualsUniqueParam) placeModel() {}

func (placeEqualsUniqueParam) unique() {}
func (placeEqualsUniqueParam) equals() {}

func (p placeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type PlaceSetParam interface {
	field() builder.Field
	settable()
	placeModel()
}

type placeSetParam struct {
	data builder.Field
}

func (placeSetParam) settable() {}

func (p placeSetParam) field() builder.Field {
	return p.data
}

func (p placeSetParam) placeModel() {}

type PlaceWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeModel()
	idField()
}

type PlaceWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	idField()
}

type placeWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaIDSetParam) placeModel() {}

func (p placeWithPrismaIDSetParam) idField() {}

type PlaceWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	idField()
}

type placeWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaIDEqualsParam) placeModel() {}

func (p placeWithPrismaIDEqualsParam) idField() {}

func (placeWithPrismaIDSetParam) settable()  {}
func (placeWithPrismaIDEqualsParam) equals() {}

type placeWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaIDEqualsUniqueParam) placeModel() {}
func (p placeWithPrismaIDEqualsUniqueParam) idField()    {}

func (placeWithPrismaIDEqualsUniqueParam) unique() {}
func (placeWithPrismaIDEqualsUniqueParam) equals() {}

type PlaceWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeModel()
	nameField()
}

type PlaceWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	nameField()
}

type placeWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaNameSetParam) placeModel() {}

func (p placeWithPrismaNameSetParam) nameField() {}

type PlaceWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	nameField()
}

type placeWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaNameEqualsParam) placeModel() {}

func (p placeWithPrismaNameEqualsParam) nameField() {}

func (placeWithPrismaNameSetParam) settable()  {}
func (placeWithPrismaNameEqualsParam) equals() {}

type placeWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaNameEqualsUniqueParam) placeModel() {}
func (p placeWithPrismaNameEqualsUniqueParam) nameField()  {}

func (placeWithPrismaNameEqualsUniqueParam) unique() {}
func (placeWithPrismaNameEqualsUniqueParam) equals() {}

type PlaceWithPrismaDescriptionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeModel()
	descriptionField()
}

type PlaceWithPrismaDescriptionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	descriptionField()
}

type placeWithPrismaDescriptionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaDescriptionSetParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaDescriptionSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaDescriptionSetParam) placeModel() {}

func (p placeWithPrismaDescriptionSetParam) descriptionField() {}

type PlaceWithPrismaDescriptionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	descriptionField()
}

type placeWithPrismaDescriptionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaDescriptionEqualsParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaDescriptionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaDescriptionEqualsParam) placeModel() {}

func (p placeWithPrismaDescriptionEqualsParam) descriptionField() {}

func (placeWithPrismaDescriptionSetParam) settable()  {}
func (placeWithPrismaDescriptionEqualsParam) equals() {}

type placeWithPrismaDescriptionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaDescriptionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaDescriptionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaDescriptionEqualsUniqueParam) placeModel()       {}
func (p placeWithPrismaDescriptionEqualsUniqueParam) descriptionField() {}

func (placeWithPrismaDescriptionEqualsUniqueParam) unique() {}
func (placeWithPrismaDescriptionEqualsUniqueParam) equals() {}

type PlaceWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeModel()
	createdAtField()
}

type PlaceWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	createdAtField()
}

type placeWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaCreatedAtSetParam) placeModel() {}

func (p placeWithPrismaCreatedAtSetParam) createdAtField() {}

type PlaceWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	createdAtField()
}

type placeWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaCreatedAtEqualsParam) placeModel() {}

func (p placeWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (placeWithPrismaCreatedAtSetParam) settable()  {}
func (placeWithPrismaCreatedAtEqualsParam) equals() {}

type placeWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaCreatedAtEqualsUniqueParam) placeModel()     {}
func (p placeWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (placeWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (placeWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type PlaceWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeModel()
	updatedAtField()
}

type PlaceWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	updatedAtField()
}

type placeWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaUpdatedAtSetParam) placeModel() {}

func (p placeWithPrismaUpdatedAtSetParam) updatedAtField() {}

type PlaceWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	updatedAtField()
}

type placeWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaUpdatedAtEqualsParam) placeModel() {}

func (p placeWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (placeWithPrismaUpdatedAtSetParam) settable()  {}
func (placeWithPrismaUpdatedAtEqualsParam) equals() {}

type placeWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaUpdatedAtEqualsUniqueParam) placeModel()     {}
func (p placeWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (placeWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (placeWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type PlaceWithPrismaArcsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeModel()
	arcsField()
}

type PlaceWithPrismaArcsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	arcsField()
}

type placeWithPrismaArcsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaArcsSetParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaArcsSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaArcsSetParam) placeModel() {}

func (p placeWithPrismaArcsSetParam) arcsField() {}

type PlaceWithPrismaArcsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	arcsField()
}

type placeWithPrismaArcsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaArcsEqualsParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaArcsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaArcsEqualsParam) placeModel() {}

func (p placeWithPrismaArcsEqualsParam) arcsField() {}

func (placeWithPrismaArcsSetParam) settable()  {}
func (placeWithPrismaArcsEqualsParam) equals() {}

type placeWithPrismaArcsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaArcsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaArcsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaArcsEqualsUniqueParam) placeModel() {}
func (p placeWithPrismaArcsEqualsUniqueParam) arcsField()  {}

func (placeWithPrismaArcsEqualsUniqueParam) unique() {}
func (placeWithPrismaArcsEqualsUniqueParam) equals() {}

type PlaceWithPrismaBoundEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeModel()
	boundField()
}

type PlaceWithPrismaBoundSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	boundField()
}

type placeWithPrismaBoundSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaBoundSetParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaBoundSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaBoundSetParam) placeModel() {}

func (p placeWithPrismaBoundSetParam) boundField() {}

type PlaceWithPrismaBoundWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	boundField()
}

type placeWithPrismaBoundEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaBoundEqualsParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaBoundEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaBoundEqualsParam) placeModel() {}

func (p placeWithPrismaBoundEqualsParam) boundField() {}

func (placeWithPrismaBoundSetParam) settable()  {}
func (placeWithPrismaBoundEqualsParam) equals() {}

type placeWithPrismaBoundEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaBoundEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaBoundEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaBoundEqualsUniqueParam) placeModel() {}
func (p placeWithPrismaBoundEqualsUniqueParam) boundField() {}

func (placeWithPrismaBoundEqualsUniqueParam) unique() {}
func (placeWithPrismaBoundEqualsUniqueParam) equals() {}

type PlaceWithPrismaNetsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeModel()
	netsField()
}

type PlaceWithPrismaNetsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	netsField()
}

type placeWithPrismaNetsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaNetsSetParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaNetsSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaNetsSetParam) placeModel() {}

func (p placeWithPrismaNetsSetParam) netsField() {}

type PlaceWithPrismaNetsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	netsField()
}

type placeWithPrismaNetsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaNetsEqualsParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaNetsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaNetsEqualsParam) placeModel() {}

func (p placeWithPrismaNetsEqualsParam) netsField() {}

func (placeWithPrismaNetsSetParam) settable()  {}
func (placeWithPrismaNetsEqualsParam) equals() {}

type placeWithPrismaNetsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaNetsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaNetsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaNetsEqualsUniqueParam) placeModel() {}
func (p placeWithPrismaNetsEqualsUniqueParam) netsField()  {}

func (placeWithPrismaNetsEqualsUniqueParam) unique() {}
func (placeWithPrismaNetsEqualsUniqueParam) equals() {}

type PlaceWithPrismaInterfacesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	placeModel()
	interfacesField()
}

type PlaceWithPrismaInterfacesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	interfacesField()
}

type placeWithPrismaInterfacesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaInterfacesSetParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaInterfacesSetParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaInterfacesSetParam) placeModel() {}

func (p placeWithPrismaInterfacesSetParam) interfacesField() {}

type PlaceWithPrismaInterfacesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	placeModel()
	interfacesField()
}

type placeWithPrismaInterfacesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaInterfacesEqualsParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaInterfacesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaInterfacesEqualsParam) placeModel() {}

func (p placeWithPrismaInterfacesEqualsParam) interfacesField() {}

func (placeWithPrismaInterfacesSetParam) settable()  {}
func (placeWithPrismaInterfacesEqualsParam) equals() {}

type placeWithPrismaInterfacesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p placeWithPrismaInterfacesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p placeWithPrismaInterfacesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p placeWithPrismaInterfacesEqualsUniqueParam) placeModel()      {}
func (p placeWithPrismaInterfacesEqualsUniqueParam) interfacesField() {}

func (placeWithPrismaInterfacesEqualsUniqueParam) unique() {}
func (placeWithPrismaInterfacesEqualsUniqueParam) equals() {}

type transitionActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var transitionOutput = []builder.Output{
	{Name: "id"},
	{Name: "condition"},
	{Name: "description"},
	{Name: "name"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type TransitionRelationWith interface {
	getQuery() builder.Query
	with()
	transitionRelation()
}

type TransitionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
}

type transitionDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionDefaultParam) field() builder.Field {
	return p.data
}

func (p transitionDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p transitionDefaultParam) transitionModel() {}

type TransitionOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
}

type transitionOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionOrderByParam) field() builder.Field {
	return p.data
}

func (p transitionOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p transitionOrderByParam) transitionModel() {}

type TransitionCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	isCursor()
}

type transitionCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionCursorParam) field() builder.Field {
	return p.data
}

func (p transitionCursorParam) isCursor() {}

func (p transitionCursorParam) getQuery() builder.Query {
	return p.query
}

func (p transitionCursorParam) transitionModel() {}

type TransitionParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	transitionModel()
}

type transitionParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p transitionParamUnique) transitionModel() {}

func (transitionParamUnique) unique() {}

func (p transitionParamUnique) field() builder.Field {
	return p.data
}

func (p transitionParamUnique) getQuery() builder.Query {
	return p.query
}

type TransitionEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionModel()
}

type transitionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionEqualsParam) transitionModel() {}

func (transitionEqualsParam) equals() {}

func (p transitionEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionEqualsParam) getQuery() builder.Query {
	return p.query
}

type TransitionEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	transitionModel()
}

type transitionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionEqualsUniqueParam) transitionModel() {}

func (transitionEqualsUniqueParam) unique() {}
func (transitionEqualsUniqueParam) equals() {}

func (p transitionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type TransitionSetParam interface {
	field() builder.Field
	settable()
	transitionModel()
}

type transitionSetParam struct {
	data builder.Field
}

func (transitionSetParam) settable() {}

func (p transitionSetParam) field() builder.Field {
	return p.data
}

func (p transitionSetParam) transitionModel() {}

type TransitionWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionModel()
	idField()
}

type TransitionWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	idField()
}

type transitionWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaIDSetParam) transitionModel() {}

func (p transitionWithPrismaIDSetParam) idField() {}

type TransitionWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	idField()
}

type transitionWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaIDEqualsParam) transitionModel() {}

func (p transitionWithPrismaIDEqualsParam) idField() {}

func (transitionWithPrismaIDSetParam) settable()  {}
func (transitionWithPrismaIDEqualsParam) equals() {}

type transitionWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaIDEqualsUniqueParam) transitionModel() {}
func (p transitionWithPrismaIDEqualsUniqueParam) idField()         {}

func (transitionWithPrismaIDEqualsUniqueParam) unique() {}
func (transitionWithPrismaIDEqualsUniqueParam) equals() {}

type TransitionWithPrismaConditionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionModel()
	conditionField()
}

type TransitionWithPrismaConditionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	conditionField()
}

type transitionWithPrismaConditionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaConditionSetParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaConditionSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaConditionSetParam) transitionModel() {}

func (p transitionWithPrismaConditionSetParam) conditionField() {}

type TransitionWithPrismaConditionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	conditionField()
}

type transitionWithPrismaConditionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaConditionEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaConditionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaConditionEqualsParam) transitionModel() {}

func (p transitionWithPrismaConditionEqualsParam) conditionField() {}

func (transitionWithPrismaConditionSetParam) settable()  {}
func (transitionWithPrismaConditionEqualsParam) equals() {}

type transitionWithPrismaConditionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaConditionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaConditionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaConditionEqualsUniqueParam) transitionModel() {}
func (p transitionWithPrismaConditionEqualsUniqueParam) conditionField()  {}

func (transitionWithPrismaConditionEqualsUniqueParam) unique() {}
func (transitionWithPrismaConditionEqualsUniqueParam) equals() {}

type TransitionWithPrismaDescriptionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionModel()
	descriptionField()
}

type TransitionWithPrismaDescriptionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	descriptionField()
}

type transitionWithPrismaDescriptionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaDescriptionSetParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaDescriptionSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaDescriptionSetParam) transitionModel() {}

func (p transitionWithPrismaDescriptionSetParam) descriptionField() {}

type TransitionWithPrismaDescriptionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	descriptionField()
}

type transitionWithPrismaDescriptionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaDescriptionEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaDescriptionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaDescriptionEqualsParam) transitionModel() {}

func (p transitionWithPrismaDescriptionEqualsParam) descriptionField() {}

func (transitionWithPrismaDescriptionSetParam) settable()  {}
func (transitionWithPrismaDescriptionEqualsParam) equals() {}

type transitionWithPrismaDescriptionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaDescriptionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaDescriptionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaDescriptionEqualsUniqueParam) transitionModel()  {}
func (p transitionWithPrismaDescriptionEqualsUniqueParam) descriptionField() {}

func (transitionWithPrismaDescriptionEqualsUniqueParam) unique() {}
func (transitionWithPrismaDescriptionEqualsUniqueParam) equals() {}

type TransitionWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionModel()
	nameField()
}

type TransitionWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	nameField()
}

type transitionWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaNameSetParam) transitionModel() {}

func (p transitionWithPrismaNameSetParam) nameField() {}

type TransitionWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	nameField()
}

type transitionWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaNameEqualsParam) transitionModel() {}

func (p transitionWithPrismaNameEqualsParam) nameField() {}

func (transitionWithPrismaNameSetParam) settable()  {}
func (transitionWithPrismaNameEqualsParam) equals() {}

type transitionWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaNameEqualsUniqueParam) transitionModel() {}
func (p transitionWithPrismaNameEqualsUniqueParam) nameField()       {}

func (transitionWithPrismaNameEqualsUniqueParam) unique() {}
func (transitionWithPrismaNameEqualsUniqueParam) equals() {}

type TransitionWithPrismaArcsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionModel()
	arcsField()
}

type TransitionWithPrismaArcsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	arcsField()
}

type transitionWithPrismaArcsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaArcsSetParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaArcsSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaArcsSetParam) transitionModel() {}

func (p transitionWithPrismaArcsSetParam) arcsField() {}

type TransitionWithPrismaArcsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	arcsField()
}

type transitionWithPrismaArcsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaArcsEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaArcsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaArcsEqualsParam) transitionModel() {}

func (p transitionWithPrismaArcsEqualsParam) arcsField() {}

func (transitionWithPrismaArcsSetParam) settable()  {}
func (transitionWithPrismaArcsEqualsParam) equals() {}

type transitionWithPrismaArcsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaArcsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaArcsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaArcsEqualsUniqueParam) transitionModel() {}
func (p transitionWithPrismaArcsEqualsUniqueParam) arcsField()       {}

func (transitionWithPrismaArcsEqualsUniqueParam) unique() {}
func (transitionWithPrismaArcsEqualsUniqueParam) equals() {}

type TransitionWithPrismaEventsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionModel()
	eventsField()
}

type TransitionWithPrismaEventsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	eventsField()
}

type transitionWithPrismaEventsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaEventsSetParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaEventsSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaEventsSetParam) transitionModel() {}

func (p transitionWithPrismaEventsSetParam) eventsField() {}

type TransitionWithPrismaEventsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	eventsField()
}

type transitionWithPrismaEventsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaEventsEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaEventsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaEventsEqualsParam) transitionModel() {}

func (p transitionWithPrismaEventsEqualsParam) eventsField() {}

func (transitionWithPrismaEventsSetParam) settable()  {}
func (transitionWithPrismaEventsEqualsParam) equals() {}

type transitionWithPrismaEventsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaEventsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaEventsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaEventsEqualsUniqueParam) transitionModel() {}
func (p transitionWithPrismaEventsEqualsUniqueParam) eventsField()     {}

func (transitionWithPrismaEventsEqualsUniqueParam) unique() {}
func (transitionWithPrismaEventsEqualsUniqueParam) equals() {}

type TransitionWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionModel()
	createdAtField()
}

type TransitionWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	createdAtField()
}

type transitionWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaCreatedAtSetParam) transitionModel() {}

func (p transitionWithPrismaCreatedAtSetParam) createdAtField() {}

type TransitionWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	createdAtField()
}

type transitionWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaCreatedAtEqualsParam) transitionModel() {}

func (p transitionWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (transitionWithPrismaCreatedAtSetParam) settable()  {}
func (transitionWithPrismaCreatedAtEqualsParam) equals() {}

type transitionWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaCreatedAtEqualsUniqueParam) transitionModel() {}
func (p transitionWithPrismaCreatedAtEqualsUniqueParam) createdAtField()  {}

func (transitionWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (transitionWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type TransitionWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionModel()
	updatedAtField()
}

type TransitionWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	updatedAtField()
}

type transitionWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaUpdatedAtSetParam) transitionModel() {}

func (p transitionWithPrismaUpdatedAtSetParam) updatedAtField() {}

type TransitionWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	updatedAtField()
}

type transitionWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaUpdatedAtEqualsParam) transitionModel() {}

func (p transitionWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (transitionWithPrismaUpdatedAtSetParam) settable()  {}
func (transitionWithPrismaUpdatedAtEqualsParam) equals() {}

type transitionWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaUpdatedAtEqualsUniqueParam) transitionModel() {}
func (p transitionWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField()  {}

func (transitionWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (transitionWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type TransitionWithPrismaNetsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionModel()
	netsField()
}

type TransitionWithPrismaNetsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	netsField()
}

type transitionWithPrismaNetsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaNetsSetParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaNetsSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaNetsSetParam) transitionModel() {}

func (p transitionWithPrismaNetsSetParam) netsField() {}

type TransitionWithPrismaNetsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	netsField()
}

type transitionWithPrismaNetsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaNetsEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaNetsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaNetsEqualsParam) transitionModel() {}

func (p transitionWithPrismaNetsEqualsParam) netsField() {}

func (transitionWithPrismaNetsSetParam) settable()  {}
func (transitionWithPrismaNetsEqualsParam) equals() {}

type transitionWithPrismaNetsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaNetsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaNetsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaNetsEqualsUniqueParam) transitionModel() {}
func (p transitionWithPrismaNetsEqualsUniqueParam) netsField()       {}

func (transitionWithPrismaNetsEqualsUniqueParam) unique() {}
func (transitionWithPrismaNetsEqualsUniqueParam) equals() {}

type TransitionWithPrismaInterfacesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transitionModel()
	interfacesField()
}

type TransitionWithPrismaInterfacesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	interfacesField()
}

type transitionWithPrismaInterfacesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaInterfacesSetParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaInterfacesSetParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaInterfacesSetParam) transitionModel() {}

func (p transitionWithPrismaInterfacesSetParam) interfacesField() {}

type TransitionWithPrismaInterfacesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transitionModel()
	interfacesField()
}

type transitionWithPrismaInterfacesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaInterfacesEqualsParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaInterfacesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaInterfacesEqualsParam) transitionModel() {}

func (p transitionWithPrismaInterfacesEqualsParam) interfacesField() {}

func (transitionWithPrismaInterfacesSetParam) settable()  {}
func (transitionWithPrismaInterfacesEqualsParam) equals() {}

type transitionWithPrismaInterfacesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transitionWithPrismaInterfacesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transitionWithPrismaInterfacesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transitionWithPrismaInterfacesEqualsUniqueParam) transitionModel() {}
func (p transitionWithPrismaInterfacesEqualsUniqueParam) interfacesField() {}

func (transitionWithPrismaInterfacesEqualsUniqueParam) unique() {}
func (transitionWithPrismaInterfacesEqualsUniqueParam) equals() {}

type arcActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var arcOutput = []builder.Output{
	{Name: "id"},
	{Name: "netID"},
	{Name: "fromPlace"},
	{Name: "placeID"},
	{Name: "transitionID"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type ArcRelationWith interface {
	getQuery() builder.Query
	with()
	arcRelation()
}

type ArcWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
}

type arcDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcDefaultParam) field() builder.Field {
	return p.data
}

func (p arcDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p arcDefaultParam) arcModel() {}

type ArcOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
}

type arcOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcOrderByParam) field() builder.Field {
	return p.data
}

func (p arcOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p arcOrderByParam) arcModel() {}

type ArcCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	isCursor()
}

type arcCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcCursorParam) field() builder.Field {
	return p.data
}

func (p arcCursorParam) isCursor() {}

func (p arcCursorParam) getQuery() builder.Query {
	return p.query
}

func (p arcCursorParam) arcModel() {}

type ArcParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	arcModel()
}

type arcParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p arcParamUnique) arcModel() {}

func (arcParamUnique) unique() {}

func (p arcParamUnique) field() builder.Field {
	return p.data
}

func (p arcParamUnique) getQuery() builder.Query {
	return p.query
}

type ArcEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	arcModel()
}

type arcEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcEqualsParam) arcModel() {}

func (arcEqualsParam) equals() {}

func (p arcEqualsParam) field() builder.Field {
	return p.data
}

func (p arcEqualsParam) getQuery() builder.Query {
	return p.query
}

type ArcEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	arcModel()
}

type arcEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcEqualsUniqueParam) arcModel() {}

func (arcEqualsUniqueParam) unique() {}
func (arcEqualsUniqueParam) equals() {}

func (p arcEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p arcEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type ArcSetParam interface {
	field() builder.Field
	settable()
	arcModel()
}

type arcSetParam struct {
	data builder.Field
}

func (arcSetParam) settable() {}

func (p arcSetParam) field() builder.Field {
	return p.data
}

func (p arcSetParam) arcModel() {}

type ArcWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	arcModel()
	idField()
}

type ArcWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	idField()
}

type arcWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaIDSetParam) arcModel() {}

func (p arcWithPrismaIDSetParam) idField() {}

type ArcWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	idField()
}

type arcWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaIDEqualsParam) arcModel() {}

func (p arcWithPrismaIDEqualsParam) idField() {}

func (arcWithPrismaIDSetParam) settable()  {}
func (arcWithPrismaIDEqualsParam) equals() {}

type arcWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaIDEqualsUniqueParam) arcModel() {}
func (p arcWithPrismaIDEqualsUniqueParam) idField()  {}

func (arcWithPrismaIDEqualsUniqueParam) unique() {}
func (arcWithPrismaIDEqualsUniqueParam) equals() {}

type ArcWithPrismaNetEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	arcModel()
	netField()
}

type ArcWithPrismaNetSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	netField()
}

type arcWithPrismaNetSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaNetSetParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaNetSetParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaNetSetParam) arcModel() {}

func (p arcWithPrismaNetSetParam) netField() {}

type ArcWithPrismaNetWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	netField()
}

type arcWithPrismaNetEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaNetEqualsParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaNetEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaNetEqualsParam) arcModel() {}

func (p arcWithPrismaNetEqualsParam) netField() {}

func (arcWithPrismaNetSetParam) settable()  {}
func (arcWithPrismaNetEqualsParam) equals() {}

type arcWithPrismaNetEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaNetEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaNetEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaNetEqualsUniqueParam) arcModel() {}
func (p arcWithPrismaNetEqualsUniqueParam) netField() {}

func (arcWithPrismaNetEqualsUniqueParam) unique() {}
func (arcWithPrismaNetEqualsUniqueParam) equals() {}

type ArcWithPrismaNetIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	arcModel()
	netIDField()
}

type ArcWithPrismaNetIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	netIDField()
}

type arcWithPrismaNetIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaNetIDSetParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaNetIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaNetIDSetParam) arcModel() {}

func (p arcWithPrismaNetIDSetParam) netIDField() {}

type ArcWithPrismaNetIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	netIDField()
}

type arcWithPrismaNetIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaNetIDEqualsParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaNetIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaNetIDEqualsParam) arcModel() {}

func (p arcWithPrismaNetIDEqualsParam) netIDField() {}

func (arcWithPrismaNetIDSetParam) settable()  {}
func (arcWithPrismaNetIDEqualsParam) equals() {}

type arcWithPrismaNetIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaNetIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaNetIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaNetIDEqualsUniqueParam) arcModel()   {}
func (p arcWithPrismaNetIDEqualsUniqueParam) netIDField() {}

func (arcWithPrismaNetIDEqualsUniqueParam) unique() {}
func (arcWithPrismaNetIDEqualsUniqueParam) equals() {}

type ArcWithPrismaFromPlaceEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	arcModel()
	fromPlaceField()
}

type ArcWithPrismaFromPlaceSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	fromPlaceField()
}

type arcWithPrismaFromPlaceSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaFromPlaceSetParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaFromPlaceSetParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaFromPlaceSetParam) arcModel() {}

func (p arcWithPrismaFromPlaceSetParam) fromPlaceField() {}

type ArcWithPrismaFromPlaceWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	fromPlaceField()
}

type arcWithPrismaFromPlaceEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaFromPlaceEqualsParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaFromPlaceEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaFromPlaceEqualsParam) arcModel() {}

func (p arcWithPrismaFromPlaceEqualsParam) fromPlaceField() {}

func (arcWithPrismaFromPlaceSetParam) settable()  {}
func (arcWithPrismaFromPlaceEqualsParam) equals() {}

type arcWithPrismaFromPlaceEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaFromPlaceEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaFromPlaceEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaFromPlaceEqualsUniqueParam) arcModel()       {}
func (p arcWithPrismaFromPlaceEqualsUniqueParam) fromPlaceField() {}

func (arcWithPrismaFromPlaceEqualsUniqueParam) unique() {}
func (arcWithPrismaFromPlaceEqualsUniqueParam) equals() {}

type ArcWithPrismaPlaceEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	arcModel()
	placeField()
}

type ArcWithPrismaPlaceSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	placeField()
}

type arcWithPrismaPlaceSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaPlaceSetParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaPlaceSetParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaPlaceSetParam) arcModel() {}

func (p arcWithPrismaPlaceSetParam) placeField() {}

type ArcWithPrismaPlaceWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	placeField()
}

type arcWithPrismaPlaceEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaPlaceEqualsParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaPlaceEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaPlaceEqualsParam) arcModel() {}

func (p arcWithPrismaPlaceEqualsParam) placeField() {}

func (arcWithPrismaPlaceSetParam) settable()  {}
func (arcWithPrismaPlaceEqualsParam) equals() {}

type arcWithPrismaPlaceEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaPlaceEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaPlaceEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaPlaceEqualsUniqueParam) arcModel()   {}
func (p arcWithPrismaPlaceEqualsUniqueParam) placeField() {}

func (arcWithPrismaPlaceEqualsUniqueParam) unique() {}
func (arcWithPrismaPlaceEqualsUniqueParam) equals() {}

type ArcWithPrismaPlaceIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	arcModel()
	placeIDField()
}

type ArcWithPrismaPlaceIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	placeIDField()
}

type arcWithPrismaPlaceIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaPlaceIDSetParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaPlaceIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaPlaceIDSetParam) arcModel() {}

func (p arcWithPrismaPlaceIDSetParam) placeIDField() {}

type ArcWithPrismaPlaceIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	placeIDField()
}

type arcWithPrismaPlaceIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaPlaceIDEqualsParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaPlaceIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaPlaceIDEqualsParam) arcModel() {}

func (p arcWithPrismaPlaceIDEqualsParam) placeIDField() {}

func (arcWithPrismaPlaceIDSetParam) settable()  {}
func (arcWithPrismaPlaceIDEqualsParam) equals() {}

type arcWithPrismaPlaceIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaPlaceIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaPlaceIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaPlaceIDEqualsUniqueParam) arcModel()     {}
func (p arcWithPrismaPlaceIDEqualsUniqueParam) placeIDField() {}

func (arcWithPrismaPlaceIDEqualsUniqueParam) unique() {}
func (arcWithPrismaPlaceIDEqualsUniqueParam) equals() {}

type ArcWithPrismaTransitionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	arcModel()
	transitionField()
}

type ArcWithPrismaTransitionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	transitionField()
}

type arcWithPrismaTransitionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaTransitionSetParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaTransitionSetParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaTransitionSetParam) arcModel() {}

func (p arcWithPrismaTransitionSetParam) transitionField() {}

type ArcWithPrismaTransitionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	transitionField()
}

type arcWithPrismaTransitionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaTransitionEqualsParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaTransitionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaTransitionEqualsParam) arcModel() {}

func (p arcWithPrismaTransitionEqualsParam) transitionField() {}

func (arcWithPrismaTransitionSetParam) settable()  {}
func (arcWithPrismaTransitionEqualsParam) equals() {}

type arcWithPrismaTransitionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaTransitionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaTransitionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaTransitionEqualsUniqueParam) arcModel()        {}
func (p arcWithPrismaTransitionEqualsUniqueParam) transitionField() {}

func (arcWithPrismaTransitionEqualsUniqueParam) unique() {}
func (arcWithPrismaTransitionEqualsUniqueParam) equals() {}

type ArcWithPrismaTransitionIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	arcModel()
	transitionIDField()
}

type ArcWithPrismaTransitionIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	transitionIDField()
}

type arcWithPrismaTransitionIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaTransitionIDSetParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaTransitionIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaTransitionIDSetParam) arcModel() {}

func (p arcWithPrismaTransitionIDSetParam) transitionIDField() {}

type ArcWithPrismaTransitionIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	transitionIDField()
}

type arcWithPrismaTransitionIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaTransitionIDEqualsParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaTransitionIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaTransitionIDEqualsParam) arcModel() {}

func (p arcWithPrismaTransitionIDEqualsParam) transitionIDField() {}

func (arcWithPrismaTransitionIDSetParam) settable()  {}
func (arcWithPrismaTransitionIDEqualsParam) equals() {}

type arcWithPrismaTransitionIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaTransitionIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaTransitionIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaTransitionIDEqualsUniqueParam) arcModel()          {}
func (p arcWithPrismaTransitionIDEqualsUniqueParam) transitionIDField() {}

func (arcWithPrismaTransitionIDEqualsUniqueParam) unique() {}
func (arcWithPrismaTransitionIDEqualsUniqueParam) equals() {}

type ArcWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	arcModel()
	createdAtField()
}

type ArcWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	createdAtField()
}

type arcWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaCreatedAtSetParam) arcModel() {}

func (p arcWithPrismaCreatedAtSetParam) createdAtField() {}

type ArcWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	createdAtField()
}

type arcWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaCreatedAtEqualsParam) arcModel() {}

func (p arcWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (arcWithPrismaCreatedAtSetParam) settable()  {}
func (arcWithPrismaCreatedAtEqualsParam) equals() {}

type arcWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaCreatedAtEqualsUniqueParam) arcModel()       {}
func (p arcWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (arcWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (arcWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type ArcWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	arcModel()
	updatedAtField()
}

type ArcWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	updatedAtField()
}

type arcWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaUpdatedAtSetParam) arcModel() {}

func (p arcWithPrismaUpdatedAtSetParam) updatedAtField() {}

type ArcWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	arcModel()
	updatedAtField()
}

type arcWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaUpdatedAtEqualsParam) arcModel() {}

func (p arcWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (arcWithPrismaUpdatedAtSetParam) settable()  {}
func (arcWithPrismaUpdatedAtEqualsParam) equals() {}

type arcWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p arcWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p arcWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p arcWithPrismaUpdatedAtEqualsUniqueParam) arcModel()       {}
func (p arcWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (arcWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (arcWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type devicesOnNetsActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var devicesOnNetsOutput = []builder.Output{
	{Name: "deviceID"},
	{Name: "netID"},
}

type DevicesOnNetsRelationWith interface {
	getQuery() builder.Query
	with()
	devicesOnNetsRelation()
}

type DevicesOnNetsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesOnNetsModel()
}

type devicesOnNetsDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsDefaultParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsDefaultParam) devicesOnNetsModel() {}

type DevicesOnNetsOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesOnNetsModel()
}

type devicesOnNetsOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsOrderByParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsOrderByParam) devicesOnNetsModel() {}

type DevicesOnNetsCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesOnNetsModel()
	isCursor()
}

type devicesOnNetsCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsCursorParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsCursorParam) isCursor() {}

func (p devicesOnNetsCursorParam) getQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsCursorParam) devicesOnNetsModel() {}

type DevicesOnNetsParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	devicesOnNetsModel()
}

type devicesOnNetsParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsParamUnique) devicesOnNetsModel() {}

func (devicesOnNetsParamUnique) unique() {}

func (p devicesOnNetsParamUnique) field() builder.Field {
	return p.data
}

func (p devicesOnNetsParamUnique) getQuery() builder.Query {
	return p.query
}

type DevicesOnNetsEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	devicesOnNetsModel()
}

type devicesOnNetsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsEqualsParam) devicesOnNetsModel() {}

func (devicesOnNetsEqualsParam) equals() {}

func (p devicesOnNetsEqualsParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsEqualsParam) getQuery() builder.Query {
	return p.query
}

type DevicesOnNetsEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	devicesOnNetsModel()
}

type devicesOnNetsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsEqualsUniqueParam) devicesOnNetsModel() {}

func (devicesOnNetsEqualsUniqueParam) unique() {}
func (devicesOnNetsEqualsUniqueParam) equals() {}

func (p devicesOnNetsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type DevicesOnNetsSetParam interface {
	field() builder.Field
	settable()
	devicesOnNetsModel()
}

type devicesOnNetsSetParam struct {
	data builder.Field
}

func (devicesOnNetsSetParam) settable() {}

func (p devicesOnNetsSetParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsSetParam) devicesOnNetsModel() {}

type DevicesOnNetsWithPrismaDeviceEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	devicesOnNetsModel()
	deviceField()
}

type DevicesOnNetsWithPrismaDeviceSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesOnNetsModel()
	deviceField()
}

type devicesOnNetsWithPrismaDeviceSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsWithPrismaDeviceSetParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsWithPrismaDeviceSetParam) getQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsWithPrismaDeviceSetParam) devicesOnNetsModel() {}

func (p devicesOnNetsWithPrismaDeviceSetParam) deviceField() {}

type DevicesOnNetsWithPrismaDeviceWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesOnNetsModel()
	deviceField()
}

type devicesOnNetsWithPrismaDeviceEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsWithPrismaDeviceEqualsParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsWithPrismaDeviceEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsWithPrismaDeviceEqualsParam) devicesOnNetsModel() {}

func (p devicesOnNetsWithPrismaDeviceEqualsParam) deviceField() {}

func (devicesOnNetsWithPrismaDeviceSetParam) settable()  {}
func (devicesOnNetsWithPrismaDeviceEqualsParam) equals() {}

type devicesOnNetsWithPrismaDeviceEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsWithPrismaDeviceEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsWithPrismaDeviceEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsWithPrismaDeviceEqualsUniqueParam) devicesOnNetsModel() {}
func (p devicesOnNetsWithPrismaDeviceEqualsUniqueParam) deviceField()        {}

func (devicesOnNetsWithPrismaDeviceEqualsUniqueParam) unique() {}
func (devicesOnNetsWithPrismaDeviceEqualsUniqueParam) equals() {}

type DevicesOnNetsWithPrismaDeviceIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	devicesOnNetsModel()
	deviceIDField()
}

type DevicesOnNetsWithPrismaDeviceIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesOnNetsModel()
	deviceIDField()
}

type devicesOnNetsWithPrismaDeviceIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsWithPrismaDeviceIDSetParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsWithPrismaDeviceIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsWithPrismaDeviceIDSetParam) devicesOnNetsModel() {}

func (p devicesOnNetsWithPrismaDeviceIDSetParam) deviceIDField() {}

type DevicesOnNetsWithPrismaDeviceIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesOnNetsModel()
	deviceIDField()
}

type devicesOnNetsWithPrismaDeviceIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsWithPrismaDeviceIDEqualsParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsWithPrismaDeviceIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsWithPrismaDeviceIDEqualsParam) devicesOnNetsModel() {}

func (p devicesOnNetsWithPrismaDeviceIDEqualsParam) deviceIDField() {}

func (devicesOnNetsWithPrismaDeviceIDSetParam) settable()  {}
func (devicesOnNetsWithPrismaDeviceIDEqualsParam) equals() {}

type devicesOnNetsWithPrismaDeviceIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsWithPrismaDeviceIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsWithPrismaDeviceIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsWithPrismaDeviceIDEqualsUniqueParam) devicesOnNetsModel() {}
func (p devicesOnNetsWithPrismaDeviceIDEqualsUniqueParam) deviceIDField()      {}

func (devicesOnNetsWithPrismaDeviceIDEqualsUniqueParam) unique() {}
func (devicesOnNetsWithPrismaDeviceIDEqualsUniqueParam) equals() {}

type DevicesOnNetsWithPrismaNetEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	devicesOnNetsModel()
	netField()
}

type DevicesOnNetsWithPrismaNetSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesOnNetsModel()
	netField()
}

type devicesOnNetsWithPrismaNetSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsWithPrismaNetSetParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsWithPrismaNetSetParam) getQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsWithPrismaNetSetParam) devicesOnNetsModel() {}

func (p devicesOnNetsWithPrismaNetSetParam) netField() {}

type DevicesOnNetsWithPrismaNetWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesOnNetsModel()
	netField()
}

type devicesOnNetsWithPrismaNetEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsWithPrismaNetEqualsParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsWithPrismaNetEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsWithPrismaNetEqualsParam) devicesOnNetsModel() {}

func (p devicesOnNetsWithPrismaNetEqualsParam) netField() {}

func (devicesOnNetsWithPrismaNetSetParam) settable()  {}
func (devicesOnNetsWithPrismaNetEqualsParam) equals() {}

type devicesOnNetsWithPrismaNetEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsWithPrismaNetEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsWithPrismaNetEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsWithPrismaNetEqualsUniqueParam) devicesOnNetsModel() {}
func (p devicesOnNetsWithPrismaNetEqualsUniqueParam) netField()           {}

func (devicesOnNetsWithPrismaNetEqualsUniqueParam) unique() {}
func (devicesOnNetsWithPrismaNetEqualsUniqueParam) equals() {}

type DevicesOnNetsWithPrismaNetIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	devicesOnNetsModel()
	netIDField()
}

type DevicesOnNetsWithPrismaNetIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesOnNetsModel()
	netIDField()
}

type devicesOnNetsWithPrismaNetIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsWithPrismaNetIDSetParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsWithPrismaNetIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsWithPrismaNetIDSetParam) devicesOnNetsModel() {}

func (p devicesOnNetsWithPrismaNetIDSetParam) netIDField() {}

type DevicesOnNetsWithPrismaNetIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesOnNetsModel()
	netIDField()
}

type devicesOnNetsWithPrismaNetIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsWithPrismaNetIDEqualsParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsWithPrismaNetIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsWithPrismaNetIDEqualsParam) devicesOnNetsModel() {}

func (p devicesOnNetsWithPrismaNetIDEqualsParam) netIDField() {}

func (devicesOnNetsWithPrismaNetIDSetParam) settable()  {}
func (devicesOnNetsWithPrismaNetIDEqualsParam) equals() {}

type devicesOnNetsWithPrismaNetIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOnNetsWithPrismaNetIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p devicesOnNetsWithPrismaNetIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p devicesOnNetsWithPrismaNetIDEqualsUniqueParam) devicesOnNetsModel() {}
func (p devicesOnNetsWithPrismaNetIDEqualsUniqueParam) netIDField()         {}

func (devicesOnNetsWithPrismaNetIDEqualsUniqueParam) unique() {}
func (devicesOnNetsWithPrismaNetIDEqualsUniqueParam) equals() {}

type fieldActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var fieldOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
	{Name: "type"},
	{Name: "condition"},
	{Name: "eventID"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type FieldRelationWith interface {
	getQuery() builder.Query
	with()
	fieldRelation()
}

type FieldWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
}

type fieldDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldDefaultParam) field() builder.Field {
	return p.data
}

func (p fieldDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p fieldDefaultParam) fieldModel() {}

type FieldOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
}

type fieldOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldOrderByParam) field() builder.Field {
	return p.data
}

func (p fieldOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p fieldOrderByParam) fieldModel() {}

type FieldCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	isCursor()
}

type fieldCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldCursorParam) field() builder.Field {
	return p.data
}

func (p fieldCursorParam) isCursor() {}

func (p fieldCursorParam) getQuery() builder.Query {
	return p.query
}

func (p fieldCursorParam) fieldModel() {}

type FieldParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	fieldModel()
}

type fieldParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p fieldParamUnique) fieldModel() {}

func (fieldParamUnique) unique() {}

func (p fieldParamUnique) field() builder.Field {
	return p.data
}

func (p fieldParamUnique) getQuery() builder.Query {
	return p.query
}

type FieldEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fieldModel()
}

type fieldEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldEqualsParam) fieldModel() {}

func (fieldEqualsParam) equals() {}

func (p fieldEqualsParam) field() builder.Field {
	return p.data
}

func (p fieldEqualsParam) getQuery() builder.Query {
	return p.query
}

type FieldEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	fieldModel()
}

type fieldEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldEqualsUniqueParam) fieldModel() {}

func (fieldEqualsUniqueParam) unique() {}
func (fieldEqualsUniqueParam) equals() {}

func (p fieldEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fieldEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type FieldSetParam interface {
	field() builder.Field
	settable()
	fieldModel()
}

type fieldSetParam struct {
	data builder.Field
}

func (fieldSetParam) settable() {}

func (p fieldSetParam) field() builder.Field {
	return p.data
}

func (p fieldSetParam) fieldModel() {}

type FieldWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fieldModel()
	idField()
}

type FieldWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	idField()
}

type fieldWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaIDSetParam) fieldModel() {}

func (p fieldWithPrismaIDSetParam) idField() {}

type FieldWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	idField()
}

type fieldWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaIDEqualsParam) fieldModel() {}

func (p fieldWithPrismaIDEqualsParam) idField() {}

func (fieldWithPrismaIDSetParam) settable()  {}
func (fieldWithPrismaIDEqualsParam) equals() {}

type fieldWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaIDEqualsUniqueParam) fieldModel() {}
func (p fieldWithPrismaIDEqualsUniqueParam) idField()    {}

func (fieldWithPrismaIDEqualsUniqueParam) unique() {}
func (fieldWithPrismaIDEqualsUniqueParam) equals() {}

type FieldWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fieldModel()
	nameField()
}

type FieldWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	nameField()
}

type fieldWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaNameSetParam) fieldModel() {}

func (p fieldWithPrismaNameSetParam) nameField() {}

type FieldWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	nameField()
}

type fieldWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaNameEqualsParam) fieldModel() {}

func (p fieldWithPrismaNameEqualsParam) nameField() {}

func (fieldWithPrismaNameSetParam) settable()  {}
func (fieldWithPrismaNameEqualsParam) equals() {}

type fieldWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaNameEqualsUniqueParam) fieldModel() {}
func (p fieldWithPrismaNameEqualsUniqueParam) nameField()  {}

func (fieldWithPrismaNameEqualsUniqueParam) unique() {}
func (fieldWithPrismaNameEqualsUniqueParam) equals() {}

type FieldWithPrismaTypeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fieldModel()
	typeField()
}

type FieldWithPrismaTypeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	typeField()
}

type fieldWithPrismaTypeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaTypeSetParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaTypeSetParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaTypeSetParam) fieldModel() {}

func (p fieldWithPrismaTypeSetParam) typeField() {}

type FieldWithPrismaTypeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	typeField()
}

type fieldWithPrismaTypeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaTypeEqualsParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaTypeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaTypeEqualsParam) fieldModel() {}

func (p fieldWithPrismaTypeEqualsParam) typeField() {}

func (fieldWithPrismaTypeSetParam) settable()  {}
func (fieldWithPrismaTypeEqualsParam) equals() {}

type fieldWithPrismaTypeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaTypeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaTypeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaTypeEqualsUniqueParam) fieldModel() {}
func (p fieldWithPrismaTypeEqualsUniqueParam) typeField()  {}

func (fieldWithPrismaTypeEqualsUniqueParam) unique() {}
func (fieldWithPrismaTypeEqualsUniqueParam) equals() {}

type FieldWithPrismaConditionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fieldModel()
	conditionField()
}

type FieldWithPrismaConditionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	conditionField()
}

type fieldWithPrismaConditionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaConditionSetParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaConditionSetParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaConditionSetParam) fieldModel() {}

func (p fieldWithPrismaConditionSetParam) conditionField() {}

type FieldWithPrismaConditionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	conditionField()
}

type fieldWithPrismaConditionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaConditionEqualsParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaConditionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaConditionEqualsParam) fieldModel() {}

func (p fieldWithPrismaConditionEqualsParam) conditionField() {}

func (fieldWithPrismaConditionSetParam) settable()  {}
func (fieldWithPrismaConditionEqualsParam) equals() {}

type fieldWithPrismaConditionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaConditionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaConditionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaConditionEqualsUniqueParam) fieldModel()     {}
func (p fieldWithPrismaConditionEqualsUniqueParam) conditionField() {}

func (fieldWithPrismaConditionEqualsUniqueParam) unique() {}
func (fieldWithPrismaConditionEqualsUniqueParam) equals() {}

type FieldWithPrismaEventEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fieldModel()
	eventField()
}

type FieldWithPrismaEventSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	eventField()
}

type fieldWithPrismaEventSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaEventSetParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaEventSetParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaEventSetParam) fieldModel() {}

func (p fieldWithPrismaEventSetParam) eventField() {}

type FieldWithPrismaEventWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	eventField()
}

type fieldWithPrismaEventEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaEventEqualsParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaEventEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaEventEqualsParam) fieldModel() {}

func (p fieldWithPrismaEventEqualsParam) eventField() {}

func (fieldWithPrismaEventSetParam) settable()  {}
func (fieldWithPrismaEventEqualsParam) equals() {}

type fieldWithPrismaEventEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaEventEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaEventEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaEventEqualsUniqueParam) fieldModel() {}
func (p fieldWithPrismaEventEqualsUniqueParam) eventField() {}

func (fieldWithPrismaEventEqualsUniqueParam) unique() {}
func (fieldWithPrismaEventEqualsUniqueParam) equals() {}

type FieldWithPrismaEventIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fieldModel()
	eventIDField()
}

type FieldWithPrismaEventIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	eventIDField()
}

type fieldWithPrismaEventIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaEventIDSetParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaEventIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaEventIDSetParam) fieldModel() {}

func (p fieldWithPrismaEventIDSetParam) eventIDField() {}

type FieldWithPrismaEventIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	eventIDField()
}

type fieldWithPrismaEventIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaEventIDEqualsParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaEventIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaEventIDEqualsParam) fieldModel() {}

func (p fieldWithPrismaEventIDEqualsParam) eventIDField() {}

func (fieldWithPrismaEventIDSetParam) settable()  {}
func (fieldWithPrismaEventIDEqualsParam) equals() {}

type fieldWithPrismaEventIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaEventIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaEventIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaEventIDEqualsUniqueParam) fieldModel()   {}
func (p fieldWithPrismaEventIDEqualsUniqueParam) eventIDField() {}

func (fieldWithPrismaEventIDEqualsUniqueParam) unique() {}
func (fieldWithPrismaEventIDEqualsUniqueParam) equals() {}

type FieldWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fieldModel()
	createdAtField()
}

type FieldWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	createdAtField()
}

type fieldWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaCreatedAtSetParam) fieldModel() {}

func (p fieldWithPrismaCreatedAtSetParam) createdAtField() {}

type FieldWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	createdAtField()
}

type fieldWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaCreatedAtEqualsParam) fieldModel() {}

func (p fieldWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (fieldWithPrismaCreatedAtSetParam) settable()  {}
func (fieldWithPrismaCreatedAtEqualsParam) equals() {}

type fieldWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaCreatedAtEqualsUniqueParam) fieldModel()     {}
func (p fieldWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (fieldWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (fieldWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type FieldWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fieldModel()
	updatedAtField()
}

type FieldWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	updatedAtField()
}

type fieldWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaUpdatedAtSetParam) fieldModel() {}

func (p fieldWithPrismaUpdatedAtSetParam) updatedAtField() {}

type FieldWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	updatedAtField()
}

type fieldWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaUpdatedAtEqualsParam) fieldModel() {}

func (p fieldWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (fieldWithPrismaUpdatedAtSetParam) settable()  {}
func (fieldWithPrismaUpdatedAtEqualsParam) equals() {}

type fieldWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaUpdatedAtEqualsUniqueParam) fieldModel()     {}
func (p fieldWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (fieldWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (fieldWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type FieldWithPrismaConstantsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fieldModel()
	constantsField()
}

type FieldWithPrismaConstantsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	constantsField()
}

type fieldWithPrismaConstantsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaConstantsSetParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaConstantsSetParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaConstantsSetParam) fieldModel() {}

func (p fieldWithPrismaConstantsSetParam) constantsField() {}

type FieldWithPrismaConstantsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fieldModel()
	constantsField()
}

type fieldWithPrismaConstantsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaConstantsEqualsParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaConstantsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaConstantsEqualsParam) fieldModel() {}

func (p fieldWithPrismaConstantsEqualsParam) constantsField() {}

func (fieldWithPrismaConstantsSetParam) settable()  {}
func (fieldWithPrismaConstantsEqualsParam) equals() {}

type fieldWithPrismaConstantsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fieldWithPrismaConstantsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fieldWithPrismaConstantsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fieldWithPrismaConstantsEqualsUniqueParam) fieldModel()     {}
func (p fieldWithPrismaConstantsEqualsUniqueParam) constantsField() {}

func (fieldWithPrismaConstantsEqualsUniqueParam) unique() {}
func (fieldWithPrismaConstantsEqualsUniqueParam) equals() {}

type eventActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var eventOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
	{Name: "description"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "placeInterfaceId"},
	{Name: "transitionInterfaceId"},
}

type EventRelationWith interface {
	getQuery() builder.Query
	with()
	eventRelation()
}

type EventWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
}

type eventDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventDefaultParam) field() builder.Field {
	return p.data
}

func (p eventDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p eventDefaultParam) eventModel() {}

type EventOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
}

type eventOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventOrderByParam) field() builder.Field {
	return p.data
}

func (p eventOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p eventOrderByParam) eventModel() {}

type EventCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	isCursor()
}

type eventCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventCursorParam) field() builder.Field {
	return p.data
}

func (p eventCursorParam) isCursor() {}

func (p eventCursorParam) getQuery() builder.Query {
	return p.query
}

func (p eventCursorParam) eventModel() {}

type EventParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	eventModel()
}

type eventParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p eventParamUnique) eventModel() {}

func (eventParamUnique) unique() {}

func (p eventParamUnique) field() builder.Field {
	return p.data
}

func (p eventParamUnique) getQuery() builder.Query {
	return p.query
}

type EventEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	eventModel()
}

type eventEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventEqualsParam) eventModel() {}

func (eventEqualsParam) equals() {}

func (p eventEqualsParam) field() builder.Field {
	return p.data
}

func (p eventEqualsParam) getQuery() builder.Query {
	return p.query
}

type EventEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	eventModel()
}

type eventEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventEqualsUniqueParam) eventModel() {}

func (eventEqualsUniqueParam) unique() {}
func (eventEqualsUniqueParam) equals() {}

func (p eventEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p eventEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type EventSetParam interface {
	field() builder.Field
	settable()
	eventModel()
}

type eventSetParam struct {
	data builder.Field
}

func (eventSetParam) settable() {}

func (p eventSetParam) field() builder.Field {
	return p.data
}

func (p eventSetParam) eventModel() {}

type EventWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	eventModel()
	idField()
}

type EventWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	idField()
}

type eventWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaIDSetParam) eventModel() {}

func (p eventWithPrismaIDSetParam) idField() {}

type EventWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	idField()
}

type eventWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaIDEqualsParam) eventModel() {}

func (p eventWithPrismaIDEqualsParam) idField() {}

func (eventWithPrismaIDSetParam) settable()  {}
func (eventWithPrismaIDEqualsParam) equals() {}

type eventWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaIDEqualsUniqueParam) eventModel() {}
func (p eventWithPrismaIDEqualsUniqueParam) idField()    {}

func (eventWithPrismaIDEqualsUniqueParam) unique() {}
func (eventWithPrismaIDEqualsUniqueParam) equals() {}

type EventWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	eventModel()
	nameField()
}

type EventWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	nameField()
}

type eventWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaNameSetParam) eventModel() {}

func (p eventWithPrismaNameSetParam) nameField() {}

type EventWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	nameField()
}

type eventWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaNameEqualsParam) eventModel() {}

func (p eventWithPrismaNameEqualsParam) nameField() {}

func (eventWithPrismaNameSetParam) settable()  {}
func (eventWithPrismaNameEqualsParam) equals() {}

type eventWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaNameEqualsUniqueParam) eventModel() {}
func (p eventWithPrismaNameEqualsUniqueParam) nameField()  {}

func (eventWithPrismaNameEqualsUniqueParam) unique() {}
func (eventWithPrismaNameEqualsUniqueParam) equals() {}

type EventWithPrismaDescriptionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	eventModel()
	descriptionField()
}

type EventWithPrismaDescriptionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	descriptionField()
}

type eventWithPrismaDescriptionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaDescriptionSetParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaDescriptionSetParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaDescriptionSetParam) eventModel() {}

func (p eventWithPrismaDescriptionSetParam) descriptionField() {}

type EventWithPrismaDescriptionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	descriptionField()
}

type eventWithPrismaDescriptionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaDescriptionEqualsParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaDescriptionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaDescriptionEqualsParam) eventModel() {}

func (p eventWithPrismaDescriptionEqualsParam) descriptionField() {}

func (eventWithPrismaDescriptionSetParam) settable()  {}
func (eventWithPrismaDescriptionEqualsParam) equals() {}

type eventWithPrismaDescriptionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaDescriptionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaDescriptionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaDescriptionEqualsUniqueParam) eventModel()       {}
func (p eventWithPrismaDescriptionEqualsUniqueParam) descriptionField() {}

func (eventWithPrismaDescriptionEqualsUniqueParam) unique() {}
func (eventWithPrismaDescriptionEqualsUniqueParam) equals() {}

type EventWithPrismaTransitionsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	eventModel()
	transitionsField()
}

type EventWithPrismaTransitionsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	transitionsField()
}

type eventWithPrismaTransitionsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaTransitionsSetParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaTransitionsSetParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaTransitionsSetParam) eventModel() {}

func (p eventWithPrismaTransitionsSetParam) transitionsField() {}

type EventWithPrismaTransitionsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	transitionsField()
}

type eventWithPrismaTransitionsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaTransitionsEqualsParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaTransitionsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaTransitionsEqualsParam) eventModel() {}

func (p eventWithPrismaTransitionsEqualsParam) transitionsField() {}

func (eventWithPrismaTransitionsSetParam) settable()  {}
func (eventWithPrismaTransitionsEqualsParam) equals() {}

type eventWithPrismaTransitionsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaTransitionsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaTransitionsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaTransitionsEqualsUniqueParam) eventModel()       {}
func (p eventWithPrismaTransitionsEqualsUniqueParam) transitionsField() {}

func (eventWithPrismaTransitionsEqualsUniqueParam) unique() {}
func (eventWithPrismaTransitionsEqualsUniqueParam) equals() {}

type EventWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	eventModel()
	createdAtField()
}

type EventWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	createdAtField()
}

type eventWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaCreatedAtSetParam) eventModel() {}

func (p eventWithPrismaCreatedAtSetParam) createdAtField() {}

type EventWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	createdAtField()
}

type eventWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaCreatedAtEqualsParam) eventModel() {}

func (p eventWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (eventWithPrismaCreatedAtSetParam) settable()  {}
func (eventWithPrismaCreatedAtEqualsParam) equals() {}

type eventWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaCreatedAtEqualsUniqueParam) eventModel()     {}
func (p eventWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (eventWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (eventWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type EventWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	eventModel()
	updatedAtField()
}

type EventWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	updatedAtField()
}

type eventWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaUpdatedAtSetParam) eventModel() {}

func (p eventWithPrismaUpdatedAtSetParam) updatedAtField() {}

type EventWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	updatedAtField()
}

type eventWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaUpdatedAtEqualsParam) eventModel() {}

func (p eventWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (eventWithPrismaUpdatedAtSetParam) settable()  {}
func (eventWithPrismaUpdatedAtEqualsParam) equals() {}

type eventWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaUpdatedAtEqualsUniqueParam) eventModel()     {}
func (p eventWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (eventWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (eventWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type EventWithPrismaFieldsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	eventModel()
	fieldsField()
}

type EventWithPrismaFieldsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	fieldsField()
}

type eventWithPrismaFieldsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaFieldsSetParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaFieldsSetParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaFieldsSetParam) eventModel() {}

func (p eventWithPrismaFieldsSetParam) fieldsField() {}

type EventWithPrismaFieldsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	fieldsField()
}

type eventWithPrismaFieldsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaFieldsEqualsParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaFieldsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaFieldsEqualsParam) eventModel() {}

func (p eventWithPrismaFieldsEqualsParam) fieldsField() {}

func (eventWithPrismaFieldsSetParam) settable()  {}
func (eventWithPrismaFieldsEqualsParam) equals() {}

type eventWithPrismaFieldsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaFieldsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaFieldsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaFieldsEqualsUniqueParam) eventModel()  {}
func (p eventWithPrismaFieldsEqualsUniqueParam) fieldsField() {}

func (eventWithPrismaFieldsEqualsUniqueParam) unique() {}
func (eventWithPrismaFieldsEqualsUniqueParam) equals() {}

type EventWithPrismaCommandsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	eventModel()
	commandsField()
}

type EventWithPrismaCommandsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	commandsField()
}

type eventWithPrismaCommandsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaCommandsSetParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaCommandsSetParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaCommandsSetParam) eventModel() {}

func (p eventWithPrismaCommandsSetParam) commandsField() {}

type EventWithPrismaCommandsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	commandsField()
}

type eventWithPrismaCommandsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaCommandsEqualsParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaCommandsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaCommandsEqualsParam) eventModel() {}

func (p eventWithPrismaCommandsEqualsParam) commandsField() {}

func (eventWithPrismaCommandsSetParam) settable()  {}
func (eventWithPrismaCommandsEqualsParam) equals() {}

type eventWithPrismaCommandsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaCommandsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaCommandsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaCommandsEqualsUniqueParam) eventModel()    {}
func (p eventWithPrismaCommandsEqualsUniqueParam) commandsField() {}

func (eventWithPrismaCommandsEqualsUniqueParam) unique() {}
func (eventWithPrismaCommandsEqualsUniqueParam) equals() {}

type EventWithPrismaDataEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	eventModel()
	dataField()
}

type EventWithPrismaDataSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	dataField()
}

type eventWithPrismaDataSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaDataSetParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaDataSetParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaDataSetParam) eventModel() {}

func (p eventWithPrismaDataSetParam) dataField() {}

type EventWithPrismaDataWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	dataField()
}

type eventWithPrismaDataEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaDataEqualsParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaDataEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaDataEqualsParam) eventModel() {}

func (p eventWithPrismaDataEqualsParam) dataField() {}

func (eventWithPrismaDataSetParam) settable()  {}
func (eventWithPrismaDataEqualsParam) equals() {}

type eventWithPrismaDataEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaDataEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaDataEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaDataEqualsUniqueParam) eventModel() {}
func (p eventWithPrismaDataEqualsUniqueParam) dataField()  {}

func (eventWithPrismaDataEqualsUniqueParam) unique() {}
func (eventWithPrismaDataEqualsUniqueParam) equals() {}

type EventWithPrismaPlaceInterfaceIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	eventModel()
	placeInterfaceIDField()
}

type EventWithPrismaPlaceInterfaceIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	placeInterfaceIDField()
}

type eventWithPrismaPlaceInterfaceIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaPlaceInterfaceIDSetParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaPlaceInterfaceIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaPlaceInterfaceIDSetParam) eventModel() {}

func (p eventWithPrismaPlaceInterfaceIDSetParam) placeInterfaceIDField() {}

type EventWithPrismaPlaceInterfaceIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	placeInterfaceIDField()
}

type eventWithPrismaPlaceInterfaceIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaPlaceInterfaceIDEqualsParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaPlaceInterfaceIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaPlaceInterfaceIDEqualsParam) eventModel() {}

func (p eventWithPrismaPlaceInterfaceIDEqualsParam) placeInterfaceIDField() {}

func (eventWithPrismaPlaceInterfaceIDSetParam) settable()  {}
func (eventWithPrismaPlaceInterfaceIDEqualsParam) equals() {}

type eventWithPrismaPlaceInterfaceIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaPlaceInterfaceIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaPlaceInterfaceIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaPlaceInterfaceIDEqualsUniqueParam) eventModel()            {}
func (p eventWithPrismaPlaceInterfaceIDEqualsUniqueParam) placeInterfaceIDField() {}

func (eventWithPrismaPlaceInterfaceIDEqualsUniqueParam) unique() {}
func (eventWithPrismaPlaceInterfaceIDEqualsUniqueParam) equals() {}

type EventWithPrismaTransitionInterfaceEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	eventModel()
	transitionInterfaceField()
}

type EventWithPrismaTransitionInterfaceSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	transitionInterfaceField()
}

type eventWithPrismaTransitionInterfaceSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaTransitionInterfaceSetParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaTransitionInterfaceSetParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaTransitionInterfaceSetParam) eventModel() {}

func (p eventWithPrismaTransitionInterfaceSetParam) transitionInterfaceField() {}

type EventWithPrismaTransitionInterfaceWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	transitionInterfaceField()
}

type eventWithPrismaTransitionInterfaceEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaTransitionInterfaceEqualsParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaTransitionInterfaceEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaTransitionInterfaceEqualsParam) eventModel() {}

func (p eventWithPrismaTransitionInterfaceEqualsParam) transitionInterfaceField() {}

func (eventWithPrismaTransitionInterfaceSetParam) settable()  {}
func (eventWithPrismaTransitionInterfaceEqualsParam) equals() {}

type eventWithPrismaTransitionInterfaceEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaTransitionInterfaceEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaTransitionInterfaceEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaTransitionInterfaceEqualsUniqueParam) eventModel()               {}
func (p eventWithPrismaTransitionInterfaceEqualsUniqueParam) transitionInterfaceField() {}

func (eventWithPrismaTransitionInterfaceEqualsUniqueParam) unique() {}
func (eventWithPrismaTransitionInterfaceEqualsUniqueParam) equals() {}

type EventWithPrismaTransitionInterfaceIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	eventModel()
	transitionInterfaceIDField()
}

type EventWithPrismaTransitionInterfaceIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	transitionInterfaceIDField()
}

type eventWithPrismaTransitionInterfaceIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaTransitionInterfaceIDSetParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaTransitionInterfaceIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaTransitionInterfaceIDSetParam) eventModel() {}

func (p eventWithPrismaTransitionInterfaceIDSetParam) transitionInterfaceIDField() {}

type EventWithPrismaTransitionInterfaceIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	eventModel()
	transitionInterfaceIDField()
}

type eventWithPrismaTransitionInterfaceIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaTransitionInterfaceIDEqualsParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaTransitionInterfaceIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaTransitionInterfaceIDEqualsParam) eventModel() {}

func (p eventWithPrismaTransitionInterfaceIDEqualsParam) transitionInterfaceIDField() {}

func (eventWithPrismaTransitionInterfaceIDSetParam) settable()  {}
func (eventWithPrismaTransitionInterfaceIDEqualsParam) equals() {}

type eventWithPrismaTransitionInterfaceIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p eventWithPrismaTransitionInterfaceIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p eventWithPrismaTransitionInterfaceIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p eventWithPrismaTransitionInterfaceIDEqualsUniqueParam) eventModel()                 {}
func (p eventWithPrismaTransitionInterfaceIDEqualsUniqueParam) transitionInterfaceIDField() {}

func (eventWithPrismaTransitionInterfaceIDEqualsUniqueParam) unique() {}
func (eventWithPrismaTransitionInterfaceIDEqualsUniqueParam) equals() {}

type instanceActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var instanceOutput = []builder.Output{
	{Name: "id"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "authorID"},
	{Name: "language"},
	{Name: "name"},
	{Name: "deviceId"},
	{Name: "addr"},
}

type InstanceRelationWith interface {
	getQuery() builder.Query
	with()
	instanceRelation()
}

type InstanceWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
}

type instanceDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceDefaultParam) field() builder.Field {
	return p.data
}

func (p instanceDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p instanceDefaultParam) instanceModel() {}

type InstanceOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
}

type instanceOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceOrderByParam) field() builder.Field {
	return p.data
}

func (p instanceOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p instanceOrderByParam) instanceModel() {}

type InstanceCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	isCursor()
}

type instanceCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceCursorParam) field() builder.Field {
	return p.data
}

func (p instanceCursorParam) isCursor() {}

func (p instanceCursorParam) getQuery() builder.Query {
	return p.query
}

func (p instanceCursorParam) instanceModel() {}

type InstanceParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	instanceModel()
}

type instanceParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p instanceParamUnique) instanceModel() {}

func (instanceParamUnique) unique() {}

func (p instanceParamUnique) field() builder.Field {
	return p.data
}

func (p instanceParamUnique) getQuery() builder.Query {
	return p.query
}

type InstanceEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	instanceModel()
}

type instanceEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceEqualsParam) instanceModel() {}

func (instanceEqualsParam) equals() {}

func (p instanceEqualsParam) field() builder.Field {
	return p.data
}

func (p instanceEqualsParam) getQuery() builder.Query {
	return p.query
}

type InstanceEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	instanceModel()
}

type instanceEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceEqualsUniqueParam) instanceModel() {}

func (instanceEqualsUniqueParam) unique() {}
func (instanceEqualsUniqueParam) equals() {}

func (p instanceEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p instanceEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type InstanceSetParam interface {
	field() builder.Field
	settable()
	instanceModel()
}

type instanceSetParam struct {
	data builder.Field
}

func (instanceSetParam) settable() {}

func (p instanceSetParam) field() builder.Field {
	return p.data
}

func (p instanceSetParam) instanceModel() {}

type InstanceWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	instanceModel()
	idField()
}

type InstanceWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	idField()
}

type instanceWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaIDSetParam) instanceModel() {}

func (p instanceWithPrismaIDSetParam) idField() {}

type InstanceWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	idField()
}

type instanceWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaIDEqualsParam) instanceModel() {}

func (p instanceWithPrismaIDEqualsParam) idField() {}

func (instanceWithPrismaIDSetParam) settable()  {}
func (instanceWithPrismaIDEqualsParam) equals() {}

type instanceWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaIDEqualsUniqueParam) instanceModel() {}
func (p instanceWithPrismaIDEqualsUniqueParam) idField()       {}

func (instanceWithPrismaIDEqualsUniqueParam) unique() {}
func (instanceWithPrismaIDEqualsUniqueParam) equals() {}

type InstanceWithPrismaAuthorEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	instanceModel()
	authorField()
}

type InstanceWithPrismaAuthorSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	authorField()
}

type instanceWithPrismaAuthorSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaAuthorSetParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaAuthorSetParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaAuthorSetParam) instanceModel() {}

func (p instanceWithPrismaAuthorSetParam) authorField() {}

type InstanceWithPrismaAuthorWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	authorField()
}

type instanceWithPrismaAuthorEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaAuthorEqualsParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaAuthorEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaAuthorEqualsParam) instanceModel() {}

func (p instanceWithPrismaAuthorEqualsParam) authorField() {}

func (instanceWithPrismaAuthorSetParam) settable()  {}
func (instanceWithPrismaAuthorEqualsParam) equals() {}

type instanceWithPrismaAuthorEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaAuthorEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaAuthorEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaAuthorEqualsUniqueParam) instanceModel() {}
func (p instanceWithPrismaAuthorEqualsUniqueParam) authorField()   {}

func (instanceWithPrismaAuthorEqualsUniqueParam) unique() {}
func (instanceWithPrismaAuthorEqualsUniqueParam) equals() {}

type InstanceWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	instanceModel()
	createdAtField()
}

type InstanceWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	createdAtField()
}

type instanceWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaCreatedAtSetParam) instanceModel() {}

func (p instanceWithPrismaCreatedAtSetParam) createdAtField() {}

type InstanceWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	createdAtField()
}

type instanceWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaCreatedAtEqualsParam) instanceModel() {}

func (p instanceWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (instanceWithPrismaCreatedAtSetParam) settable()  {}
func (instanceWithPrismaCreatedAtEqualsParam) equals() {}

type instanceWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaCreatedAtEqualsUniqueParam) instanceModel()  {}
func (p instanceWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (instanceWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (instanceWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type InstanceWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	instanceModel()
	updatedAtField()
}

type InstanceWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	updatedAtField()
}

type instanceWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaUpdatedAtSetParam) instanceModel() {}

func (p instanceWithPrismaUpdatedAtSetParam) updatedAtField() {}

type InstanceWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	updatedAtField()
}

type instanceWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaUpdatedAtEqualsParam) instanceModel() {}

func (p instanceWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (instanceWithPrismaUpdatedAtSetParam) settable()  {}
func (instanceWithPrismaUpdatedAtEqualsParam) equals() {}

type instanceWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaUpdatedAtEqualsUniqueParam) instanceModel()  {}
func (p instanceWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (instanceWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (instanceWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type InstanceWithPrismaAuthorIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	instanceModel()
	authorIDField()
}

type InstanceWithPrismaAuthorIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	authorIDField()
}

type instanceWithPrismaAuthorIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaAuthorIDSetParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaAuthorIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaAuthorIDSetParam) instanceModel() {}

func (p instanceWithPrismaAuthorIDSetParam) authorIDField() {}

type InstanceWithPrismaAuthorIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	authorIDField()
}

type instanceWithPrismaAuthorIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaAuthorIDEqualsParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaAuthorIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaAuthorIDEqualsParam) instanceModel() {}

func (p instanceWithPrismaAuthorIDEqualsParam) authorIDField() {}

func (instanceWithPrismaAuthorIDSetParam) settable()  {}
func (instanceWithPrismaAuthorIDEqualsParam) equals() {}

type instanceWithPrismaAuthorIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaAuthorIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaAuthorIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaAuthorIDEqualsUniqueParam) instanceModel() {}
func (p instanceWithPrismaAuthorIDEqualsUniqueParam) authorIDField() {}

func (instanceWithPrismaAuthorIDEqualsUniqueParam) unique() {}
func (instanceWithPrismaAuthorIDEqualsUniqueParam) equals() {}

type InstanceWithPrismaLanguageEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	instanceModel()
	languageField()
}

type InstanceWithPrismaLanguageSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	languageField()
}

type instanceWithPrismaLanguageSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaLanguageSetParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaLanguageSetParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaLanguageSetParam) instanceModel() {}

func (p instanceWithPrismaLanguageSetParam) languageField() {}

type InstanceWithPrismaLanguageWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	languageField()
}

type instanceWithPrismaLanguageEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaLanguageEqualsParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaLanguageEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaLanguageEqualsParam) instanceModel() {}

func (p instanceWithPrismaLanguageEqualsParam) languageField() {}

func (instanceWithPrismaLanguageSetParam) settable()  {}
func (instanceWithPrismaLanguageEqualsParam) equals() {}

type instanceWithPrismaLanguageEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaLanguageEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaLanguageEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaLanguageEqualsUniqueParam) instanceModel() {}
func (p instanceWithPrismaLanguageEqualsUniqueParam) languageField() {}

func (instanceWithPrismaLanguageEqualsUniqueParam) unique() {}
func (instanceWithPrismaLanguageEqualsUniqueParam) equals() {}

type InstanceWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	instanceModel()
	nameField()
}

type InstanceWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	nameField()
}

type instanceWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaNameSetParam) instanceModel() {}

func (p instanceWithPrismaNameSetParam) nameField() {}

type InstanceWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	nameField()
}

type instanceWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaNameEqualsParam) instanceModel() {}

func (p instanceWithPrismaNameEqualsParam) nameField() {}

func (instanceWithPrismaNameSetParam) settable()  {}
func (instanceWithPrismaNameEqualsParam) equals() {}

type instanceWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaNameEqualsUniqueParam) instanceModel() {}
func (p instanceWithPrismaNameEqualsUniqueParam) nameField()     {}

func (instanceWithPrismaNameEqualsUniqueParam) unique() {}
func (instanceWithPrismaNameEqualsUniqueParam) equals() {}

type InstanceWithPrismaDeviceEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	instanceModel()
	deviceField()
}

type InstanceWithPrismaDeviceSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	deviceField()
}

type instanceWithPrismaDeviceSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaDeviceSetParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaDeviceSetParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaDeviceSetParam) instanceModel() {}

func (p instanceWithPrismaDeviceSetParam) deviceField() {}

type InstanceWithPrismaDeviceWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	deviceField()
}

type instanceWithPrismaDeviceEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaDeviceEqualsParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaDeviceEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaDeviceEqualsParam) instanceModel() {}

func (p instanceWithPrismaDeviceEqualsParam) deviceField() {}

func (instanceWithPrismaDeviceSetParam) settable()  {}
func (instanceWithPrismaDeviceEqualsParam) equals() {}

type instanceWithPrismaDeviceEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaDeviceEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaDeviceEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaDeviceEqualsUniqueParam) instanceModel() {}
func (p instanceWithPrismaDeviceEqualsUniqueParam) deviceField()   {}

func (instanceWithPrismaDeviceEqualsUniqueParam) unique() {}
func (instanceWithPrismaDeviceEqualsUniqueParam) equals() {}

type InstanceWithPrismaDeviceIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	instanceModel()
	deviceIDField()
}

type InstanceWithPrismaDeviceIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	deviceIDField()
}

type instanceWithPrismaDeviceIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaDeviceIDSetParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaDeviceIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaDeviceIDSetParam) instanceModel() {}

func (p instanceWithPrismaDeviceIDSetParam) deviceIDField() {}

type InstanceWithPrismaDeviceIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	deviceIDField()
}

type instanceWithPrismaDeviceIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaDeviceIDEqualsParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaDeviceIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaDeviceIDEqualsParam) instanceModel() {}

func (p instanceWithPrismaDeviceIDEqualsParam) deviceIDField() {}

func (instanceWithPrismaDeviceIDSetParam) settable()  {}
func (instanceWithPrismaDeviceIDEqualsParam) equals() {}

type instanceWithPrismaDeviceIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaDeviceIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaDeviceIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaDeviceIDEqualsUniqueParam) instanceModel() {}
func (p instanceWithPrismaDeviceIDEqualsUniqueParam) deviceIDField() {}

func (instanceWithPrismaDeviceIDEqualsUniqueParam) unique() {}
func (instanceWithPrismaDeviceIDEqualsUniqueParam) equals() {}

type InstanceWithPrismaAddrEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	instanceModel()
	addrField()
}

type InstanceWithPrismaAddrSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	addrField()
}

type instanceWithPrismaAddrSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaAddrSetParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaAddrSetParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaAddrSetParam) instanceModel() {}

func (p instanceWithPrismaAddrSetParam) addrField() {}

type InstanceWithPrismaAddrWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	addrField()
}

type instanceWithPrismaAddrEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaAddrEqualsParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaAddrEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaAddrEqualsParam) instanceModel() {}

func (p instanceWithPrismaAddrEqualsParam) addrField() {}

func (instanceWithPrismaAddrSetParam) settable()  {}
func (instanceWithPrismaAddrEqualsParam) equals() {}

type instanceWithPrismaAddrEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaAddrEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaAddrEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaAddrEqualsUniqueParam) instanceModel() {}
func (p instanceWithPrismaAddrEqualsUniqueParam) addrField()     {}

func (instanceWithPrismaAddrEqualsUniqueParam) unique() {}
func (instanceWithPrismaAddrEqualsUniqueParam) equals() {}

type InstanceWithPrismaDataEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	instanceModel()
	dataField()
}

type InstanceWithPrismaDataSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	dataField()
}

type instanceWithPrismaDataSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaDataSetParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaDataSetParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaDataSetParam) instanceModel() {}

func (p instanceWithPrismaDataSetParam) dataField() {}

type InstanceWithPrismaDataWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	dataField()
}

type instanceWithPrismaDataEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaDataEqualsParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaDataEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaDataEqualsParam) instanceModel() {}

func (p instanceWithPrismaDataEqualsParam) dataField() {}

func (instanceWithPrismaDataSetParam) settable()  {}
func (instanceWithPrismaDataEqualsParam) equals() {}

type instanceWithPrismaDataEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaDataEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaDataEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaDataEqualsUniqueParam) instanceModel() {}
func (p instanceWithPrismaDataEqualsUniqueParam) dataField()     {}

func (instanceWithPrismaDataEqualsUniqueParam) unique() {}
func (instanceWithPrismaDataEqualsUniqueParam) equals() {}

type InstanceWithPrismaSessionsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	instanceModel()
	sessionsField()
}

type InstanceWithPrismaSessionsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	sessionsField()
}

type instanceWithPrismaSessionsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaSessionsSetParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaSessionsSetParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaSessionsSetParam) instanceModel() {}

func (p instanceWithPrismaSessionsSetParam) sessionsField() {}

type InstanceWithPrismaSessionsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	instanceModel()
	sessionsField()
}

type instanceWithPrismaSessionsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaSessionsEqualsParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaSessionsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaSessionsEqualsParam) instanceModel() {}

func (p instanceWithPrismaSessionsEqualsParam) sessionsField() {}

func (instanceWithPrismaSessionsSetParam) settable()  {}
func (instanceWithPrismaSessionsEqualsParam) equals() {}

type instanceWithPrismaSessionsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p instanceWithPrismaSessionsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p instanceWithPrismaSessionsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p instanceWithPrismaSessionsEqualsUniqueParam) instanceModel() {}
func (p instanceWithPrismaSessionsEqualsUniqueParam) sessionsField() {}

func (instanceWithPrismaSessionsEqualsUniqueParam) unique() {}
func (instanceWithPrismaSessionsEqualsUniqueParam) equals() {}

type deviceActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var deviceOutput = []builder.Output{
	{Name: "id"},
	{Name: "authorID"},
	{Name: "name"},
	{Name: "description"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "netIDs"},
}

type DeviceRelationWith interface {
	getQuery() builder.Query
	with()
	deviceRelation()
}

type DeviceWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
}

type deviceDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceDefaultParam) field() builder.Field {
	return p.data
}

func (p deviceDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p deviceDefaultParam) deviceModel() {}

type DeviceOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
}

type deviceOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceOrderByParam) field() builder.Field {
	return p.data
}

func (p deviceOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p deviceOrderByParam) deviceModel() {}

type DeviceCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	isCursor()
}

type deviceCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceCursorParam) field() builder.Field {
	return p.data
}

func (p deviceCursorParam) isCursor() {}

func (p deviceCursorParam) getQuery() builder.Query {
	return p.query
}

func (p deviceCursorParam) deviceModel() {}

type DeviceParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	deviceModel()
}

type deviceParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p deviceParamUnique) deviceModel() {}

func (deviceParamUnique) unique() {}

func (p deviceParamUnique) field() builder.Field {
	return p.data
}

func (p deviceParamUnique) getQuery() builder.Query {
	return p.query
}

type DeviceEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	deviceModel()
}

type deviceEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceEqualsParam) deviceModel() {}

func (deviceEqualsParam) equals() {}

func (p deviceEqualsParam) field() builder.Field {
	return p.data
}

func (p deviceEqualsParam) getQuery() builder.Query {
	return p.query
}

type DeviceEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	deviceModel()
}

type deviceEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceEqualsUniqueParam) deviceModel() {}

func (deviceEqualsUniqueParam) unique() {}
func (deviceEqualsUniqueParam) equals() {}

func (p deviceEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p deviceEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type DeviceSetParam interface {
	field() builder.Field
	settable()
	deviceModel()
}

type deviceSetParam struct {
	data builder.Field
}

func (deviceSetParam) settable() {}

func (p deviceSetParam) field() builder.Field {
	return p.data
}

func (p deviceSetParam) deviceModel() {}

type DeviceWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	deviceModel()
	idField()
}

type DeviceWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	idField()
}

type deviceWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaIDSetParam) deviceModel() {}

func (p deviceWithPrismaIDSetParam) idField() {}

type DeviceWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	idField()
}

type deviceWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaIDEqualsParam) deviceModel() {}

func (p deviceWithPrismaIDEqualsParam) idField() {}

func (deviceWithPrismaIDSetParam) settable()  {}
func (deviceWithPrismaIDEqualsParam) equals() {}

type deviceWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaIDEqualsUniqueParam) deviceModel() {}
func (p deviceWithPrismaIDEqualsUniqueParam) idField()     {}

func (deviceWithPrismaIDEqualsUniqueParam) unique() {}
func (deviceWithPrismaIDEqualsUniqueParam) equals() {}

type DeviceWithPrismaAuthorEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	deviceModel()
	authorField()
}

type DeviceWithPrismaAuthorSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	authorField()
}

type deviceWithPrismaAuthorSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaAuthorSetParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaAuthorSetParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaAuthorSetParam) deviceModel() {}

func (p deviceWithPrismaAuthorSetParam) authorField() {}

type DeviceWithPrismaAuthorWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	authorField()
}

type deviceWithPrismaAuthorEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaAuthorEqualsParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaAuthorEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaAuthorEqualsParam) deviceModel() {}

func (p deviceWithPrismaAuthorEqualsParam) authorField() {}

func (deviceWithPrismaAuthorSetParam) settable()  {}
func (deviceWithPrismaAuthorEqualsParam) equals() {}

type deviceWithPrismaAuthorEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaAuthorEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaAuthorEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaAuthorEqualsUniqueParam) deviceModel() {}
func (p deviceWithPrismaAuthorEqualsUniqueParam) authorField() {}

func (deviceWithPrismaAuthorEqualsUniqueParam) unique() {}
func (deviceWithPrismaAuthorEqualsUniqueParam) equals() {}

type DeviceWithPrismaAuthorIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	deviceModel()
	authorIDField()
}

type DeviceWithPrismaAuthorIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	authorIDField()
}

type deviceWithPrismaAuthorIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaAuthorIDSetParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaAuthorIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaAuthorIDSetParam) deviceModel() {}

func (p deviceWithPrismaAuthorIDSetParam) authorIDField() {}

type DeviceWithPrismaAuthorIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	authorIDField()
}

type deviceWithPrismaAuthorIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaAuthorIDEqualsParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaAuthorIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaAuthorIDEqualsParam) deviceModel() {}

func (p deviceWithPrismaAuthorIDEqualsParam) authorIDField() {}

func (deviceWithPrismaAuthorIDSetParam) settable()  {}
func (deviceWithPrismaAuthorIDEqualsParam) equals() {}

type deviceWithPrismaAuthorIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaAuthorIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaAuthorIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaAuthorIDEqualsUniqueParam) deviceModel()   {}
func (p deviceWithPrismaAuthorIDEqualsUniqueParam) authorIDField() {}

func (deviceWithPrismaAuthorIDEqualsUniqueParam) unique() {}
func (deviceWithPrismaAuthorIDEqualsUniqueParam) equals() {}

type DeviceWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	deviceModel()
	nameField()
}

type DeviceWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	nameField()
}

type deviceWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaNameSetParam) deviceModel() {}

func (p deviceWithPrismaNameSetParam) nameField() {}

type DeviceWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	nameField()
}

type deviceWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaNameEqualsParam) deviceModel() {}

func (p deviceWithPrismaNameEqualsParam) nameField() {}

func (deviceWithPrismaNameSetParam) settable()  {}
func (deviceWithPrismaNameEqualsParam) equals() {}

type deviceWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaNameEqualsUniqueParam) deviceModel() {}
func (p deviceWithPrismaNameEqualsUniqueParam) nameField()   {}

func (deviceWithPrismaNameEqualsUniqueParam) unique() {}
func (deviceWithPrismaNameEqualsUniqueParam) equals() {}

type DeviceWithPrismaDescriptionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	deviceModel()
	descriptionField()
}

type DeviceWithPrismaDescriptionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	descriptionField()
}

type deviceWithPrismaDescriptionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaDescriptionSetParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaDescriptionSetParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaDescriptionSetParam) deviceModel() {}

func (p deviceWithPrismaDescriptionSetParam) descriptionField() {}

type DeviceWithPrismaDescriptionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	descriptionField()
}

type deviceWithPrismaDescriptionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaDescriptionEqualsParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaDescriptionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaDescriptionEqualsParam) deviceModel() {}

func (p deviceWithPrismaDescriptionEqualsParam) descriptionField() {}

func (deviceWithPrismaDescriptionSetParam) settable()  {}
func (deviceWithPrismaDescriptionEqualsParam) equals() {}

type deviceWithPrismaDescriptionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaDescriptionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaDescriptionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaDescriptionEqualsUniqueParam) deviceModel()      {}
func (p deviceWithPrismaDescriptionEqualsUniqueParam) descriptionField() {}

func (deviceWithPrismaDescriptionEqualsUniqueParam) unique() {}
func (deviceWithPrismaDescriptionEqualsUniqueParam) equals() {}

type DeviceWithPrismaInstancesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	deviceModel()
	instancesField()
}

type DeviceWithPrismaInstancesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	instancesField()
}

type deviceWithPrismaInstancesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaInstancesSetParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaInstancesSetParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaInstancesSetParam) deviceModel() {}

func (p deviceWithPrismaInstancesSetParam) instancesField() {}

type DeviceWithPrismaInstancesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	instancesField()
}

type deviceWithPrismaInstancesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaInstancesEqualsParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaInstancesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaInstancesEqualsParam) deviceModel() {}

func (p deviceWithPrismaInstancesEqualsParam) instancesField() {}

func (deviceWithPrismaInstancesSetParam) settable()  {}
func (deviceWithPrismaInstancesEqualsParam) equals() {}

type deviceWithPrismaInstancesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaInstancesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaInstancesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaInstancesEqualsUniqueParam) deviceModel()    {}
func (p deviceWithPrismaInstancesEqualsUniqueParam) instancesField() {}

func (deviceWithPrismaInstancesEqualsUniqueParam) unique() {}
func (deviceWithPrismaInstancesEqualsUniqueParam) equals() {}

type DeviceWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	deviceModel()
	createdAtField()
}

type DeviceWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	createdAtField()
}

type deviceWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaCreatedAtSetParam) deviceModel() {}

func (p deviceWithPrismaCreatedAtSetParam) createdAtField() {}

type DeviceWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	createdAtField()
}

type deviceWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaCreatedAtEqualsParam) deviceModel() {}

func (p deviceWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (deviceWithPrismaCreatedAtSetParam) settable()  {}
func (deviceWithPrismaCreatedAtEqualsParam) equals() {}

type deviceWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaCreatedAtEqualsUniqueParam) deviceModel()    {}
func (p deviceWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (deviceWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (deviceWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type DeviceWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	deviceModel()
	updatedAtField()
}

type DeviceWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	updatedAtField()
}

type deviceWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaUpdatedAtSetParam) deviceModel() {}

func (p deviceWithPrismaUpdatedAtSetParam) updatedAtField() {}

type DeviceWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	updatedAtField()
}

type deviceWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaUpdatedAtEqualsParam) deviceModel() {}

func (p deviceWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (deviceWithPrismaUpdatedAtSetParam) settable()  {}
func (deviceWithPrismaUpdatedAtEqualsParam) equals() {}

type deviceWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaUpdatedAtEqualsUniqueParam) deviceModel()    {}
func (p deviceWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (deviceWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (deviceWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type DeviceWithPrismaNetIDsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	deviceModel()
	netIDsField()
}

type DeviceWithPrismaNetIDsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	netIDsField()
}

type deviceWithPrismaNetIDsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaNetIDsSetParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaNetIDsSetParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaNetIDsSetParam) deviceModel() {}

func (p deviceWithPrismaNetIDsSetParam) netIDsField() {}

type DeviceWithPrismaNetIDsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	netIDsField()
}

type deviceWithPrismaNetIDsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaNetIDsEqualsParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaNetIDsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaNetIDsEqualsParam) deviceModel() {}

func (p deviceWithPrismaNetIDsEqualsParam) netIDsField() {}

func (deviceWithPrismaNetIDsSetParam) settable()  {}
func (deviceWithPrismaNetIDsEqualsParam) equals() {}

type deviceWithPrismaNetIDsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaNetIDsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaNetIDsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaNetIDsEqualsUniqueParam) deviceModel() {}
func (p deviceWithPrismaNetIDsEqualsUniqueParam) netIDsField() {}

func (deviceWithPrismaNetIDsEqualsUniqueParam) unique() {}
func (deviceWithPrismaNetIDsEqualsUniqueParam) equals() {}

type DeviceWithPrismaNetsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	deviceModel()
	netsField()
}

type DeviceWithPrismaNetsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	netsField()
}

type deviceWithPrismaNetsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaNetsSetParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaNetsSetParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaNetsSetParam) deviceModel() {}

func (p deviceWithPrismaNetsSetParam) netsField() {}

type DeviceWithPrismaNetsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	netsField()
}

type deviceWithPrismaNetsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaNetsEqualsParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaNetsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaNetsEqualsParam) deviceModel() {}

func (p deviceWithPrismaNetsEqualsParam) netsField() {}

func (deviceWithPrismaNetsSetParam) settable()  {}
func (deviceWithPrismaNetsEqualsParam) equals() {}

type deviceWithPrismaNetsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaNetsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaNetsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaNetsEqualsUniqueParam) deviceModel() {}
func (p deviceWithPrismaNetsEqualsUniqueParam) netsField()   {}

func (deviceWithPrismaNetsEqualsUniqueParam) unique() {}
func (deviceWithPrismaNetsEqualsUniqueParam) equals() {}

type DeviceWithPrismaActionsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	deviceModel()
	actionsField()
}

type DeviceWithPrismaActionsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	actionsField()
}

type deviceWithPrismaActionsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaActionsSetParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaActionsSetParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaActionsSetParam) deviceModel() {}

func (p deviceWithPrismaActionsSetParam) actionsField() {}

type DeviceWithPrismaActionsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	deviceModel()
	actionsField()
}

type deviceWithPrismaActionsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaActionsEqualsParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaActionsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaActionsEqualsParam) deviceModel() {}

func (p deviceWithPrismaActionsEqualsParam) actionsField() {}

func (deviceWithPrismaActionsSetParam) settable()  {}
func (deviceWithPrismaActionsEqualsParam) equals() {}

type deviceWithPrismaActionsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p deviceWithPrismaActionsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p deviceWithPrismaActionsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p deviceWithPrismaActionsEqualsUniqueParam) deviceModel()  {}
func (p deviceWithPrismaActionsEqualsUniqueParam) actionsField() {}

func (deviceWithPrismaActionsEqualsUniqueParam) unique() {}
func (deviceWithPrismaActionsEqualsUniqueParam) equals() {}

type constantActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var constantOutput = []builder.Output{
	{Name: "id"},
	{Name: "actionID"},
	{Name: "fieldID"},
	{Name: "value"},
}

type ConstantRelationWith interface {
	getQuery() builder.Query
	with()
	constantRelation()
}

type ConstantWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	constantModel()
}

type constantDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantDefaultParam) field() builder.Field {
	return p.data
}

func (p constantDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p constantDefaultParam) constantModel() {}

type ConstantOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	constantModel()
}

type constantOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantOrderByParam) field() builder.Field {
	return p.data
}

func (p constantOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p constantOrderByParam) constantModel() {}

type ConstantCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	constantModel()
	isCursor()
}

type constantCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantCursorParam) field() builder.Field {
	return p.data
}

func (p constantCursorParam) isCursor() {}

func (p constantCursorParam) getQuery() builder.Query {
	return p.query
}

func (p constantCursorParam) constantModel() {}

type ConstantParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	constantModel()
}

type constantParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p constantParamUnique) constantModel() {}

func (constantParamUnique) unique() {}

func (p constantParamUnique) field() builder.Field {
	return p.data
}

func (p constantParamUnique) getQuery() builder.Query {
	return p.query
}

type ConstantEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	constantModel()
}

type constantEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantEqualsParam) constantModel() {}

func (constantEqualsParam) equals() {}

func (p constantEqualsParam) field() builder.Field {
	return p.data
}

func (p constantEqualsParam) getQuery() builder.Query {
	return p.query
}

type ConstantEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	constantModel()
}

type constantEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantEqualsUniqueParam) constantModel() {}

func (constantEqualsUniqueParam) unique() {}
func (constantEqualsUniqueParam) equals() {}

func (p constantEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p constantEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type ConstantSetParam interface {
	field() builder.Field
	settable()
	constantModel()
}

type constantSetParam struct {
	data builder.Field
}

func (constantSetParam) settable() {}

func (p constantSetParam) field() builder.Field {
	return p.data
}

func (p constantSetParam) constantModel() {}

type ConstantWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	constantModel()
	idField()
}

type ConstantWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	constantModel()
	idField()
}

type constantWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaIDSetParam) constantModel() {}

func (p constantWithPrismaIDSetParam) idField() {}

type ConstantWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	constantModel()
	idField()
}

type constantWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaIDEqualsParam) constantModel() {}

func (p constantWithPrismaIDEqualsParam) idField() {}

func (constantWithPrismaIDSetParam) settable()  {}
func (constantWithPrismaIDEqualsParam) equals() {}

type constantWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaIDEqualsUniqueParam) constantModel() {}
func (p constantWithPrismaIDEqualsUniqueParam) idField()       {}

func (constantWithPrismaIDEqualsUniqueParam) unique() {}
func (constantWithPrismaIDEqualsUniqueParam) equals() {}

type ConstantWithPrismaActionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	constantModel()
	actionField()
}

type ConstantWithPrismaActionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	constantModel()
	actionField()
}

type constantWithPrismaActionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaActionSetParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaActionSetParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaActionSetParam) constantModel() {}

func (p constantWithPrismaActionSetParam) actionField() {}

type ConstantWithPrismaActionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	constantModel()
	actionField()
}

type constantWithPrismaActionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaActionEqualsParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaActionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaActionEqualsParam) constantModel() {}

func (p constantWithPrismaActionEqualsParam) actionField() {}

func (constantWithPrismaActionSetParam) settable()  {}
func (constantWithPrismaActionEqualsParam) equals() {}

type constantWithPrismaActionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaActionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaActionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaActionEqualsUniqueParam) constantModel() {}
func (p constantWithPrismaActionEqualsUniqueParam) actionField()   {}

func (constantWithPrismaActionEqualsUniqueParam) unique() {}
func (constantWithPrismaActionEqualsUniqueParam) equals() {}

type ConstantWithPrismaActionIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	constantModel()
	actionIDField()
}

type ConstantWithPrismaActionIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	constantModel()
	actionIDField()
}

type constantWithPrismaActionIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaActionIDSetParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaActionIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaActionIDSetParam) constantModel() {}

func (p constantWithPrismaActionIDSetParam) actionIDField() {}

type ConstantWithPrismaActionIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	constantModel()
	actionIDField()
}

type constantWithPrismaActionIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaActionIDEqualsParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaActionIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaActionIDEqualsParam) constantModel() {}

func (p constantWithPrismaActionIDEqualsParam) actionIDField() {}

func (constantWithPrismaActionIDSetParam) settable()  {}
func (constantWithPrismaActionIDEqualsParam) equals() {}

type constantWithPrismaActionIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaActionIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaActionIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaActionIDEqualsUniqueParam) constantModel() {}
func (p constantWithPrismaActionIDEqualsUniqueParam) actionIDField() {}

func (constantWithPrismaActionIDEqualsUniqueParam) unique() {}
func (constantWithPrismaActionIDEqualsUniqueParam) equals() {}

type ConstantWithPrismaFieldEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	constantModel()
	fieldField()
}

type ConstantWithPrismaFieldSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	constantModel()
	fieldField()
}

type constantWithPrismaFieldSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaFieldSetParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaFieldSetParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaFieldSetParam) constantModel() {}

func (p constantWithPrismaFieldSetParam) fieldField() {}

type ConstantWithPrismaFieldWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	constantModel()
	fieldField()
}

type constantWithPrismaFieldEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaFieldEqualsParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaFieldEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaFieldEqualsParam) constantModel() {}

func (p constantWithPrismaFieldEqualsParam) fieldField() {}

func (constantWithPrismaFieldSetParam) settable()  {}
func (constantWithPrismaFieldEqualsParam) equals() {}

type constantWithPrismaFieldEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaFieldEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaFieldEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaFieldEqualsUniqueParam) constantModel() {}
func (p constantWithPrismaFieldEqualsUniqueParam) fieldField()    {}

func (constantWithPrismaFieldEqualsUniqueParam) unique() {}
func (constantWithPrismaFieldEqualsUniqueParam) equals() {}

type ConstantWithPrismaFieldIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	constantModel()
	fieldIDField()
}

type ConstantWithPrismaFieldIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	constantModel()
	fieldIDField()
}

type constantWithPrismaFieldIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaFieldIDSetParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaFieldIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaFieldIDSetParam) constantModel() {}

func (p constantWithPrismaFieldIDSetParam) fieldIDField() {}

type ConstantWithPrismaFieldIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	constantModel()
	fieldIDField()
}

type constantWithPrismaFieldIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaFieldIDEqualsParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaFieldIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaFieldIDEqualsParam) constantModel() {}

func (p constantWithPrismaFieldIDEqualsParam) fieldIDField() {}

func (constantWithPrismaFieldIDSetParam) settable()  {}
func (constantWithPrismaFieldIDEqualsParam) equals() {}

type constantWithPrismaFieldIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaFieldIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaFieldIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaFieldIDEqualsUniqueParam) constantModel() {}
func (p constantWithPrismaFieldIDEqualsUniqueParam) fieldIDField()  {}

func (constantWithPrismaFieldIDEqualsUniqueParam) unique() {}
func (constantWithPrismaFieldIDEqualsUniqueParam) equals() {}

type ConstantWithPrismaValueEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	constantModel()
	valueField()
}

type ConstantWithPrismaValueSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	constantModel()
	valueField()
}

type constantWithPrismaValueSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaValueSetParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaValueSetParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaValueSetParam) constantModel() {}

func (p constantWithPrismaValueSetParam) valueField() {}

type ConstantWithPrismaValueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	constantModel()
	valueField()
}

type constantWithPrismaValueEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaValueEqualsParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaValueEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaValueEqualsParam) constantModel() {}

func (p constantWithPrismaValueEqualsParam) valueField() {}

func (constantWithPrismaValueSetParam) settable()  {}
func (constantWithPrismaValueEqualsParam) equals() {}

type constantWithPrismaValueEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p constantWithPrismaValueEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p constantWithPrismaValueEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p constantWithPrismaValueEqualsUniqueParam) constantModel() {}
func (p constantWithPrismaValueEqualsUniqueParam) valueField()    {}

func (constantWithPrismaValueEqualsUniqueParam) unique() {}
func (constantWithPrismaValueEqualsUniqueParam) equals() {}

type actionActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var actionOutput = []builder.Output{
	{Name: "id"},
	{Name: "input"},
	{Name: "output"},
	{Name: "deviceId"},
	{Name: "eventID"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type ActionRelationWith interface {
	getQuery() builder.Query
	with()
	actionRelation()
}

type ActionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
}

type actionDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionDefaultParam) field() builder.Field {
	return p.data
}

func (p actionDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p actionDefaultParam) actionModel() {}

type ActionOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
}

type actionOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionOrderByParam) field() builder.Field {
	return p.data
}

func (p actionOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p actionOrderByParam) actionModel() {}

type ActionCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	isCursor()
}

type actionCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionCursorParam) field() builder.Field {
	return p.data
}

func (p actionCursorParam) isCursor() {}

func (p actionCursorParam) getQuery() builder.Query {
	return p.query
}

func (p actionCursorParam) actionModel() {}

type ActionParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	actionModel()
}

type actionParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p actionParamUnique) actionModel() {}

func (actionParamUnique) unique() {}

func (p actionParamUnique) field() builder.Field {
	return p.data
}

func (p actionParamUnique) getQuery() builder.Query {
	return p.query
}

type ActionEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	actionModel()
}

type actionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionEqualsParam) actionModel() {}

func (actionEqualsParam) equals() {}

func (p actionEqualsParam) field() builder.Field {
	return p.data
}

func (p actionEqualsParam) getQuery() builder.Query {
	return p.query
}

type ActionEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	actionModel()
}

type actionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionEqualsUniqueParam) actionModel() {}

func (actionEqualsUniqueParam) unique() {}
func (actionEqualsUniqueParam) equals() {}

func (p actionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p actionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type ActionSetParam interface {
	field() builder.Field
	settable()
	actionModel()
}

type actionSetParam struct {
	data builder.Field
}

func (actionSetParam) settable() {}

func (p actionSetParam) field() builder.Field {
	return p.data
}

func (p actionSetParam) actionModel() {}

type ActionWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	actionModel()
	idField()
}

type ActionWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	idField()
}

type actionWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaIDSetParam) actionModel() {}

func (p actionWithPrismaIDSetParam) idField() {}

type ActionWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	idField()
}

type actionWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaIDEqualsParam) actionModel() {}

func (p actionWithPrismaIDEqualsParam) idField() {}

func (actionWithPrismaIDSetParam) settable()  {}
func (actionWithPrismaIDEqualsParam) equals() {}

type actionWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaIDEqualsUniqueParam) actionModel() {}
func (p actionWithPrismaIDEqualsUniqueParam) idField()     {}

func (actionWithPrismaIDEqualsUniqueParam) unique() {}
func (actionWithPrismaIDEqualsUniqueParam) equals() {}

type ActionWithPrismaInputEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	actionModel()
	inputField()
}

type ActionWithPrismaInputSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	inputField()
}

type actionWithPrismaInputSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaInputSetParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaInputSetParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaInputSetParam) actionModel() {}

func (p actionWithPrismaInputSetParam) inputField() {}

type ActionWithPrismaInputWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	inputField()
}

type actionWithPrismaInputEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaInputEqualsParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaInputEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaInputEqualsParam) actionModel() {}

func (p actionWithPrismaInputEqualsParam) inputField() {}

func (actionWithPrismaInputSetParam) settable()  {}
func (actionWithPrismaInputEqualsParam) equals() {}

type actionWithPrismaInputEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaInputEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaInputEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaInputEqualsUniqueParam) actionModel() {}
func (p actionWithPrismaInputEqualsUniqueParam) inputField()  {}

func (actionWithPrismaInputEqualsUniqueParam) unique() {}
func (actionWithPrismaInputEqualsUniqueParam) equals() {}

type ActionWithPrismaOutputEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	actionModel()
	outputField()
}

type ActionWithPrismaOutputSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	outputField()
}

type actionWithPrismaOutputSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaOutputSetParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaOutputSetParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaOutputSetParam) actionModel() {}

func (p actionWithPrismaOutputSetParam) outputField() {}

type ActionWithPrismaOutputWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	outputField()
}

type actionWithPrismaOutputEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaOutputEqualsParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaOutputEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaOutputEqualsParam) actionModel() {}

func (p actionWithPrismaOutputEqualsParam) outputField() {}

func (actionWithPrismaOutputSetParam) settable()  {}
func (actionWithPrismaOutputEqualsParam) equals() {}

type actionWithPrismaOutputEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaOutputEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaOutputEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaOutputEqualsUniqueParam) actionModel() {}
func (p actionWithPrismaOutputEqualsUniqueParam) outputField() {}

func (actionWithPrismaOutputEqualsUniqueParam) unique() {}
func (actionWithPrismaOutputEqualsUniqueParam) equals() {}

type ActionWithPrismaDeviceEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	actionModel()
	deviceField()
}

type ActionWithPrismaDeviceSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	deviceField()
}

type actionWithPrismaDeviceSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaDeviceSetParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaDeviceSetParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaDeviceSetParam) actionModel() {}

func (p actionWithPrismaDeviceSetParam) deviceField() {}

type ActionWithPrismaDeviceWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	deviceField()
}

type actionWithPrismaDeviceEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaDeviceEqualsParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaDeviceEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaDeviceEqualsParam) actionModel() {}

func (p actionWithPrismaDeviceEqualsParam) deviceField() {}

func (actionWithPrismaDeviceSetParam) settable()  {}
func (actionWithPrismaDeviceEqualsParam) equals() {}

type actionWithPrismaDeviceEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaDeviceEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaDeviceEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaDeviceEqualsUniqueParam) actionModel() {}
func (p actionWithPrismaDeviceEqualsUniqueParam) deviceField() {}

func (actionWithPrismaDeviceEqualsUniqueParam) unique() {}
func (actionWithPrismaDeviceEqualsUniqueParam) equals() {}

type ActionWithPrismaDeviceIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	actionModel()
	deviceIDField()
}

type ActionWithPrismaDeviceIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	deviceIDField()
}

type actionWithPrismaDeviceIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaDeviceIDSetParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaDeviceIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaDeviceIDSetParam) actionModel() {}

func (p actionWithPrismaDeviceIDSetParam) deviceIDField() {}

type ActionWithPrismaDeviceIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	deviceIDField()
}

type actionWithPrismaDeviceIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaDeviceIDEqualsParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaDeviceIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaDeviceIDEqualsParam) actionModel() {}

func (p actionWithPrismaDeviceIDEqualsParam) deviceIDField() {}

func (actionWithPrismaDeviceIDSetParam) settable()  {}
func (actionWithPrismaDeviceIDEqualsParam) equals() {}

type actionWithPrismaDeviceIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaDeviceIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaDeviceIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaDeviceIDEqualsUniqueParam) actionModel()   {}
func (p actionWithPrismaDeviceIDEqualsUniqueParam) deviceIDField() {}

func (actionWithPrismaDeviceIDEqualsUniqueParam) unique() {}
func (actionWithPrismaDeviceIDEqualsUniqueParam) equals() {}

type ActionWithPrismaEventEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	actionModel()
	eventField()
}

type ActionWithPrismaEventSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	eventField()
}

type actionWithPrismaEventSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaEventSetParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaEventSetParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaEventSetParam) actionModel() {}

func (p actionWithPrismaEventSetParam) eventField() {}

type ActionWithPrismaEventWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	eventField()
}

type actionWithPrismaEventEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaEventEqualsParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaEventEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaEventEqualsParam) actionModel() {}

func (p actionWithPrismaEventEqualsParam) eventField() {}

func (actionWithPrismaEventSetParam) settable()  {}
func (actionWithPrismaEventEqualsParam) equals() {}

type actionWithPrismaEventEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaEventEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaEventEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaEventEqualsUniqueParam) actionModel() {}
func (p actionWithPrismaEventEqualsUniqueParam) eventField()  {}

func (actionWithPrismaEventEqualsUniqueParam) unique() {}
func (actionWithPrismaEventEqualsUniqueParam) equals() {}

type ActionWithPrismaEventIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	actionModel()
	eventIDField()
}

type ActionWithPrismaEventIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	eventIDField()
}

type actionWithPrismaEventIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaEventIDSetParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaEventIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaEventIDSetParam) actionModel() {}

func (p actionWithPrismaEventIDSetParam) eventIDField() {}

type ActionWithPrismaEventIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	eventIDField()
}

type actionWithPrismaEventIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaEventIDEqualsParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaEventIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaEventIDEqualsParam) actionModel() {}

func (p actionWithPrismaEventIDEqualsParam) eventIDField() {}

func (actionWithPrismaEventIDSetParam) settable()  {}
func (actionWithPrismaEventIDEqualsParam) equals() {}

type actionWithPrismaEventIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaEventIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaEventIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaEventIDEqualsUniqueParam) actionModel()  {}
func (p actionWithPrismaEventIDEqualsUniqueParam) eventIDField() {}

func (actionWithPrismaEventIDEqualsUniqueParam) unique() {}
func (actionWithPrismaEventIDEqualsUniqueParam) equals() {}

type ActionWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	actionModel()
	createdAtField()
}

type ActionWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	createdAtField()
}

type actionWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaCreatedAtSetParam) actionModel() {}

func (p actionWithPrismaCreatedAtSetParam) createdAtField() {}

type ActionWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	createdAtField()
}

type actionWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaCreatedAtEqualsParam) actionModel() {}

func (p actionWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (actionWithPrismaCreatedAtSetParam) settable()  {}
func (actionWithPrismaCreatedAtEqualsParam) equals() {}

type actionWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaCreatedAtEqualsUniqueParam) actionModel()    {}
func (p actionWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (actionWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (actionWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type ActionWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	actionModel()
	updatedAtField()
}

type ActionWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	updatedAtField()
}

type actionWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaUpdatedAtSetParam) actionModel() {}

func (p actionWithPrismaUpdatedAtSetParam) updatedAtField() {}

type ActionWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	updatedAtField()
}

type actionWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaUpdatedAtEqualsParam) actionModel() {}

func (p actionWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (actionWithPrismaUpdatedAtSetParam) settable()  {}
func (actionWithPrismaUpdatedAtEqualsParam) equals() {}

type actionWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaUpdatedAtEqualsUniqueParam) actionModel()    {}
func (p actionWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (actionWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (actionWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type ActionWithPrismaConstantsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	actionModel()
	constantsField()
}

type ActionWithPrismaConstantsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	constantsField()
}

type actionWithPrismaConstantsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaConstantsSetParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaConstantsSetParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaConstantsSetParam) actionModel() {}

func (p actionWithPrismaConstantsSetParam) constantsField() {}

type ActionWithPrismaConstantsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	constantsField()
}

type actionWithPrismaConstantsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaConstantsEqualsParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaConstantsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaConstantsEqualsParam) actionModel() {}

func (p actionWithPrismaConstantsEqualsParam) constantsField() {}

func (actionWithPrismaConstantsSetParam) settable()  {}
func (actionWithPrismaConstantsEqualsParam) equals() {}

type actionWithPrismaConstantsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaConstantsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaConstantsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaConstantsEqualsUniqueParam) actionModel()    {}
func (p actionWithPrismaConstantsEqualsUniqueParam) constantsField() {}

func (actionWithPrismaConstantsEqualsUniqueParam) unique() {}
func (actionWithPrismaConstantsEqualsUniqueParam) equals() {}

type ActionWithPrismaStepsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	actionModel()
	stepsField()
}

type ActionWithPrismaStepsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	stepsField()
}

type actionWithPrismaStepsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaStepsSetParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaStepsSetParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaStepsSetParam) actionModel() {}

func (p actionWithPrismaStepsSetParam) stepsField() {}

type ActionWithPrismaStepsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	actionModel()
	stepsField()
}

type actionWithPrismaStepsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaStepsEqualsParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaStepsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaStepsEqualsParam) actionModel() {}

func (p actionWithPrismaStepsEqualsParam) stepsField() {}

func (actionWithPrismaStepsSetParam) settable()  {}
func (actionWithPrismaStepsEqualsParam) equals() {}

type actionWithPrismaStepsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p actionWithPrismaStepsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p actionWithPrismaStepsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p actionWithPrismaStepsEqualsUniqueParam) actionModel() {}
func (p actionWithPrismaStepsEqualsUniqueParam) stepsField()  {}

func (actionWithPrismaStepsEqualsUniqueParam) unique() {}
func (actionWithPrismaStepsEqualsUniqueParam) equals() {}

type stepActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var stepOutput = []builder.Output{
	{Name: "id"},
	{Name: "order"},
	{Name: "runID"},
	{Name: "actionID"},
}

type StepRelationWith interface {
	getQuery() builder.Query
	with()
	stepRelation()
}

type StepWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	stepModel()
}

type stepDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepDefaultParam) field() builder.Field {
	return p.data
}

func (p stepDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p stepDefaultParam) stepModel() {}

type StepOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	stepModel()
}

type stepOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepOrderByParam) field() builder.Field {
	return p.data
}

func (p stepOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p stepOrderByParam) stepModel() {}

type StepCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	stepModel()
	isCursor()
}

type stepCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepCursorParam) field() builder.Field {
	return p.data
}

func (p stepCursorParam) isCursor() {}

func (p stepCursorParam) getQuery() builder.Query {
	return p.query
}

func (p stepCursorParam) stepModel() {}

type StepParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	stepModel()
}

type stepParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p stepParamUnique) stepModel() {}

func (stepParamUnique) unique() {}

func (p stepParamUnique) field() builder.Field {
	return p.data
}

func (p stepParamUnique) getQuery() builder.Query {
	return p.query
}

type StepEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	stepModel()
}

type stepEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepEqualsParam) stepModel() {}

func (stepEqualsParam) equals() {}

func (p stepEqualsParam) field() builder.Field {
	return p.data
}

func (p stepEqualsParam) getQuery() builder.Query {
	return p.query
}

type StepEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	stepModel()
}

type stepEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepEqualsUniqueParam) stepModel() {}

func (stepEqualsUniqueParam) unique() {}
func (stepEqualsUniqueParam) equals() {}

func (p stepEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p stepEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type StepSetParam interface {
	field() builder.Field
	settable()
	stepModel()
}

type stepSetParam struct {
	data builder.Field
}

func (stepSetParam) settable() {}

func (p stepSetParam) field() builder.Field {
	return p.data
}

func (p stepSetParam) stepModel() {}

type StepWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	stepModel()
	idField()
}

type StepWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	stepModel()
	idField()
}

type stepWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaIDSetParam) stepModel() {}

func (p stepWithPrismaIDSetParam) idField() {}

type StepWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	stepModel()
	idField()
}

type stepWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaIDEqualsParam) stepModel() {}

func (p stepWithPrismaIDEqualsParam) idField() {}

func (stepWithPrismaIDSetParam) settable()  {}
func (stepWithPrismaIDEqualsParam) equals() {}

type stepWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaIDEqualsUniqueParam) stepModel() {}
func (p stepWithPrismaIDEqualsUniqueParam) idField()   {}

func (stepWithPrismaIDEqualsUniqueParam) unique() {}
func (stepWithPrismaIDEqualsUniqueParam) equals() {}

type StepWithPrismaOrderEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	stepModel()
	orderField()
}

type StepWithPrismaOrderSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	stepModel()
	orderField()
}

type stepWithPrismaOrderSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaOrderSetParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaOrderSetParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaOrderSetParam) stepModel() {}

func (p stepWithPrismaOrderSetParam) orderField() {}

type StepWithPrismaOrderWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	stepModel()
	orderField()
}

type stepWithPrismaOrderEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaOrderEqualsParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaOrderEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaOrderEqualsParam) stepModel() {}

func (p stepWithPrismaOrderEqualsParam) orderField() {}

func (stepWithPrismaOrderSetParam) settable()  {}
func (stepWithPrismaOrderEqualsParam) equals() {}

type stepWithPrismaOrderEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaOrderEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaOrderEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaOrderEqualsUniqueParam) stepModel()  {}
func (p stepWithPrismaOrderEqualsUniqueParam) orderField() {}

func (stepWithPrismaOrderEqualsUniqueParam) unique() {}
func (stepWithPrismaOrderEqualsUniqueParam) equals() {}

type StepWithPrismaRunEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	stepModel()
	runField()
}

type StepWithPrismaRunSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	stepModel()
	runField()
}

type stepWithPrismaRunSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaRunSetParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaRunSetParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaRunSetParam) stepModel() {}

func (p stepWithPrismaRunSetParam) runField() {}

type StepWithPrismaRunWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	stepModel()
	runField()
}

type stepWithPrismaRunEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaRunEqualsParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaRunEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaRunEqualsParam) stepModel() {}

func (p stepWithPrismaRunEqualsParam) runField() {}

func (stepWithPrismaRunSetParam) settable()  {}
func (stepWithPrismaRunEqualsParam) equals() {}

type stepWithPrismaRunEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaRunEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaRunEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaRunEqualsUniqueParam) stepModel() {}
func (p stepWithPrismaRunEqualsUniqueParam) runField()  {}

func (stepWithPrismaRunEqualsUniqueParam) unique() {}
func (stepWithPrismaRunEqualsUniqueParam) equals() {}

type StepWithPrismaRunIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	stepModel()
	runIDField()
}

type StepWithPrismaRunIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	stepModel()
	runIDField()
}

type stepWithPrismaRunIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaRunIDSetParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaRunIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaRunIDSetParam) stepModel() {}

func (p stepWithPrismaRunIDSetParam) runIDField() {}

type StepWithPrismaRunIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	stepModel()
	runIDField()
}

type stepWithPrismaRunIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaRunIDEqualsParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaRunIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaRunIDEqualsParam) stepModel() {}

func (p stepWithPrismaRunIDEqualsParam) runIDField() {}

func (stepWithPrismaRunIDSetParam) settable()  {}
func (stepWithPrismaRunIDEqualsParam) equals() {}

type stepWithPrismaRunIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaRunIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaRunIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaRunIDEqualsUniqueParam) stepModel()  {}
func (p stepWithPrismaRunIDEqualsUniqueParam) runIDField() {}

func (stepWithPrismaRunIDEqualsUniqueParam) unique() {}
func (stepWithPrismaRunIDEqualsUniqueParam) equals() {}

type StepWithPrismaActionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	stepModel()
	actionField()
}

type StepWithPrismaActionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	stepModel()
	actionField()
}

type stepWithPrismaActionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaActionSetParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaActionSetParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaActionSetParam) stepModel() {}

func (p stepWithPrismaActionSetParam) actionField() {}

type StepWithPrismaActionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	stepModel()
	actionField()
}

type stepWithPrismaActionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaActionEqualsParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaActionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaActionEqualsParam) stepModel() {}

func (p stepWithPrismaActionEqualsParam) actionField() {}

func (stepWithPrismaActionSetParam) settable()  {}
func (stepWithPrismaActionEqualsParam) equals() {}

type stepWithPrismaActionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaActionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaActionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaActionEqualsUniqueParam) stepModel()   {}
func (p stepWithPrismaActionEqualsUniqueParam) actionField() {}

func (stepWithPrismaActionEqualsUniqueParam) unique() {}
func (stepWithPrismaActionEqualsUniqueParam) equals() {}

type StepWithPrismaActionIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	stepModel()
	actionIDField()
}

type StepWithPrismaActionIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	stepModel()
	actionIDField()
}

type stepWithPrismaActionIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaActionIDSetParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaActionIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaActionIDSetParam) stepModel() {}

func (p stepWithPrismaActionIDSetParam) actionIDField() {}

type StepWithPrismaActionIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	stepModel()
	actionIDField()
}

type stepWithPrismaActionIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaActionIDEqualsParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaActionIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaActionIDEqualsParam) stepModel() {}

func (p stepWithPrismaActionIDEqualsParam) actionIDField() {}

func (stepWithPrismaActionIDSetParam) settable()  {}
func (stepWithPrismaActionIDEqualsParam) equals() {}

type stepWithPrismaActionIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p stepWithPrismaActionIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p stepWithPrismaActionIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p stepWithPrismaActionIDEqualsUniqueParam) stepModel()     {}
func (p stepWithPrismaActionIDEqualsUniqueParam) actionIDField() {}

func (stepWithPrismaActionIDEqualsUniqueParam) unique() {}
func (stepWithPrismaActionIDEqualsUniqueParam) equals() {}

type runActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var runOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
	{Name: "description"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "netID"},
}

type RunRelationWith interface {
	getQuery() builder.Query
	with()
	runRelation()
}

type RunWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
}

type runDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p runDefaultParam) field() builder.Field {
	return p.data
}

func (p runDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p runDefaultParam) runModel() {}

type RunOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
}

type runOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p runOrderByParam) field() builder.Field {
	return p.data
}

func (p runOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p runOrderByParam) runModel() {}

type RunCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	isCursor()
}

type runCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p runCursorParam) field() builder.Field {
	return p.data
}

func (p runCursorParam) isCursor() {}

func (p runCursorParam) getQuery() builder.Query {
	return p.query
}

func (p runCursorParam) runModel() {}

type RunParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	runModel()
}

type runParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p runParamUnique) runModel() {}

func (runParamUnique) unique() {}

func (p runParamUnique) field() builder.Field {
	return p.data
}

func (p runParamUnique) getQuery() builder.Query {
	return p.query
}

type RunEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	runModel()
}

type runEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p runEqualsParam) runModel() {}

func (runEqualsParam) equals() {}

func (p runEqualsParam) field() builder.Field {
	return p.data
}

func (p runEqualsParam) getQuery() builder.Query {
	return p.query
}

type RunEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	runModel()
}

type runEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p runEqualsUniqueParam) runModel() {}

func (runEqualsUniqueParam) unique() {}
func (runEqualsUniqueParam) equals() {}

func (p runEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p runEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type RunSetParam interface {
	field() builder.Field
	settable()
	runModel()
}

type runSetParam struct {
	data builder.Field
}

func (runSetParam) settable() {}

func (p runSetParam) field() builder.Field {
	return p.data
}

func (p runSetParam) runModel() {}

type RunWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	runModel()
	idField()
}

type RunWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	idField()
}

type runWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaIDSetParam) runModel() {}

func (p runWithPrismaIDSetParam) idField() {}

type RunWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	idField()
}

type runWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaIDEqualsParam) runModel() {}

func (p runWithPrismaIDEqualsParam) idField() {}

func (runWithPrismaIDSetParam) settable()  {}
func (runWithPrismaIDEqualsParam) equals() {}

type runWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaIDEqualsUniqueParam) runModel() {}
func (p runWithPrismaIDEqualsUniqueParam) idField()  {}

func (runWithPrismaIDEqualsUniqueParam) unique() {}
func (runWithPrismaIDEqualsUniqueParam) equals() {}

type RunWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	runModel()
	nameField()
}

type RunWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	nameField()
}

type runWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaNameSetParam) runModel() {}

func (p runWithPrismaNameSetParam) nameField() {}

type RunWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	nameField()
}

type runWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaNameEqualsParam) runModel() {}

func (p runWithPrismaNameEqualsParam) nameField() {}

func (runWithPrismaNameSetParam) settable()  {}
func (runWithPrismaNameEqualsParam) equals() {}

type runWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaNameEqualsUniqueParam) runModel()  {}
func (p runWithPrismaNameEqualsUniqueParam) nameField() {}

func (runWithPrismaNameEqualsUniqueParam) unique() {}
func (runWithPrismaNameEqualsUniqueParam) equals() {}

type RunWithPrismaDescriptionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	runModel()
	descriptionField()
}

type RunWithPrismaDescriptionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	descriptionField()
}

type runWithPrismaDescriptionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaDescriptionSetParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaDescriptionSetParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaDescriptionSetParam) runModel() {}

func (p runWithPrismaDescriptionSetParam) descriptionField() {}

type RunWithPrismaDescriptionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	descriptionField()
}

type runWithPrismaDescriptionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaDescriptionEqualsParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaDescriptionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaDescriptionEqualsParam) runModel() {}

func (p runWithPrismaDescriptionEqualsParam) descriptionField() {}

func (runWithPrismaDescriptionSetParam) settable()  {}
func (runWithPrismaDescriptionEqualsParam) equals() {}

type runWithPrismaDescriptionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaDescriptionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaDescriptionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaDescriptionEqualsUniqueParam) runModel()         {}
func (p runWithPrismaDescriptionEqualsUniqueParam) descriptionField() {}

func (runWithPrismaDescriptionEqualsUniqueParam) unique() {}
func (runWithPrismaDescriptionEqualsUniqueParam) equals() {}

type RunWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	runModel()
	createdAtField()
}

type RunWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	createdAtField()
}

type runWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaCreatedAtSetParam) runModel() {}

func (p runWithPrismaCreatedAtSetParam) createdAtField() {}

type RunWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	createdAtField()
}

type runWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaCreatedAtEqualsParam) runModel() {}

func (p runWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (runWithPrismaCreatedAtSetParam) settable()  {}
func (runWithPrismaCreatedAtEqualsParam) equals() {}

type runWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaCreatedAtEqualsUniqueParam) runModel()       {}
func (p runWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (runWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (runWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type RunWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	runModel()
	updatedAtField()
}

type RunWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	updatedAtField()
}

type runWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaUpdatedAtSetParam) runModel() {}

func (p runWithPrismaUpdatedAtSetParam) updatedAtField() {}

type RunWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	updatedAtField()
}

type runWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaUpdatedAtEqualsParam) runModel() {}

func (p runWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (runWithPrismaUpdatedAtSetParam) settable()  {}
func (runWithPrismaUpdatedAtEqualsParam) equals() {}

type runWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaUpdatedAtEqualsUniqueParam) runModel()       {}
func (p runWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (runWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (runWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type RunWithPrismaNetEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	runModel()
	netField()
}

type RunWithPrismaNetSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	netField()
}

type runWithPrismaNetSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaNetSetParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaNetSetParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaNetSetParam) runModel() {}

func (p runWithPrismaNetSetParam) netField() {}

type RunWithPrismaNetWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	netField()
}

type runWithPrismaNetEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaNetEqualsParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaNetEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaNetEqualsParam) runModel() {}

func (p runWithPrismaNetEqualsParam) netField() {}

func (runWithPrismaNetSetParam) settable()  {}
func (runWithPrismaNetEqualsParam) equals() {}

type runWithPrismaNetEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaNetEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaNetEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaNetEqualsUniqueParam) runModel() {}
func (p runWithPrismaNetEqualsUniqueParam) netField() {}

func (runWithPrismaNetEqualsUniqueParam) unique() {}
func (runWithPrismaNetEqualsUniqueParam) equals() {}

type RunWithPrismaNetIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	runModel()
	netIDField()
}

type RunWithPrismaNetIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	netIDField()
}

type runWithPrismaNetIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaNetIDSetParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaNetIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaNetIDSetParam) runModel() {}

func (p runWithPrismaNetIDSetParam) netIDField() {}

type RunWithPrismaNetIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	netIDField()
}

type runWithPrismaNetIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaNetIDEqualsParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaNetIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaNetIDEqualsParam) runModel() {}

func (p runWithPrismaNetIDEqualsParam) netIDField() {}

func (runWithPrismaNetIDSetParam) settable()  {}
func (runWithPrismaNetIDEqualsParam) equals() {}

type runWithPrismaNetIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaNetIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaNetIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaNetIDEqualsUniqueParam) runModel()   {}
func (p runWithPrismaNetIDEqualsUniqueParam) netIDField() {}

func (runWithPrismaNetIDEqualsUniqueParam) unique() {}
func (runWithPrismaNetIDEqualsUniqueParam) equals() {}

type RunWithPrismaSessionsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	runModel()
	sessionsField()
}

type RunWithPrismaSessionsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	sessionsField()
}

type runWithPrismaSessionsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaSessionsSetParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaSessionsSetParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaSessionsSetParam) runModel() {}

func (p runWithPrismaSessionsSetParam) sessionsField() {}

type RunWithPrismaSessionsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	sessionsField()
}

type runWithPrismaSessionsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaSessionsEqualsParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaSessionsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaSessionsEqualsParam) runModel() {}

func (p runWithPrismaSessionsEqualsParam) sessionsField() {}

func (runWithPrismaSessionsSetParam) settable()  {}
func (runWithPrismaSessionsEqualsParam) equals() {}

type runWithPrismaSessionsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaSessionsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaSessionsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaSessionsEqualsUniqueParam) runModel()      {}
func (p runWithPrismaSessionsEqualsUniqueParam) sessionsField() {}

func (runWithPrismaSessionsEqualsUniqueParam) unique() {}
func (runWithPrismaSessionsEqualsUniqueParam) equals() {}

type RunWithPrismaStepsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	runModel()
	stepsField()
}

type RunWithPrismaStepsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	stepsField()
}

type runWithPrismaStepsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaStepsSetParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaStepsSetParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaStepsSetParam) runModel() {}

func (p runWithPrismaStepsSetParam) stepsField() {}

type RunWithPrismaStepsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	runModel()
	stepsField()
}

type runWithPrismaStepsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaStepsEqualsParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaStepsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaStepsEqualsParam) runModel() {}

func (p runWithPrismaStepsEqualsParam) stepsField() {}

func (runWithPrismaStepsSetParam) settable()  {}
func (runWithPrismaStepsEqualsParam) equals() {}

type runWithPrismaStepsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p runWithPrismaStepsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p runWithPrismaStepsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p runWithPrismaStepsEqualsUniqueParam) runModel()   {}
func (p runWithPrismaStepsEqualsUniqueParam) stepsField() {}

func (runWithPrismaStepsEqualsUniqueParam) unique() {}
func (runWithPrismaStepsEqualsUniqueParam) equals() {}

type datumActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var datumOutput = []builder.Output{
	{Name: "id"},
	{Name: "instanceID"},
	{Name: "sessionID"},
	{Name: "value"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "eventId"},
}

type DatumRelationWith interface {
	getQuery() builder.Query
	with()
	datumRelation()
}

type DatumWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
}

type datumDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumDefaultParam) field() builder.Field {
	return p.data
}

func (p datumDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p datumDefaultParam) datumModel() {}

type DatumOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
}

type datumOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumOrderByParam) field() builder.Field {
	return p.data
}

func (p datumOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p datumOrderByParam) datumModel() {}

type DatumCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	isCursor()
}

type datumCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumCursorParam) field() builder.Field {
	return p.data
}

func (p datumCursorParam) isCursor() {}

func (p datumCursorParam) getQuery() builder.Query {
	return p.query
}

func (p datumCursorParam) datumModel() {}

type DatumParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	datumModel()
}

type datumParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p datumParamUnique) datumModel() {}

func (datumParamUnique) unique() {}

func (p datumParamUnique) field() builder.Field {
	return p.data
}

func (p datumParamUnique) getQuery() builder.Query {
	return p.query
}

type DatumEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	datumModel()
}

type datumEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumEqualsParam) datumModel() {}

func (datumEqualsParam) equals() {}

func (p datumEqualsParam) field() builder.Field {
	return p.data
}

func (p datumEqualsParam) getQuery() builder.Query {
	return p.query
}

type DatumEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	datumModel()
}

type datumEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumEqualsUniqueParam) datumModel() {}

func (datumEqualsUniqueParam) unique() {}
func (datumEqualsUniqueParam) equals() {}

func (p datumEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p datumEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type DatumSetParam interface {
	field() builder.Field
	settable()
	datumModel()
}

type datumSetParam struct {
	data builder.Field
}

func (datumSetParam) settable() {}

func (p datumSetParam) field() builder.Field {
	return p.data
}

func (p datumSetParam) datumModel() {}

type DatumWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	datumModel()
	idField()
}

type DatumWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	idField()
}

type datumWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaIDSetParam) datumModel() {}

func (p datumWithPrismaIDSetParam) idField() {}

type DatumWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	idField()
}

type datumWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaIDEqualsParam) datumModel() {}

func (p datumWithPrismaIDEqualsParam) idField() {}

func (datumWithPrismaIDSetParam) settable()  {}
func (datumWithPrismaIDEqualsParam) equals() {}

type datumWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaIDEqualsUniqueParam) datumModel() {}
func (p datumWithPrismaIDEqualsUniqueParam) idField()    {}

func (datumWithPrismaIDEqualsUniqueParam) unique() {}
func (datumWithPrismaIDEqualsUniqueParam) equals() {}

type DatumWithPrismaInstanceEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	datumModel()
	instanceField()
}

type DatumWithPrismaInstanceSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	instanceField()
}

type datumWithPrismaInstanceSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaInstanceSetParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaInstanceSetParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaInstanceSetParam) datumModel() {}

func (p datumWithPrismaInstanceSetParam) instanceField() {}

type DatumWithPrismaInstanceWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	instanceField()
}

type datumWithPrismaInstanceEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaInstanceEqualsParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaInstanceEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaInstanceEqualsParam) datumModel() {}

func (p datumWithPrismaInstanceEqualsParam) instanceField() {}

func (datumWithPrismaInstanceSetParam) settable()  {}
func (datumWithPrismaInstanceEqualsParam) equals() {}

type datumWithPrismaInstanceEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaInstanceEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaInstanceEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaInstanceEqualsUniqueParam) datumModel()    {}
func (p datumWithPrismaInstanceEqualsUniqueParam) instanceField() {}

func (datumWithPrismaInstanceEqualsUniqueParam) unique() {}
func (datumWithPrismaInstanceEqualsUniqueParam) equals() {}

type DatumWithPrismaInstanceIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	datumModel()
	instanceIDField()
}

type DatumWithPrismaInstanceIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	instanceIDField()
}

type datumWithPrismaInstanceIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaInstanceIDSetParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaInstanceIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaInstanceIDSetParam) datumModel() {}

func (p datumWithPrismaInstanceIDSetParam) instanceIDField() {}

type DatumWithPrismaInstanceIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	instanceIDField()
}

type datumWithPrismaInstanceIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaInstanceIDEqualsParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaInstanceIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaInstanceIDEqualsParam) datumModel() {}

func (p datumWithPrismaInstanceIDEqualsParam) instanceIDField() {}

func (datumWithPrismaInstanceIDSetParam) settable()  {}
func (datumWithPrismaInstanceIDEqualsParam) equals() {}

type datumWithPrismaInstanceIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaInstanceIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaInstanceIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaInstanceIDEqualsUniqueParam) datumModel()      {}
func (p datumWithPrismaInstanceIDEqualsUniqueParam) instanceIDField() {}

func (datumWithPrismaInstanceIDEqualsUniqueParam) unique() {}
func (datumWithPrismaInstanceIDEqualsUniqueParam) equals() {}

type DatumWithPrismaSessionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	datumModel()
	sessionField()
}

type DatumWithPrismaSessionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	sessionField()
}

type datumWithPrismaSessionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaSessionSetParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaSessionSetParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaSessionSetParam) datumModel() {}

func (p datumWithPrismaSessionSetParam) sessionField() {}

type DatumWithPrismaSessionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	sessionField()
}

type datumWithPrismaSessionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaSessionEqualsParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaSessionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaSessionEqualsParam) datumModel() {}

func (p datumWithPrismaSessionEqualsParam) sessionField() {}

func (datumWithPrismaSessionSetParam) settable()  {}
func (datumWithPrismaSessionEqualsParam) equals() {}

type datumWithPrismaSessionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaSessionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaSessionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaSessionEqualsUniqueParam) datumModel()   {}
func (p datumWithPrismaSessionEqualsUniqueParam) sessionField() {}

func (datumWithPrismaSessionEqualsUniqueParam) unique() {}
func (datumWithPrismaSessionEqualsUniqueParam) equals() {}

type DatumWithPrismaSessionIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	datumModel()
	sessionIDField()
}

type DatumWithPrismaSessionIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	sessionIDField()
}

type datumWithPrismaSessionIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaSessionIDSetParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaSessionIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaSessionIDSetParam) datumModel() {}

func (p datumWithPrismaSessionIDSetParam) sessionIDField() {}

type DatumWithPrismaSessionIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	sessionIDField()
}

type datumWithPrismaSessionIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaSessionIDEqualsParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaSessionIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaSessionIDEqualsParam) datumModel() {}

func (p datumWithPrismaSessionIDEqualsParam) sessionIDField() {}

func (datumWithPrismaSessionIDSetParam) settable()  {}
func (datumWithPrismaSessionIDEqualsParam) equals() {}

type datumWithPrismaSessionIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaSessionIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaSessionIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaSessionIDEqualsUniqueParam) datumModel()     {}
func (p datumWithPrismaSessionIDEqualsUniqueParam) sessionIDField() {}

func (datumWithPrismaSessionIDEqualsUniqueParam) unique() {}
func (datumWithPrismaSessionIDEqualsUniqueParam) equals() {}

type DatumWithPrismaValueEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	datumModel()
	valueField()
}

type DatumWithPrismaValueSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	valueField()
}

type datumWithPrismaValueSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaValueSetParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaValueSetParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaValueSetParam) datumModel() {}

func (p datumWithPrismaValueSetParam) valueField() {}

type DatumWithPrismaValueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	valueField()
}

type datumWithPrismaValueEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaValueEqualsParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaValueEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaValueEqualsParam) datumModel() {}

func (p datumWithPrismaValueEqualsParam) valueField() {}

func (datumWithPrismaValueSetParam) settable()  {}
func (datumWithPrismaValueEqualsParam) equals() {}

type datumWithPrismaValueEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaValueEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaValueEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaValueEqualsUniqueParam) datumModel() {}
func (p datumWithPrismaValueEqualsUniqueParam) valueField() {}

func (datumWithPrismaValueEqualsUniqueParam) unique() {}
func (datumWithPrismaValueEqualsUniqueParam) equals() {}

type DatumWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	datumModel()
	createdAtField()
}

type DatumWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	createdAtField()
}

type datumWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaCreatedAtSetParam) datumModel() {}

func (p datumWithPrismaCreatedAtSetParam) createdAtField() {}

type DatumWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	createdAtField()
}

type datumWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaCreatedAtEqualsParam) datumModel() {}

func (p datumWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (datumWithPrismaCreatedAtSetParam) settable()  {}
func (datumWithPrismaCreatedAtEqualsParam) equals() {}

type datumWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaCreatedAtEqualsUniqueParam) datumModel()     {}
func (p datumWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (datumWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (datumWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type DatumWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	datumModel()
	updatedAtField()
}

type DatumWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	updatedAtField()
}

type datumWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaUpdatedAtSetParam) datumModel() {}

func (p datumWithPrismaUpdatedAtSetParam) updatedAtField() {}

type DatumWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	updatedAtField()
}

type datumWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaUpdatedAtEqualsParam) datumModel() {}

func (p datumWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (datumWithPrismaUpdatedAtSetParam) settable()  {}
func (datumWithPrismaUpdatedAtEqualsParam) equals() {}

type datumWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaUpdatedAtEqualsUniqueParam) datumModel()     {}
func (p datumWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (datumWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (datumWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type DatumWithPrismaEventEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	datumModel()
	eventField()
}

type DatumWithPrismaEventSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	eventField()
}

type datumWithPrismaEventSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaEventSetParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaEventSetParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaEventSetParam) datumModel() {}

func (p datumWithPrismaEventSetParam) eventField() {}

type DatumWithPrismaEventWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	eventField()
}

type datumWithPrismaEventEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaEventEqualsParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaEventEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaEventEqualsParam) datumModel() {}

func (p datumWithPrismaEventEqualsParam) eventField() {}

func (datumWithPrismaEventSetParam) settable()  {}
func (datumWithPrismaEventEqualsParam) equals() {}

type datumWithPrismaEventEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaEventEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaEventEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaEventEqualsUniqueParam) datumModel() {}
func (p datumWithPrismaEventEqualsUniqueParam) eventField() {}

func (datumWithPrismaEventEqualsUniqueParam) unique() {}
func (datumWithPrismaEventEqualsUniqueParam) equals() {}

type DatumWithPrismaEventIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	datumModel()
	eventIDField()
}

type DatumWithPrismaEventIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	eventIDField()
}

type datumWithPrismaEventIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaEventIDSetParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaEventIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaEventIDSetParam) datumModel() {}

func (p datumWithPrismaEventIDSetParam) eventIDField() {}

type DatumWithPrismaEventIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	datumModel()
	eventIDField()
}

type datumWithPrismaEventIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaEventIDEqualsParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaEventIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaEventIDEqualsParam) datumModel() {}

func (p datumWithPrismaEventIDEqualsParam) eventIDField() {}

func (datumWithPrismaEventIDSetParam) settable()  {}
func (datumWithPrismaEventIDEqualsParam) equals() {}

type datumWithPrismaEventIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p datumWithPrismaEventIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p datumWithPrismaEventIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p datumWithPrismaEventIDEqualsUniqueParam) datumModel()   {}
func (p datumWithPrismaEventIDEqualsUniqueParam) eventIDField() {}

func (datumWithPrismaEventIDEqualsUniqueParam) unique() {}
func (datumWithPrismaEventIDEqualsUniqueParam) equals() {}

type sessionActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var sessionOutput = []builder.Output{
	{Name: "id"},
	{Name: "userID"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "startedAt"},
	{Name: "stoppedAt"},
	{Name: "pausedAt"},
	{Name: "resumedAt"},
	{Name: "state"},
	{Name: "deleted"},
	{Name: "runID"},
}

type SessionRelationWith interface {
	getQuery() builder.Query
	with()
	sessionRelation()
}

type SessionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
}

type sessionDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionDefaultParam) field() builder.Field {
	return p.data
}

func (p sessionDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p sessionDefaultParam) sessionModel() {}

type SessionOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
}

type sessionOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionOrderByParam) field() builder.Field {
	return p.data
}

func (p sessionOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p sessionOrderByParam) sessionModel() {}

type SessionCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	isCursor()
}

type sessionCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionCursorParam) field() builder.Field {
	return p.data
}

func (p sessionCursorParam) isCursor() {}

func (p sessionCursorParam) getQuery() builder.Query {
	return p.query
}

func (p sessionCursorParam) sessionModel() {}

type SessionParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	sessionModel()
}

type sessionParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p sessionParamUnique) sessionModel() {}

func (sessionParamUnique) unique() {}

func (p sessionParamUnique) field() builder.Field {
	return p.data
}

func (p sessionParamUnique) getQuery() builder.Query {
	return p.query
}

type SessionEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	sessionModel()
}

type sessionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionEqualsParam) sessionModel() {}

func (sessionEqualsParam) equals() {}

func (p sessionEqualsParam) field() builder.Field {
	return p.data
}

func (p sessionEqualsParam) getQuery() builder.Query {
	return p.query
}

type SessionEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	sessionModel()
}

type sessionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionEqualsUniqueParam) sessionModel() {}

func (sessionEqualsUniqueParam) unique() {}
func (sessionEqualsUniqueParam) equals() {}

func (p sessionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p sessionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type SessionSetParam interface {
	field() builder.Field
	settable()
	sessionModel()
}

type sessionSetParam struct {
	data builder.Field
}

func (sessionSetParam) settable() {}

func (p sessionSetParam) field() builder.Field {
	return p.data
}

func (p sessionSetParam) sessionModel() {}

type SessionWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	sessionModel()
	idField()
}

type SessionWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	idField()
}

type sessionWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaIDSetParam) sessionModel() {}

func (p sessionWithPrismaIDSetParam) idField() {}

type SessionWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	idField()
}

type sessionWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaIDEqualsParam) sessionModel() {}

func (p sessionWithPrismaIDEqualsParam) idField() {}

func (sessionWithPrismaIDSetParam) settable()  {}
func (sessionWithPrismaIDEqualsParam) equals() {}

type sessionWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaIDEqualsUniqueParam) sessionModel() {}
func (p sessionWithPrismaIDEqualsUniqueParam) idField()      {}

func (sessionWithPrismaIDEqualsUniqueParam) unique() {}
func (sessionWithPrismaIDEqualsUniqueParam) equals() {}

type SessionWithPrismaUserEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	sessionModel()
	userField()
}

type SessionWithPrismaUserSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	userField()
}

type sessionWithPrismaUserSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaUserSetParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaUserSetParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaUserSetParam) sessionModel() {}

func (p sessionWithPrismaUserSetParam) userField() {}

type SessionWithPrismaUserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	userField()
}

type sessionWithPrismaUserEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaUserEqualsParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaUserEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaUserEqualsParam) sessionModel() {}

func (p sessionWithPrismaUserEqualsParam) userField() {}

func (sessionWithPrismaUserSetParam) settable()  {}
func (sessionWithPrismaUserEqualsParam) equals() {}

type sessionWithPrismaUserEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaUserEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaUserEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaUserEqualsUniqueParam) sessionModel() {}
func (p sessionWithPrismaUserEqualsUniqueParam) userField()    {}

func (sessionWithPrismaUserEqualsUniqueParam) unique() {}
func (sessionWithPrismaUserEqualsUniqueParam) equals() {}

type SessionWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	sessionModel()
	userIDField()
}

type SessionWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	userIDField()
}

type sessionWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaUserIDSetParam) sessionModel() {}

func (p sessionWithPrismaUserIDSetParam) userIDField() {}

type SessionWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	userIDField()
}

type sessionWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaUserIDEqualsParam) sessionModel() {}

func (p sessionWithPrismaUserIDEqualsParam) userIDField() {}

func (sessionWithPrismaUserIDSetParam) settable()  {}
func (sessionWithPrismaUserIDEqualsParam) equals() {}

type sessionWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaUserIDEqualsUniqueParam) sessionModel() {}
func (p sessionWithPrismaUserIDEqualsUniqueParam) userIDField()  {}

func (sessionWithPrismaUserIDEqualsUniqueParam) unique() {}
func (sessionWithPrismaUserIDEqualsUniqueParam) equals() {}

type SessionWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	sessionModel()
	createdAtField()
}

type SessionWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	createdAtField()
}

type sessionWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaCreatedAtSetParam) sessionModel() {}

func (p sessionWithPrismaCreatedAtSetParam) createdAtField() {}

type SessionWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	createdAtField()
}

type sessionWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaCreatedAtEqualsParam) sessionModel() {}

func (p sessionWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (sessionWithPrismaCreatedAtSetParam) settable()  {}
func (sessionWithPrismaCreatedAtEqualsParam) equals() {}

type sessionWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaCreatedAtEqualsUniqueParam) sessionModel()   {}
func (p sessionWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (sessionWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (sessionWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type SessionWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	sessionModel()
	updatedAtField()
}

type SessionWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	updatedAtField()
}

type sessionWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaUpdatedAtSetParam) sessionModel() {}

func (p sessionWithPrismaUpdatedAtSetParam) updatedAtField() {}

type SessionWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	updatedAtField()
}

type sessionWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaUpdatedAtEqualsParam) sessionModel() {}

func (p sessionWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (sessionWithPrismaUpdatedAtSetParam) settable()  {}
func (sessionWithPrismaUpdatedAtEqualsParam) equals() {}

type sessionWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaUpdatedAtEqualsUniqueParam) sessionModel()   {}
func (p sessionWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (sessionWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (sessionWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type SessionWithPrismaStartedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	sessionModel()
	startedAtField()
}

type SessionWithPrismaStartedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	startedAtField()
}

type sessionWithPrismaStartedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaStartedAtSetParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaStartedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaStartedAtSetParam) sessionModel() {}

func (p sessionWithPrismaStartedAtSetParam) startedAtField() {}

type SessionWithPrismaStartedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	startedAtField()
}

type sessionWithPrismaStartedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaStartedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaStartedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaStartedAtEqualsParam) sessionModel() {}

func (p sessionWithPrismaStartedAtEqualsParam) startedAtField() {}

func (sessionWithPrismaStartedAtSetParam) settable()  {}
func (sessionWithPrismaStartedAtEqualsParam) equals() {}

type sessionWithPrismaStartedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaStartedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaStartedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaStartedAtEqualsUniqueParam) sessionModel()   {}
func (p sessionWithPrismaStartedAtEqualsUniqueParam) startedAtField() {}

func (sessionWithPrismaStartedAtEqualsUniqueParam) unique() {}
func (sessionWithPrismaStartedAtEqualsUniqueParam) equals() {}

type SessionWithPrismaStoppedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	sessionModel()
	stoppedAtField()
}

type SessionWithPrismaStoppedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	stoppedAtField()
}

type sessionWithPrismaStoppedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaStoppedAtSetParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaStoppedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaStoppedAtSetParam) sessionModel() {}

func (p sessionWithPrismaStoppedAtSetParam) stoppedAtField() {}

type SessionWithPrismaStoppedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	stoppedAtField()
}

type sessionWithPrismaStoppedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaStoppedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaStoppedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaStoppedAtEqualsParam) sessionModel() {}

func (p sessionWithPrismaStoppedAtEqualsParam) stoppedAtField() {}

func (sessionWithPrismaStoppedAtSetParam) settable()  {}
func (sessionWithPrismaStoppedAtEqualsParam) equals() {}

type sessionWithPrismaStoppedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaStoppedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaStoppedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaStoppedAtEqualsUniqueParam) sessionModel()   {}
func (p sessionWithPrismaStoppedAtEqualsUniqueParam) stoppedAtField() {}

func (sessionWithPrismaStoppedAtEqualsUniqueParam) unique() {}
func (sessionWithPrismaStoppedAtEqualsUniqueParam) equals() {}

type SessionWithPrismaPausedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	sessionModel()
	pausedAtField()
}

type SessionWithPrismaPausedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	pausedAtField()
}

type sessionWithPrismaPausedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaPausedAtSetParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaPausedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaPausedAtSetParam) sessionModel() {}

func (p sessionWithPrismaPausedAtSetParam) pausedAtField() {}

type SessionWithPrismaPausedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	pausedAtField()
}

type sessionWithPrismaPausedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaPausedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaPausedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaPausedAtEqualsParam) sessionModel() {}

func (p sessionWithPrismaPausedAtEqualsParam) pausedAtField() {}

func (sessionWithPrismaPausedAtSetParam) settable()  {}
func (sessionWithPrismaPausedAtEqualsParam) equals() {}

type sessionWithPrismaPausedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaPausedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaPausedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaPausedAtEqualsUniqueParam) sessionModel()  {}
func (p sessionWithPrismaPausedAtEqualsUniqueParam) pausedAtField() {}

func (sessionWithPrismaPausedAtEqualsUniqueParam) unique() {}
func (sessionWithPrismaPausedAtEqualsUniqueParam) equals() {}

type SessionWithPrismaResumedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	sessionModel()
	resumedAtField()
}

type SessionWithPrismaResumedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	resumedAtField()
}

type sessionWithPrismaResumedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaResumedAtSetParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaResumedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaResumedAtSetParam) sessionModel() {}

func (p sessionWithPrismaResumedAtSetParam) resumedAtField() {}

type SessionWithPrismaResumedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	resumedAtField()
}

type sessionWithPrismaResumedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaResumedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaResumedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaResumedAtEqualsParam) sessionModel() {}

func (p sessionWithPrismaResumedAtEqualsParam) resumedAtField() {}

func (sessionWithPrismaResumedAtSetParam) settable()  {}
func (sessionWithPrismaResumedAtEqualsParam) equals() {}

type sessionWithPrismaResumedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaResumedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaResumedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaResumedAtEqualsUniqueParam) sessionModel()   {}
func (p sessionWithPrismaResumedAtEqualsUniqueParam) resumedAtField() {}

func (sessionWithPrismaResumedAtEqualsUniqueParam) unique() {}
func (sessionWithPrismaResumedAtEqualsUniqueParam) equals() {}

type SessionWithPrismaRunEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	sessionModel()
	runField()
}

type SessionWithPrismaRunSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	runField()
}

type sessionWithPrismaRunSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaRunSetParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaRunSetParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaRunSetParam) sessionModel() {}

func (p sessionWithPrismaRunSetParam) runField() {}

type SessionWithPrismaRunWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	runField()
}

type sessionWithPrismaRunEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaRunEqualsParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaRunEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaRunEqualsParam) sessionModel() {}

func (p sessionWithPrismaRunEqualsParam) runField() {}

func (sessionWithPrismaRunSetParam) settable()  {}
func (sessionWithPrismaRunEqualsParam) equals() {}

type sessionWithPrismaRunEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaRunEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaRunEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaRunEqualsUniqueParam) sessionModel() {}
func (p sessionWithPrismaRunEqualsUniqueParam) runField()     {}

func (sessionWithPrismaRunEqualsUniqueParam) unique() {}
func (sessionWithPrismaRunEqualsUniqueParam) equals() {}

type SessionWithPrismaInstancesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	sessionModel()
	instancesField()
}

type SessionWithPrismaInstancesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	instancesField()
}

type sessionWithPrismaInstancesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaInstancesSetParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaInstancesSetParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaInstancesSetParam) sessionModel() {}

func (p sessionWithPrismaInstancesSetParam) instancesField() {}

type SessionWithPrismaInstancesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	instancesField()
}

type sessionWithPrismaInstancesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaInstancesEqualsParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaInstancesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaInstancesEqualsParam) sessionModel() {}

func (p sessionWithPrismaInstancesEqualsParam) instancesField() {}

func (sessionWithPrismaInstancesSetParam) settable()  {}
func (sessionWithPrismaInstancesEqualsParam) equals() {}

type sessionWithPrismaInstancesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaInstancesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaInstancesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaInstancesEqualsUniqueParam) sessionModel()   {}
func (p sessionWithPrismaInstancesEqualsUniqueParam) instancesField() {}

func (sessionWithPrismaInstancesEqualsUniqueParam) unique() {}
func (sessionWithPrismaInstancesEqualsUniqueParam) equals() {}

type SessionWithPrismaStateEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	sessionModel()
	stateField()
}

type SessionWithPrismaStateSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	stateField()
}

type sessionWithPrismaStateSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaStateSetParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaStateSetParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaStateSetParam) sessionModel() {}

func (p sessionWithPrismaStateSetParam) stateField() {}

type SessionWithPrismaStateWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	stateField()
}

type sessionWithPrismaStateEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaStateEqualsParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaStateEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaStateEqualsParam) sessionModel() {}

func (p sessionWithPrismaStateEqualsParam) stateField() {}

func (sessionWithPrismaStateSetParam) settable()  {}
func (sessionWithPrismaStateEqualsParam) equals() {}

type sessionWithPrismaStateEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaStateEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaStateEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaStateEqualsUniqueParam) sessionModel() {}
func (p sessionWithPrismaStateEqualsUniqueParam) stateField()   {}

func (sessionWithPrismaStateEqualsUniqueParam) unique() {}
func (sessionWithPrismaStateEqualsUniqueParam) equals() {}

type SessionWithPrismaDeletedEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	sessionModel()
	deletedField()
}

type SessionWithPrismaDeletedSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	deletedField()
}

type sessionWithPrismaDeletedSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaDeletedSetParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaDeletedSetParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaDeletedSetParam) sessionModel() {}

func (p sessionWithPrismaDeletedSetParam) deletedField() {}

type SessionWithPrismaDeletedWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	deletedField()
}

type sessionWithPrismaDeletedEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaDeletedEqualsParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaDeletedEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaDeletedEqualsParam) sessionModel() {}

func (p sessionWithPrismaDeletedEqualsParam) deletedField() {}

func (sessionWithPrismaDeletedSetParam) settable()  {}
func (sessionWithPrismaDeletedEqualsParam) equals() {}

type sessionWithPrismaDeletedEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaDeletedEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaDeletedEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaDeletedEqualsUniqueParam) sessionModel() {}
func (p sessionWithPrismaDeletedEqualsUniqueParam) deletedField() {}

func (sessionWithPrismaDeletedEqualsUniqueParam) unique() {}
func (sessionWithPrismaDeletedEqualsUniqueParam) equals() {}

type SessionWithPrismaRunIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	sessionModel()
	runIDField()
}

type SessionWithPrismaRunIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	runIDField()
}

type sessionWithPrismaRunIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaRunIDSetParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaRunIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaRunIDSetParam) sessionModel() {}

func (p sessionWithPrismaRunIDSetParam) runIDField() {}

type SessionWithPrismaRunIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	runIDField()
}

type sessionWithPrismaRunIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaRunIDEqualsParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaRunIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaRunIDEqualsParam) sessionModel() {}

func (p sessionWithPrismaRunIDEqualsParam) runIDField() {}

func (sessionWithPrismaRunIDSetParam) settable()  {}
func (sessionWithPrismaRunIDEqualsParam) equals() {}

type sessionWithPrismaRunIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaRunIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaRunIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaRunIDEqualsUniqueParam) sessionModel() {}
func (p sessionWithPrismaRunIDEqualsUniqueParam) runIDField()   {}

func (sessionWithPrismaRunIDEqualsUniqueParam) unique() {}
func (sessionWithPrismaRunIDEqualsUniqueParam) equals() {}

type SessionWithPrismaDataEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	sessionModel()
	dataField()
}

type SessionWithPrismaDataSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	dataField()
}

type sessionWithPrismaDataSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaDataSetParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaDataSetParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaDataSetParam) sessionModel() {}

func (p sessionWithPrismaDataSetParam) dataField() {}

type SessionWithPrismaDataWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	sessionModel()
	dataField()
}

type sessionWithPrismaDataEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaDataEqualsParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaDataEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaDataEqualsParam) sessionModel() {}

func (p sessionWithPrismaDataEqualsParam) dataField() {}

func (sessionWithPrismaDataSetParam) settable()  {}
func (sessionWithPrismaDataEqualsParam) equals() {}

type sessionWithPrismaDataEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p sessionWithPrismaDataEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p sessionWithPrismaDataEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p sessionWithPrismaDataEqualsUniqueParam) sessionModel() {}
func (p sessionWithPrismaDataEqualsUniqueParam) dataField()    {}

func (sessionWithPrismaDataEqualsUniqueParam) unique() {}
func (sessionWithPrismaDataEqualsUniqueParam) equals() {}
