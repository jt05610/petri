package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.42

import (
	"context"
	"fmt"

	"github.com/jt05610/petri"
	"github.com/jt05610/petri/graph/generated"
	"github.com/jt05610/petri/resolver/model"
)

// StartSession is the resolver for the startSession field.
func (r *mutationResolver) StartSession(ctx context.Context, input model.StartSessionInput) (*model.Event, error) {
	panic(fmt.Errorf("not implemented: StartSession - startSession"))
}

// NewSession is the resolver for the newSession field.
func (r *mutationResolver) NewSession(ctx context.Context, input model.NewSessionInput) (*model.Session, error) {
	panic(fmt.Errorf("not implemented: NewSession - newSession"))
}

// StopSession is the resolver for the stopSession field.
func (r *mutationResolver) StopSession(ctx context.Context, sessionID string) (*model.Session, error) {
	panic(fmt.Errorf("not implemented: StopSession - stopSession"))
}

// PauseSession is the resolver for the pauseSession field.
func (r *mutationResolver) PauseSession(ctx context.Context, sessionID string) (*model.Session, error) {
	panic(fmt.Errorf("not implemented: PauseSession - pauseSession"))
}

// ResumeSession is the resolver for the resumeSession field.
func (r *mutationResolver) ResumeSession(ctx context.Context, sessionID string) (*model.Session, error) {
	panic(fmt.Errorf("not implemented: ResumeSession - resumeSession"))
}

// CreateNet is the resolver for the createNet field.
func (r *mutationResolver) CreateNet(ctx context.Context, input petri.NetInput) (*petri.Net, error) {
	return r.nets.Add(ctx, &input)
}

// AddTokenSchemaToNet is the resolver for the addTokenSchemaToNet field.
func (r *mutationResolver) AddTokenSchemaToNet(ctx context.Context, netID string, tokenSchema petri.TokenSchemaInput) (*petri.Net, error) {
	n, err := r.nets.Get(ctx, netID)
	if err != nil {
		return nil, err
	}
	t, err := r.tokenSchema.Add(ctx, &tokenSchema)
	if err != nil {
		return nil, err
	}
	n.TokenSchemas = append(n.TokenSchemas, t)
	return r.nets.Update(ctx, netID, &petri.NetUpdate{
		Input: &petri.NetInput{
			TokenSchemas: n.TokenSchemas,
		},
		Mask: &petri.NetMask{
			TokenSchemas: true,
		},
	})
}

// AddPlaceToNet is the resolver for the addPlaceToNet field.
func (r *mutationResolver) AddPlaceToNet(ctx context.Context, netID string, place petri.PlaceInput) (*petri.Net, error) {
	n, err := r.nets.Get(ctx, netID)
	if err != nil {
		return nil, err
	}
	p, err := r.places.Add(ctx, &place)
	if err != nil {
		return nil, err
	}
	n.Places = append(n.Places, p)
	return r.nets.Update(ctx, netID, &petri.NetUpdate{
		Input: &petri.NetInput{
			Places: n.Places,
		},
		Mask: &petri.NetMask{
			Places: true,
		},
	})
}

// AddTransitionToNet is the resolver for the addTransitionToNet field.
func (r *mutationResolver) AddTransitionToNet(ctx context.Context, netID string, transition petri.TransitionInput) (*petri.Net, error) {
	n, err := r.nets.Get(ctx, netID)
	if err != nil {
		return nil, err
	}
	t, err := r.transitions.Add(ctx, &transition)
	if err != nil {
		return nil, err
	}
	n.Transitions = append(n.Transitions, t)
	return r.nets.Update(ctx, netID, &petri.NetUpdate{
		Input: &petri.NetInput{
			Transitions: n.Transitions,
		},
		Mask: &petri.NetMask{
			Transitions: true,
		},
	})
}

// AddArcToNet is the resolver for the addArcToNet field.
func (r *mutationResolver) AddArcToNet(ctx context.Context, netID string, arc petri.ArcInput) (*petri.Net, error) {
	n, err := r.nets.Get(ctx, netID)
	if err != nil {
		return nil, err
	}
	a, err := r.arcs.Add(ctx, &arc)
	if err != nil {
		return nil, err
	}
	n.Arcs = append(n.Arcs, a)
	return r.nets.Update(ctx, netID, &petri.NetUpdate{
		Input: &petri.NetInput{
			Arcs: n.Arcs,
		},
		Mask: &petri.NetMask{
			Arcs: true,
		},
	})
}

// RemoveTokenSchemaFromNet is the resolver for the removeTokenSchemaFromNet field.
func (r *mutationResolver) RemoveTokenSchemaFromNet(ctx context.Context, netID string, tokenSchemaID string) (*petri.Net, error) {
	n, err := r.nets.Get(ctx, netID)
	if err != nil {
		return nil, err
	}
	for i, tok := range n.TokenSchemas {
		if tok.ID == tokenSchemaID {
			n.TokenSchemas = append(n.TokenSchemas[:i], n.TokenSchemas[i+1:]...)
			updated, err := r.nets.Update(ctx, netID, &petri.NetUpdate{
				Input: &petri.NetInput{
					TokenSchemas: n.TokenSchemas,
				},
				Mask: &petri.NetMask{
					TokenSchemas: true,
				},
			})
			if err != nil {
				return nil, err
			}
			_, err = r.tokenSchema.Remove(ctx, tokenSchemaID)
			if err != nil {
				return nil, err
			}
			return updated, nil
		}
	}
	return nil, fmt.Errorf("token schema %s not found in net %s", tokenSchemaID, netID)
}

// RemovePlaceFromNet is the resolver for the removePlaceFromNet field.
func (r *mutationResolver) RemovePlaceFromNet(ctx context.Context, netID string, placeID string) (*petri.Net, error) {
	n, err := r.nets.Get(ctx, netID)
	if err != nil {
		return nil, err
	}
	for i, p := range n.Places {
		if p.ID == placeID {
			n.Places = append(n.Places[:i], n.Places[i+1:]...)
			updated, err := r.nets.Update(ctx, netID, &petri.NetUpdate{
				Input: &petri.NetInput{
					Places: n.Places,
				},
				Mask: &petri.NetMask{
					Places: true,
				},
			})
			if err != nil {
				return nil, err
			}
			_, err = r.places.Remove(ctx, placeID)
			if err != nil {
				return nil, err
			}
			return updated, nil
		}
	}
	return nil, fmt.Errorf("place %s not found in net %s", placeID, netID)
}

// RemoveTransitionFromNet is the resolver for the removeTransitionFromNet field.
func (r *mutationResolver) RemoveTransitionFromNet(ctx context.Context, netID string, transitionID string) (*petri.Net, error) {
	n, err := r.nets.Get(ctx, netID)
	if err != nil {
		return nil, err
	}
	for i, t := range n.Transitions {
		if t.ID == transitionID {
			n.Transitions = append(n.Transitions[:i], n.Transitions[i+1:]...)
			updated, err := r.nets.Update(ctx, netID, &petri.NetUpdate{
				Input: &petri.NetInput{
					Transitions: n.Transitions,
				},
				Mask: &petri.NetMask{
					Transitions: true,
				},
			})
			if err != nil {
				return nil, err
			}
			_, err = r.transitions.Remove(ctx, transitionID)
			if err != nil {
				return nil, err
			}
			return updated, nil
		}
	}
	return nil, fmt.Errorf("transition %s not found in net %s", transitionID, netID)
}

// RemoveArcFromNet is the resolver for the removeArcFromNet field.
func (r *mutationResolver) RemoveArcFromNet(ctx context.Context, netID string, arcID string) (*petri.Net, error) {
	n, err := r.nets.Get(ctx, netID)
	if err != nil {
		return nil, err
	}
	for i, arc := range n.Arcs {
		if arc.ID == arcID {
			n.Arcs = append(n.Arcs[:i], n.Arcs[i+1:]...)
			updated, err := r.nets.Update(ctx, netID, &petri.NetUpdate{
				Input: &petri.NetInput{
					Arcs: n.Arcs,
				},
				Mask: &petri.NetMask{
					Arcs: true,
				},
			})
			if err != nil {
				return nil, err
			}
			_, err = r.arcs.Remove(ctx, arcID)
			if err != nil {
				return nil, err
			}
			return updated, nil
		}
	}
	return nil, fmt.Errorf("arc %s not found in net %s", arcID, netID)
}

// UpdateTokenSchema is the resolver for the updateTokenSchema field.
func (r *mutationResolver) UpdateTokenSchema(ctx context.Context, id string, input petri.TokenUpdate) (*petri.TokenSchema, error) {
	return r.tokenSchema.Update(ctx, id, &input)
}

// UpdatePlace is the resolver for the updatePlace field.
func (r *mutationResolver) UpdatePlace(ctx context.Context, id string, input petri.PlaceUpdate) (*petri.Place, error) {
	return r.places.Update(ctx, id, &input)
}

// UpdateTransition is the resolver for the updateTransition field.
func (r *mutationResolver) UpdateTransition(ctx context.Context, id string, input petri.TransitionUpdate) (*petri.Transition, error) {
	return r.transitions.Update(ctx, id, &input)
}

// UpdateArc is the resolver for the updateArc field.
func (r *mutationResolver) UpdateArc(ctx context.Context, id string, input petri.ArcUpdate) (*petri.Arc, error) {
	return r.arcs.Update(ctx, id, &input)
}

// UpdateNet is the resolver for the updateNet field.
func (r *mutationResolver) UpdateNet(ctx context.Context, id string, input petri.NetUpdate) (*petri.Net, error) {
	return r.nets.Update(ctx, id, &input)
}

// DeleteNet is the resolver for the deleteNet field.
func (r *mutationResolver) DeleteNet(ctx context.Context, netID string) (*petri.Net, error) {
	return r.nets.Remove(ctx, netID)
}

// AddEventToTransition is the resolver for the addEventToTransition field.
func (r *mutationResolver) AddEventToTransition(ctx context.Context, transitionID string, event petri.EventInput) (*petri.Transition, error) {
	t, err := r.transitions.Get(ctx, transitionID)
	if err != nil {
		return nil, err
	}
	if t.Event != nil {
		return nil, fmt.Errorf("transition %s already has event %s", transitionID, t.Event.ID)
	}
	return r.transitions.Update(ctx, transitionID, &petri.TransitionUpdate{
		Input: &petri.TransitionInput{
			Event: &event,
		},
		Mask: &petri.TransitionMask{
			Event: true,
		},
	})
}

// RemoveEventFromTransition is the resolver for the removeEventFromTransition field.
func (r *mutationResolver) RemoveEventFromTransition(ctx context.Context, transitionID string, eventID string) (*petri.Transition, error) {
	t, err := r.transitions.Get(ctx, transitionID)
	if err != nil {
		return nil, err
	}
	if t.Event.ID != eventID {
		return nil, fmt.Errorf("event %s not found in transition %s", eventID, transitionID)
	}
	return r.transitions.Update(ctx, transitionID, &petri.TransitionUpdate{
		Input: &petri.TransitionInput{
			Event: nil,
		},
		Mask: &petri.TransitionMask{
			Event: true,
		},
	})
}

// UpdateEvent is the resolver for the updateEvent field.
func (r *mutationResolver) UpdateEvent(ctx context.Context, id string, input petri.EventUpdate) (*petri.EventSchema, error) {
	return r.eventSchema.Update(ctx, id, &input)
}

// ActiveSessions is the resolver for the activeSessions field.
func (r *queryResolver) ActiveSessions(ctx context.Context) ([]*model.Session, error) {
	panic(fmt.Errorf("not implemented: ActiveSessions - activeSessions"))
}

// Sessions is the resolver for the sessions field.
func (r *queryResolver) Sessions(ctx context.Context, runID string) ([]*model.Session, error) {
	panic(fmt.Errorf("not implemented: Sessions - sessions"))
}

// CurrentStep is the resolver for the currentStep field.
func (r *queryResolver) CurrentStep(ctx context.Context, sessionID string) (int, error) {
	panic(fmt.Errorf("not implemented: CurrentStep - currentStep"))
}

// EventHistory is the resolver for the eventHistory field.
func (r *queryResolver) EventHistory(ctx context.Context, sessionID string) ([]*model.Event, error) {
	panic(fmt.Errorf("not implemented: EventHistory - eventHistory"))
}

// Instances is the resolver for the instances field.
func (r *queryResolver) Instances(ctx context.Context, runID string) ([]*model.Instance, error) {
	panic(fmt.Errorf("not implemented: Instances - instances"))
}

// Devices is the resolver for the devices field.
func (r *queryResolver) Devices(ctx context.Context, filter *string) ([]*model.Device, error) {
	panic(fmt.Errorf("not implemented: Devices - devices"))
}

// DeviceMarkings is the resolver for the deviceMarkings field.
func (r *queryResolver) DeviceMarkings(ctx context.Context, input model.DeviceMarkingsInput) ([]*model.DeviceMarking, error) {
	panic(fmt.Errorf("not implemented: DeviceMarkings - deviceMarkings"))
}

// NewEvents is the resolver for the newEvents field.
func (r *queryResolver) NewEvents(ctx context.Context, sessionID string) ([]*model.Event, error) {
	panic(fmt.Errorf("not implemented: NewEvents - newEvents"))
}

// Nets is the resolver for the nets field.
func (r *queryResolver) Nets(ctx context.Context, filter *petri.NetFilter) ([]*petri.Net, error) {
	return r.nets.List(ctx, filter)
}

// PlacesInNet is the resolver for the placesInNet field.
func (r *queryResolver) PlacesInNet(ctx context.Context, netID string) ([]*petri.Place, error) {
	n, err := r.nets.Get(ctx, netID)
	if err != nil {
		return nil, err
	}
	ids := make([]string, len(n.Places))
	for i, p := range n.Places {
		ids[i] = p.ID
	}
	return r.places.List(ctx, &petri.PlaceFilter{ID: &petri.StringSelector{
		In: ids,
	},
	})
}

// TransitionsInNet is the resolver for the transitionsInNet field.
func (r *queryResolver) TransitionsInNet(ctx context.Context, netID string) ([]*petri.Transition, error) {
	n, err := r.nets.Get(ctx, netID)
	if err != nil {
		return nil, err
	}
	ids := make([]string, len(n.Transitions))
	for i, t := range n.Transitions {
		ids[i] = t.ID
	}
	return r.transitions.List(ctx, &petri.TransitionFilter{ID: &petri.StringSelector{
		In: ids,
	},
	})
}

// ArcsInNet is the resolver for the arcsInNet field.
func (r *queryResolver) ArcsInNet(ctx context.Context, netID string) ([]*petri.Arc, error) {
	n, err := r.nets.Get(ctx, netID)
	if err != nil {
		return nil, err
	}
	ids := make([]string, len(n.Arcs))
	for i, arc := range n.Arcs {
		ids[i] = arc.ID
	}
	return r.arcs.List(ctx, &petri.ArcFilter{ID: &petri.StringSelector{
		In: ids,
	},
	})
}

// NetsInNet is the resolver for the netsInNet field.
func (r *queryResolver) NetsInNet(ctx context.Context, netID string) ([]*petri.Net, error) {
	n, err := r.nets.Get(ctx, netID)
	if err != nil {
		return nil, err
	}
	ids := make([]string, len(n.Nets))
	for i, net := range n.Nets {
		ids[i] = net.ID
	}
	return r.nets.List(ctx, &petri.NetFilter{ID: &petri.StringSelector{
		In: ids,
	}})
}

// TokenSchemaInNet is the resolver for the tokenSchemaInNet field.
func (r *queryResolver) TokenSchemaInNet(ctx context.Context, netID string) ([]*petri.TokenSchema, error) {
	n, err := r.nets.Get(ctx, netID)
	if err != nil {
		return nil, err
	}
	ids := make([]string, len(n.TokenSchemas))
	for i, tok := range n.TokenSchemas {
		ids[i] = tok.ID
	}
	return r.tokenSchema.List(ctx, &petri.TokenFilter{ID: &petri.StringSelector{
		In: ids,
	}})
}

// TokenSchemaByID is the resolver for the tokenSchemaByID field.
func (r *queryResolver) TokenSchemaByID(ctx context.Context, id string) (*petri.TokenSchema, error) {
	return r.tokenSchema.Get(ctx, id)
}

// TokenSchemas is the resolver for the tokenSchemas field.
func (r *queryResolver) TokenSchemas(ctx context.Context, filter *petri.TokenFilter) ([]*petri.TokenSchema, error) {
	return r.tokenSchema.List(ctx, filter)
}

// Places is the resolver for the places field.
func (r *queryResolver) Places(ctx context.Context, filter *petri.PlaceFilter) ([]*petri.Place, error) {
	return r.places.List(ctx, filter)
}

// Transitions is the resolver for the transitions field.
func (r *queryResolver) Transitions(ctx context.Context, filter *petri.TransitionFilter) ([]*petri.Transition, error) {
	return r.transitions.List(ctx, filter)
}

// Arcs is the resolver for the arcs field.
func (r *queryResolver) Arcs(ctx context.Context, filter *petri.ArcFilter) ([]*petri.Arc, error) {
	return r.arcs.List(ctx, filter)
}

// PlaceByID is the resolver for the placeByID field.
func (r *queryResolver) PlaceByID(ctx context.Context, id string) (*petri.Place, error) {
	return r.places.Get(ctx, id)
}

// TransitionByID is the resolver for the transitionByID field.
func (r *queryResolver) TransitionByID(ctx context.Context, id string) (*petri.Transition, error) {
	return r.transitions.Get(ctx, id)
}

// ArcByID is the resolver for the arcByID field.
func (r *queryResolver) ArcByID(ctx context.Context, id string) (*petri.Arc, error) {
	return r.arcs.Get(ctx, id)
}

// NetByID is the resolver for the netByID field.
func (r *queryResolver) NetByID(ctx context.Context, id string) (*petri.Net, error) {
	return r.nets.Get(ctx, id)
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
